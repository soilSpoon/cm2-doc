<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CM2 Math1 SDK: Vector-Vector Basic Template Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">CM2 Math1 SDK<span id="projectnumber">&#160;5.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group___vec_vec_basic_group.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Vector-Vector Basic Template Functions </div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9e6ef592ace7645c9101a47593c178b2" id="r_ga9e6ef592ace7645c9101a47593c178b2"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga9e6ef592ace7645c9101a47593c178b2 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e6ef592ace7645c9101a47593c178b2">cm2::vecvec::copy2</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga9e6ef592ace7645c9101a47593c178b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga07c074098e64fefeaa144f6e7874a8e0" id="r_ga07c074098e64fefeaa144f6e7874a8e0"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga07c074098e64fefeaa144f6e7874a8e0 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga07c074098e64fefeaa144f6e7874a8e0">cm2::vecvec::copy3</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga07c074098e64fefeaa144f6e7874a8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga64227412d61228fd3c1bfed1ca2e04e8" id="r_ga64227412d61228fd3c1bfed1ca2e04e8"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga64227412d61228fd3c1bfed1ca2e04e8 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64227412d61228fd3c1bfed1ca2e04e8">cm2::vecvec::copy_n</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga64227412d61228fd3c1bfed1ca2e04e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaea3661b996c334d9e3b20e8084a5ab62" id="r_gaea3661b996c334d9e3b20e8084a5ab62"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaea3661b996c334d9e3b20e8084a5ab62 template"><td class="memItemLeft" align="right" valign="top">IterY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea3661b996c334d9e3b20e8084a5ab62">cm2::vecvec::copy_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gaea3661b996c334d9e3b20e8084a5ab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy.  <br /></td></tr>
<tr class="memitem:ga34dc8a2626fb6ef60286216f88f8d1a6" id="r_ga34dc8a2626fb6ef60286216f88f8d1a6"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga34dc8a2626fb6ef60286216f88f8d1a6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34dc8a2626fb6ef60286216f88f8d1a6">cm2::vecvec::swap2</a> (T *CM2_RESTRICT x, T *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga34dc8a2626fb6ef60286216f88f8d1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise swap (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga2615b70a9805e5ed9f6583e334964166" id="r_ga2615b70a9805e5ed9f6583e334964166"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga2615b70a9805e5ed9f6583e334964166 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2615b70a9805e5ed9f6583e334964166">cm2::vecvec::swap3</a> (T *CM2_RESTRICT x, T *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga2615b70a9805e5ed9f6583e334964166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise swap (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga0c0e5386841cb75cac9226672a41ddca" id="r_ga0c0e5386841cb75cac9226672a41ddca"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga0c0e5386841cb75cac9226672a41ddca template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0c0e5386841cb75cac9226672a41ddca">cm2::vecvec::swap_n</a> (T *CM2_RESTRICT x, T *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga0c0e5386841cb75cac9226672a41ddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise swap (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga164106c2ded04788bdda090457c3e3bf" id="r_ga164106c2ded04788bdda090457c3e3bf"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga164106c2ded04788bdda090457c3e3bf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga164106c2ded04788bdda090457c3e3bf">cm2::vecvec::swap_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga164106c2ded04788bdda090457c3e3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise swap.  <br /></td></tr>
<tr class="memitem:ga5d74314d9a64366505691c34cc4676e6" id="r_ga5d74314d9a64366505691c34cc4676e6"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:ga5d74314d9a64366505691c34cc4676e6 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d74314d9a64366505691c34cc4676e6">cm2::vecvec::copy_scale2</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga5d74314d9a64366505691c34cc4676e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaac21b1bc0b90b3742846bea620892505" id="r_gaac21b1bc0b90b3742846bea620892505"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:gaac21b1bc0b90b3742846bea620892505 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac21b1bc0b90b3742846bea620892505">cm2::vecvec::copy_scale3</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gaac21b1bc0b90b3742846bea620892505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga388a1e6886c383e616471c26150c8ac7" id="r_ga388a1e6886c383e616471c26150c8ac7"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:ga388a1e6886c383e616471c26150c8ac7 template"><td class="memItemLeft" align="right" valign="top">TY *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga388a1e6886c383e616471c26150c8ac7">cm2::vecvec::copy_scale_n</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga388a1e6886c383e616471c26150c8ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise copy with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga65a82eea4d0533f2314ea904ea729855" id="r_ga65a82eea4d0533f2314ea904ea729855"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga65a82eea4d0533f2314ea904ea729855 template"><td class="memItemLeft" align="right" valign="top">IterY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65a82eea4d0533f2314ea904ea729855">cm2::vecvec::copy_scale_n</a> (T a, IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga65a82eea4d0533f2314ea904ea729855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling.  <br /></td></tr>
<tr class="memitem:gad1f3fa5d668f91f4c0fc6ed8e822a9bf" id="r_gad1f3fa5d668f91f4c0fc6ed8e822a9bf"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gad1f3fa5d668f91f4c0fc6ed8e822a9bf template"><td class="memItemLeft" align="right" valign="top">IterY&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1f3fa5d668f91f4c0fc6ed8e822a9bf">cm2::vecvec::copy_scale_n_par</a> (T a, IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gad1f3fa5d668f91f4c0fc6ed8e822a9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (parallel version with iterators).  <br /></td></tr>
<tr class="memitem:gad3c357b5290a959dcb242631d2175c3d" id="r_gad3c357b5290a959dcb242631d2175c3d"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:gad3c357b5290a959dcb242631d2175c3d template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad3c357b5290a959dcb242631d2175c3d">cm2::vecvec::copy_add2</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gad3c357b5290a959dcb242631d2175c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaa44a4fc8a3e8ff7cc85db98a74e35f80" id="r_gaa44a4fc8a3e8ff7cc85db98a74e35f80"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:gaa44a4fc8a3e8ff7cc85db98a74e35f80 template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa44a4fc8a3e8ff7cc85db98a74e35f80">cm2::vecvec::copy_add3</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gaa44a4fc8a3e8ff7cc85db98a74e35f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaf2113aa3c7138ccff4379882077b16db" id="r_gaf2113aa3c7138ccff4379882077b16db"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:gaf2113aa3c7138ccff4379882077b16db template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2113aa3c7138ccff4379882077b16db">cm2::vecvec::copy_add_n</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:gaf2113aa3c7138ccff4379882077b16db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaa7b2e6084e7ebd5b4e47f00938098139" id="r_gaa7b2e6084e7ebd5b4e47f00938098139"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gaa7b2e6084e7ebd5b4e47f00938098139 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa7b2e6084e7ebd5b4e47f00938098139">cm2::vecvec::copy_add_n</a> (IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:gaa7b2e6084e7ebd5b4e47f00938098139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum.  <br /></td></tr>
<tr class="memitem:gae1f8421e03f22db1ba06abbde9b8137f" id="r_gae1f8421e03f22db1ba06abbde9b8137f"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gae1f8421e03f22db1ba06abbde9b8137f template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae1f8421e03f22db1ba06abbde9b8137f">cm2::vecvec::copy_add_n_par</a> (IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gae1f8421e03f22db1ba06abbde9b8137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum.  <br /></td></tr>
<tr class="memitem:ga1c881d2845b9c92b665cdd71cb8ef417" id="r_ga1c881d2845b9c92b665cdd71cb8ef417"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga1c881d2845b9c92b665cdd71cb8ef417 template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c881d2845b9c92b665cdd71cb8ef417">cm2::vecvec::copy_add2</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:ga1c881d2845b9c92b665cdd71cb8ef417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gafbd57c31513203dd599889b1ed70dd7e" id="r_gafbd57c31513203dd599889b1ed70dd7e"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:gafbd57c31513203dd599889b1ed70dd7e template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbd57c31513203dd599889b1ed70dd7e">cm2::vecvec::copy_add3</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gafbd57c31513203dd599889b1ed70dd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga224428e769d4ac719f784205b33cd97e" id="r_ga224428e769d4ac719f784205b33cd97e"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga224428e769d4ac719f784205b33cd97e template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga224428e769d4ac719f784205b33cd97e">cm2::vecvec::copy_add_n</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:ga224428e769d4ac719f784205b33cd97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling.  <br /></td></tr>
<tr class="memitem:gadea1068e723b0588bba7518a95a189bc" id="r_gadea1068e723b0588bba7518a95a189bc"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gadea1068e723b0588bba7518a95a189bc template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadea1068e723b0588bba7518a95a189bc">cm2::vecvec::copy_add_n</a> (T a, IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:gadea1068e723b0588bba7518a95a189bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling.  <br /></td></tr>
<tr class="memitem:ga8af27f7c9a26f1d1b996f5a679464ab2" id="r_ga8af27f7c9a26f1d1b996f5a679464ab2"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga8af27f7c9a26f1d1b996f5a679464ab2 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8af27f7c9a26f1d1b996f5a679464ab2">cm2::vecvec::copy_add_n_par</a> (T a, IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga8af27f7c9a26f1d1b996f5a679464ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (parallel version with pointers).  <br /></td></tr>
<tr class="memitem:gaabcd915bb07fcb024b0fd74879ef8257" id="r_gaabcd915bb07fcb024b0fd74879ef8257"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ, class TW&gt; </td></tr>
<tr class="memitem:gaabcd915bb07fcb024b0fd74879ef8257 template"><td class="memItemLeft" align="right" valign="top">TW *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaabcd915bb07fcb024b0fd74879ef8257">cm2::vecvec::copy_add2</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, const TZ *CM2_RESTRICT z, TW *CM2_RESTRICT w)</td></tr>
<tr class="memdesc:gaabcd915bb07fcb024b0fd74879ef8257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga5345e78c03e25093a34dd4cfdffcfe91" id="r_ga5345e78c03e25093a34dd4cfdffcfe91"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ, class TW&gt; </td></tr>
<tr class="memitem:ga5345e78c03e25093a34dd4cfdffcfe91 template"><td class="memItemLeft" align="right" valign="top">TW *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5345e78c03e25093a34dd4cfdffcfe91">cm2::vecvec::copy_add3</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, const TZ *CM2_RESTRICT z, TW *CM2_RESTRICT w)</td></tr>
<tr class="memdesc:ga5345e78c03e25093a34dd4cfdffcfe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga6bd6ba6c2c6304eacff6b3aa79337f81" id="r_ga6bd6ba6c2c6304eacff6b3aa79337f81"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ, class TW&gt; </td></tr>
<tr class="memitem:ga6bd6ba6c2c6304eacff6b3aa79337f81 template"><td class="memItemLeft" align="right" valign="top">TW *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6bd6ba6c2c6304eacff6b3aa79337f81">cm2::vecvec::copy_add_n</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, const TZ *CM2_RESTRICT z, TW *CM2_RESTRICT w, size_t n)</td></tr>
<tr class="memdesc:ga6bd6ba6c2c6304eacff6b3aa79337f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga8c8db799afd6f8fad06e4b6451abe3c4" id="r_ga8c8db799afd6f8fad06e4b6451abe3c4"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ, class IterW&gt; </td></tr>
<tr class="memitem:ga8c8db799afd6f8fad06e4b6451abe3c4 template"><td class="memItemLeft" align="right" valign="top">IterW&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c8db799afd6f8fad06e4b6451abe3c4">cm2::vecvec::copy_add_n</a> (T a, IterX x, IterY y, IterZ z, IterW w, size_t n)</td></tr>
<tr class="memdesc:ga8c8db799afd6f8fad06e4b6451abe3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling.  <br /></td></tr>
<tr class="memitem:ga6a524d001b704fd0bfff359908fac5e2" id="r_ga6a524d001b704fd0bfff359908fac5e2"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ, class IterW&gt; </td></tr>
<tr class="memitem:ga6a524d001b704fd0bfff359908fac5e2 template"><td class="memItemLeft" align="right" valign="top">IterW&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a524d001b704fd0bfff359908fac5e2">cm2::vecvec::copy_add_n_par</a> (T a, IterX x, IterY y, IterZ z, IterW w, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga6a524d001b704fd0bfff359908fac5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum with scaling.  <br /></td></tr>
<tr class="memitem:gaea80fb538a89accb1d54d5fd9a8c8e2e" id="r_gaea80fb538a89accb1d54d5fd9a8c8e2e"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:gaea80fb538a89accb1d54d5fd9a8c8e2e template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea80fb538a89accb1d54d5fd9a8c8e2e">cm2::vecvec::copy_diff2</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gaea80fb538a89accb1d54d5fd9a8c8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga0420b09374c2d24b75ae6437d705a53a" id="r_ga0420b09374c2d24b75ae6437d705a53a"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga0420b09374c2d24b75ae6437d705a53a template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0420b09374c2d24b75ae6437d705a53a">cm2::vecvec::copy_diff3</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:ga0420b09374c2d24b75ae6437d705a53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga259e1579ed7b635c7415c46e8959b2cc" id="r_ga259e1579ed7b635c7415c46e8959b2cc"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga259e1579ed7b635c7415c46e8959b2cc template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga259e1579ed7b635c7415c46e8959b2cc">cm2::vecvec::copy_diff_n</a> (const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:ga259e1579ed7b635c7415c46e8959b2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga51d39d03cb0378ae2c48167113665022" id="r_ga51d39d03cb0378ae2c48167113665022"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga51d39d03cb0378ae2c48167113665022 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51d39d03cb0378ae2c48167113665022">cm2::vecvec::copy_diff_n</a> (IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:ga51d39d03cb0378ae2c48167113665022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference.  <br /></td></tr>
<tr class="memitem:gafbafef6c859fc87b332188a8c9141e92" id="r_gafbafef6c859fc87b332188a8c9141e92"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gafbafef6c859fc87b332188a8c9141e92 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbafef6c859fc87b332188a8c9141e92">cm2::vecvec::copy_diff_n_par</a> (IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gafbafef6c859fc87b332188a8c9141e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference (parallel version with pointers).  <br /></td></tr>
<tr class="memitem:ga9381312fb5d1505d392be7b0a8f64600" id="r_ga9381312fb5d1505d392be7b0a8f64600"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga9381312fb5d1505d392be7b0a8f64600 template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9381312fb5d1505d392be7b0a8f64600">cm2::vecvec::copy_diff2</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:ga9381312fb5d1505d392be7b0a8f64600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga3497d12c5e845061ba059ef2feb81611" id="r_ga3497d12c5e845061ba059ef2feb81611"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga3497d12c5e845061ba059ef2feb81611 template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3497d12c5e845061ba059ef2feb81611">cm2::vecvec::copy_diff3</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:ga3497d12c5e845061ba059ef2feb81611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga4f2beab778dcce0f51b0637ee4a6880b" id="r_ga4f2beab778dcce0f51b0637ee4a6880b"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY, class TZ&gt; </td></tr>
<tr class="memitem:ga4f2beab778dcce0f51b0637ee4a6880b template"><td class="memItemLeft" align="right" valign="top">TZ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f2beab778dcce0f51b0637ee4a6880b">cm2::vecvec::copy_diff_n</a> (T a, const TX *CM2_RESTRICT x, const TY *CM2_RESTRICT y, TZ *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:ga4f2beab778dcce0f51b0637ee4a6880b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference with scaling (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga7c3832db9f3b654ffa5ccaee896a27d4" id="r_ga7c3832db9f3b654ffa5ccaee896a27d4"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga7c3832db9f3b654ffa5ccaee896a27d4 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c3832db9f3b654ffa5ccaee896a27d4">cm2::vecvec::copy_diff_n</a> (T a, IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:ga7c3832db9f3b654ffa5ccaee896a27d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference with scaling.  <br /></td></tr>
<tr class="memitem:ga76e7d359e29150f1ba523514fec3a666" id="r_ga76e7d359e29150f1ba523514fec3a666"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga76e7d359e29150f1ba523514fec3a666 template"><td class="memItemLeft" align="right" valign="top">IterZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga76e7d359e29150f1ba523514fec3a666">cm2::vecvec::copy_diff_n_par</a> (T a, IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga76e7d359e29150f1ba523514fec3a666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise difference with scaling.  <br /></td></tr>
<tr class="memitem:ga521b31e2953ae75ef76c1068874ad3ef" id="r_ga521b31e2953ae75ef76c1068874ad3ef"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga521b31e2953ae75ef76c1068874ad3ef template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga521b31e2953ae75ef76c1068874ad3ef">cm2::vecvec::add2</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga521b31e2953ae75ef76c1068874ad3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise add (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga90e04db4a98bcf86410ea01cfd156b59" id="r_ga90e04db4a98bcf86410ea01cfd156b59"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga90e04db4a98bcf86410ea01cfd156b59 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga90e04db4a98bcf86410ea01cfd156b59">cm2::vecvec::add3</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga90e04db4a98bcf86410ea01cfd156b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise add (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga249ef68503ce3ac8f897da9d9c8c26be" id="r_ga249ef68503ce3ac8f897da9d9c8c26be"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga249ef68503ce3ac8f897da9d9c8c26be template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga249ef68503ce3ac8f897da9d9c8c26be">cm2::vecvec::add_n</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga249ef68503ce3ac8f897da9d9c8c26be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise add (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gac997c2b5d217724672f0d6d2063e044f" id="r_gac997c2b5d217724672f0d6d2063e044f"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gac997c2b5d217724672f0d6d2063e044f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac997c2b5d217724672f0d6d2063e044f">cm2::vecvec::add_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gac997c2b5d217724672f0d6d2063e044f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise add.  <br /></td></tr>
<tr class="memitem:ga60a44636b534ea2f789538528a7a85bd" id="r_ga60a44636b534ea2f789538528a7a85bd"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga60a44636b534ea2f789538528a7a85bd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60a44636b534ea2f789538528a7a85bd">cm2::vecvec::add_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga60a44636b534ea2f789538528a7a85bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise add.  <br /></td></tr>
<tr class="memitem:ga9473e8a9c13b3d50022a3b89cb82b691" id="r_ga9473e8a9c13b3d50022a3b89cb82b691"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga9473e8a9c13b3d50022a3b89cb82b691 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9473e8a9c13b3d50022a3b89cb82b691">cm2::vecvec::subtract2</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga9473e8a9c13b3d50022a3b89cb82b691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise subtract (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga7f4822b5f6a30a4faf19c0dced5dc868" id="r_ga7f4822b5f6a30a4faf19c0dced5dc868"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga7f4822b5f6a30a4faf19c0dced5dc868 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f4822b5f6a30a4faf19c0dced5dc868">cm2::vecvec::subtract3</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga7f4822b5f6a30a4faf19c0dced5dc868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise subtract (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga9f1992265d68192b12e44b0164e0d0da" id="r_ga9f1992265d68192b12e44b0164e0d0da"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga9f1992265d68192b12e44b0164e0d0da template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9f1992265d68192b12e44b0164e0d0da">cm2::vecvec::subtract_n</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga9f1992265d68192b12e44b0164e0d0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise subtract (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga8d8ecdb7f072b43c856d5dc8adfa1017" id="r_ga8d8ecdb7f072b43c856d5dc8adfa1017"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga8d8ecdb7f072b43c856d5dc8adfa1017 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d8ecdb7f072b43c856d5dc8adfa1017">cm2::vecvec::subtract_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga8d8ecdb7f072b43c856d5dc8adfa1017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise subtract.  <br /></td></tr>
<tr class="memitem:ga4c7f8ce85cbe553bc3360e5e74b47c27" id="r_ga4c7f8ce85cbe553bc3360e5e74b47c27"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga4c7f8ce85cbe553bc3360e5e74b47c27 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4c7f8ce85cbe553bc3360e5e74b47c27">cm2::vecvec::subtract_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga4c7f8ce85cbe553bc3360e5e74b47c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise subtract.  <br /></td></tr>
<tr class="memitem:gadf1b81c36fe815c71e2b53780452d4df" id="r_gadf1b81c36fe815c71e2b53780452d4df"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:gadf1b81c36fe815c71e2b53780452d4df template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf1b81c36fe815c71e2b53780452d4df">cm2::vecvec::mult2</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gadf1b81c36fe815c71e2b53780452d4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise mult (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga2cab962350c3d5f9e2c81ef29135ddb6" id="r_ga2cab962350c3d5f9e2c81ef29135ddb6"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga2cab962350c3d5f9e2c81ef29135ddb6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2cab962350c3d5f9e2c81ef29135ddb6">cm2::vecvec::mult3</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga2cab962350c3d5f9e2c81ef29135ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise mult (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gadb732691fe89ad630be64d2fbac01dd0" id="r_gadb732691fe89ad630be64d2fbac01dd0"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:gadb732691fe89ad630be64d2fbac01dd0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb732691fe89ad630be64d2fbac01dd0">cm2::vecvec::mult_n</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:gadb732691fe89ad630be64d2fbac01dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise mult (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga19dc8ded1fc3a2b506cfe0cd0d2024f7" id="r_ga19dc8ded1fc3a2b506cfe0cd0d2024f7"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga19dc8ded1fc3a2b506cfe0cd0d2024f7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19dc8ded1fc3a2b506cfe0cd0d2024f7">cm2::vecvec::mult_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga19dc8ded1fc3a2b506cfe0cd0d2024f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise mult.  <br /></td></tr>
<tr class="memitem:ga31bfc80412345363190bfff19a623346" id="r_ga31bfc80412345363190bfff19a623346"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga31bfc80412345363190bfff19a623346 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31bfc80412345363190bfff19a623346">cm2::vecvec::mult_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga31bfc80412345363190bfff19a623346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise mult.  <br /></td></tr>
<tr class="memitem:ga6492a1347950fb57e784c852a0fa86ad" id="r_ga6492a1347950fb57e784c852a0fa86ad"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga6492a1347950fb57e784c852a0fa86ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6492a1347950fb57e784c852a0fa86ad">cm2::vecvec::div2</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga6492a1347950fb57e784c852a0fa86ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise div (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gaf65db05e268e1b5b810c5af079ec373e" id="r_gaf65db05e268e1b5b810c5af079ec373e"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:gaf65db05e268e1b5b810c5af079ec373e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf65db05e268e1b5b810c5af079ec373e">cm2::vecvec::div3</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gaf65db05e268e1b5b810c5af079ec373e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise div (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga934a999755e021f7523a77b61134fd32" id="r_ga934a999755e021f7523a77b61134fd32"><td class="memTemplParams" colspan="2">template&lt;class TX, class TY&gt; </td></tr>
<tr class="memitem:ga934a999755e021f7523a77b61134fd32 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga934a999755e021f7523a77b61134fd32">cm2::vecvec::div_n</a> (const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga934a999755e021f7523a77b61134fd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise div (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga1ccd891a914ba269f30d2d66d7a0c173" id="r_ga1ccd891a914ba269f30d2d66d7a0c173"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga1ccd891a914ba269f30d2d66d7a0c173 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ccd891a914ba269f30d2d66d7a0c173">cm2::vecvec::div_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga1ccd891a914ba269f30d2d66d7a0c173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise div.  <br /></td></tr>
<tr class="memitem:gaa9efdc83c79f607d3dee41c55f9d55aa" id="r_gaa9efdc83c79f607d3dee41c55f9d55aa"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaa9efdc83c79f607d3dee41c55f9d55aa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9efdc83c79f607d3dee41c55f9d55aa">cm2::vecvec::div_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gaa9efdc83c79f607d3dee41c55f9d55aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise div.  <br /></td></tr>
<tr class="memitem:gad23b018f10e937f524be274ab051b7f5" id="r_gad23b018f10e937f524be274ab051b7f5"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:gad23b018f10e937f524be274ab051b7f5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad23b018f10e937f524be274ab051b7f5">cm2::vecvec::axpy2</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gad23b018f10e937f524be274ab051b7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXPY (serial version with pointers).  <br /></td></tr>
<tr class="memitem:gab79ffb425c4da6757752091d670c467a" id="r_gab79ffb425c4da6757752091d670c467a"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:gab79ffb425c4da6757752091d670c467a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab79ffb425c4da6757752091d670c467a">cm2::vecvec::axpy3</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gab79ffb425c4da6757752091d670c467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXPY (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga1f8efd3305242cc05e3044ee54ba1bd9" id="r_ga1f8efd3305242cc05e3044ee54ba1bd9"><td class="memTemplParams" colspan="2">template&lt;class T, class TX, class TY&gt; </td></tr>
<tr class="memitem:ga1f8efd3305242cc05e3044ee54ba1bd9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f8efd3305242cc05e3044ee54ba1bd9">cm2::vecvec::axpy_n</a> (T a, const TX *CM2_RESTRICT x, TY *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga1f8efd3305242cc05e3044ee54ba1bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXPY (serial version with pointers).  <br /></td></tr>
<tr class="memitem:ga9b2a27c13914a8ce9f89d4f0d45b1f05" id="r_ga9b2a27c13914a8ce9f89d4f0d45b1f05"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga9b2a27c13914a8ce9f89d4f0d45b1f05 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b2a27c13914a8ce9f89d4f0d45b1f05">cm2::vecvec::axpy_n</a> (T a, IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga9b2a27c13914a8ce9f89d4f0d45b1f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXPY (serial version).  <br /></td></tr>
<tr class="memitem:gaa1182729b3933e546198fbf67da43849" id="r_gaa1182729b3933e546198fbf67da43849"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaa1182729b3933e546198fbf67da43849 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1182729b3933e546198fbf67da43849">cm2::vecvec::axpy_n_par</a> (T a, IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gaa1182729b3933e546198fbf67da43849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXPY (parallel version).  <br /></td></tr>
<tr class="memitem:gac4395bdd23a0d2769df2c53b95ddf1e0" id="r_gac4395bdd23a0d2769df2c53b95ddf1e0"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gac4395bdd23a0d2769df2c53b95ddf1e0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4395bdd23a0d2769df2c53b95ddf1e0">cm2::vecvec::axypz2</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gac4395bdd23a0d2769df2c53b95ddf1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXYPZ.  <br /></td></tr>
<tr class="memitem:gadf9662a212ee92c5af852a728f8a84f6" id="r_gadf9662a212ee92c5af852a728f8a84f6"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gadf9662a212ee92c5af852a728f8a84f6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf9662a212ee92c5af852a728f8a84f6">cm2::vecvec::axypz3</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gadf9662a212ee92c5af852a728f8a84f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXYPZ.  <br /></td></tr>
<tr class="memitem:gac51eed9dea9c17eb1df71c2488657a55" id="r_gac51eed9dea9c17eb1df71c2488657a55"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gac51eed9dea9c17eb1df71c2488657a55 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac51eed9dea9c17eb1df71c2488657a55">cm2::vecvec::axypz_n</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:gac51eed9dea9c17eb1df71c2488657a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXYPZ.  <br /></td></tr>
<tr class="memitem:ga50944f876805890658b3b5cd5cdbd8ce" id="r_ga50944f876805890658b3b5cd5cdbd8ce"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga50944f876805890658b3b5cd5cdbd8ce template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50944f876805890658b3b5cd5cdbd8ce">cm2::vecvec::axypz_n</a> (T a, IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:ga50944f876805890658b3b5cd5cdbd8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXYPZ.  <br /></td></tr>
<tr class="memitem:ga71206cf9ed67809672a228552fc7883a" id="r_ga71206cf9ed67809672a228552fc7883a"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga71206cf9ed67809672a228552fc7883a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71206cf9ed67809672a228552fc7883a">cm2::vecvec::axypz_n_par</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga71206cf9ed67809672a228552fc7883a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AXYPZ.  <br /></td></tr>
<tr class="memitem:gab97910f3160fabdd6a7714c59eb76d86" id="r_gab97910f3160fabdd6a7714c59eb76d86"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gab97910f3160fabdd6a7714c59eb76d86 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab97910f3160fabdd6a7714c59eb76d86">cm2::vecvec::interpol2</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gab97910f3160fabdd6a7714c59eb76d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise interpolation.  <br /></td></tr>
<tr class="memitem:gaff32fbdd39ac34ec03acf35f292f169e" id="r_gaff32fbdd39ac34ec03acf35f292f169e"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gaff32fbdd39ac34ec03acf35f292f169e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaff32fbdd39ac34ec03acf35f292f169e">cm2::vecvec::interpol3</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z)</td></tr>
<tr class="memdesc:gaff32fbdd39ac34ec03acf35f292f169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise interpolation.  <br /></td></tr>
<tr class="memitem:ga51cf028980f59d6294c1f7301ffdd6ba" id="r_ga51cf028980f59d6294c1f7301ffdd6ba"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga51cf028980f59d6294c1f7301ffdd6ba template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51cf028980f59d6294c1f7301ffdd6ba">cm2::vecvec::interpol_n</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z, size_t n)</td></tr>
<tr class="memdesc:ga51cf028980f59d6294c1f7301ffdd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise interpolation.  <br /></td></tr>
<tr class="memitem:gaddccb4e76a033a078c71afce440ae61b" id="r_gaddccb4e76a033a078c71afce440ae61b"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gaddccb4e76a033a078c71afce440ae61b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddccb4e76a033a078c71afce440ae61b">cm2::vecvec::interpol_n</a> (T a, IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:gaddccb4e76a033a078c71afce440ae61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise interpolation.  <br /></td></tr>
<tr class="memitem:ga427db881b6c8ac76667097e2408665e2" id="r_ga427db881b6c8ac76667097e2408665e2"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga427db881b6c8ac76667097e2408665e2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga427db881b6c8ac76667097e2408665e2">cm2::vecvec::interpol_n_par</a> (T a, const T *CM2_RESTRICT x, const T *CM2_RESTRICT y, T *CM2_RESTRICT z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga427db881b6c8ac76667097e2408665e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise interpolation.  <br /></td></tr>
<tr class="memitem:gae9ae0a973ddbfda73fa7deeadca4791f" id="r_gae9ae0a973ddbfda73fa7deeadca4791f"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gae9ae0a973ddbfda73fa7deeadca4791f template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9ae0a973ddbfda73fa7deeadca4791f">cm2::vecvec::dot2</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:gae9ae0a973ddbfda73fa7deeadca4791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product (serial version).  <br /></td></tr>
<tr class="memitem:ga30b1bf24378e2be63709cd98c5cd7fc9" id="r_ga30b1bf24378e2be63709cd98c5cd7fc9"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga30b1bf24378e2be63709cd98c5cd7fc9 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30b1bf24378e2be63709cd98c5cd7fc9">cm2::vecvec::dot3</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga30b1bf24378e2be63709cd98c5cd7fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product (serial version).  <br /></td></tr>
<tr class="memitem:gaec08ae8bb8acd77f531a5d8aa89906a8" id="r_gaec08ae8bb8acd77f531a5d8aa89906a8"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaec08ae8bb8acd77f531a5d8aa89906a8 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec08ae8bb8acd77f531a5d8aa89906a8">cm2::vecvec::dot_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gaec08ae8bb8acd77f531a5d8aa89906a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product (serial version).  <br /></td></tr>
<tr class="memitem:ga15066c5806e60da0df9efedd7b3951af" id="r_ga15066c5806e60da0df9efedd7b3951af"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga15066c5806e60da0df9efedd7b3951af template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga15066c5806e60da0df9efedd7b3951af">cm2::vecvec::dot_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga15066c5806e60da0df9efedd7b3951af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product (parallel version).  <br /></td></tr>
<tr class="memitem:ga3f8a2950bc4cc6cf61623bbc5a8762bc" id="r_ga3f8a2950bc4cc6cf61623bbc5a8762bc"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga3f8a2950bc4cc6cf61623bbc5a8762bc template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f8a2950bc4cc6cf61623bbc5a8762bc">cm2::vecvec::dot2</a> (IterX x, IterY y, IterZ z)</td></tr>
<tr class="memdesc:ga3f8a2950bc4cc6cf61623bbc5a8762bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between three vectors (serial version).  <br /></td></tr>
<tr class="memitem:gafe1a41396521f76e92e6e68ac5051ebc" id="r_gafe1a41396521f76e92e6e68ac5051ebc"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gafe1a41396521f76e92e6e68ac5051ebc template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe1a41396521f76e92e6e68ac5051ebc">cm2::vecvec::dot3</a> (IterX x, IterY y, IterZ z)</td></tr>
<tr class="memdesc:gafe1a41396521f76e92e6e68ac5051ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between three vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga5c92dc26794f85b47b9322a1b6db051c" id="r_ga5c92dc26794f85b47b9322a1b6db051c"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga5c92dc26794f85b47b9322a1b6db051c template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c92dc26794f85b47b9322a1b6db051c">cm2::vecvec::dot_n</a> (IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:ga5c92dc26794f85b47b9322a1b6db051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between three vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga847437ccb7559e3988194dc938f18070" id="r_ga847437ccb7559e3988194dc938f18070"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga847437ccb7559e3988194dc938f18070 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga847437ccb7559e3988194dc938f18070">cm2::vecvec::dot_n_par</a> (IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga847437ccb7559e3988194dc938f18070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between three vectors (parallel version).  <br /></td></tr>
<tr class="memitem:ga61c68f7a5413e733682ff9a123f89abc" id="r_ga61c68f7a5413e733682ff9a123f89abc"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga61c68f7a5413e733682ff9a123f89abc template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga61c68f7a5413e733682ff9a123f89abc">cm2::vecvec::Herm_dot2</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga61c68f7a5413e733682ff9a123f89abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian inner (dot) product (serial version).  <br /></td></tr>
<tr class="memitem:ga70b8818370b2d60bc89ded76dff99280" id="r_ga70b8818370b2d60bc89ded76dff99280"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga70b8818370b2d60bc89ded76dff99280 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga70b8818370b2d60bc89ded76dff99280">cm2::vecvec::Herm_dot3</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga70b8818370b2d60bc89ded76dff99280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian inner (dot) product (serial version).  <br /></td></tr>
<tr class="memitem:gafe39635e5a5608b71148ee86dafa7303" id="r_gafe39635e5a5608b71148ee86dafa7303"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gafe39635e5a5608b71148ee86dafa7303 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe39635e5a5608b71148ee86dafa7303">cm2::vecvec::__Herm_dot_n</a> (IterX x, cm2::full_tag, IterY y, cm2::full_tag, size_t n)</td></tr>
<tr class="memdesc:gafe39635e5a5608b71148ee86dafa7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian inner (dot) product (serial version).  <br /></td></tr>
<tr class="memitem:gab5f271b996cef5f0ac5a666a07286e9e" id="r_gab5f271b996cef5f0ac5a666a07286e9e"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gab5f271b996cef5f0ac5a666a07286e9e template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5f271b996cef5f0ac5a666a07286e9e">cm2::vecvec::Herm_dot_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gab5f271b996cef5f0ac5a666a07286e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian inner (dot) product (serial version).  <br /></td></tr>
<tr class="memitem:gad6713f700091253f38d2aee5f9a77471" id="r_gad6713f700091253f38d2aee5f9a77471"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gad6713f700091253f38d2aee5f9a77471 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6713f700091253f38d2aee5f9a77471">cm2::vecvec::Herm_dot_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gad6713f700091253f38d2aee5f9a77471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian inner (dot) product (parallel version).  <br /></td></tr>
<tr class="memitem:gab9521c62c97a7f5221acf644a58db6ad" id="r_gab9521c62c97a7f5221acf644a58db6ad"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gab9521c62c97a7f5221acf644a58db6ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9521c62c97a7f5221acf644a58db6ad">cm2::vecvec::Herm_axpy2</a> (T a, const T *CM2_RESTRICT x, T *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:gab9521c62c97a7f5221acf644a58db6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian AXPY.  <br /></td></tr>
<tr class="memitem:ga2c1d98f8207a7573cd43aae62da1086c" id="r_ga2c1d98f8207a7573cd43aae62da1086c"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga2c1d98f8207a7573cd43aae62da1086c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c1d98f8207a7573cd43aae62da1086c">cm2::vecvec::Herm_axpy3</a> (T a, const T *CM2_RESTRICT x, T *CM2_RESTRICT y)</td></tr>
<tr class="memdesc:ga2c1d98f8207a7573cd43aae62da1086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian AXPY.  <br /></td></tr>
<tr class="memitem:ga3705173c7888d4c2d21a7de35156e9e7" id="r_ga3705173c7888d4c2d21a7de35156e9e7"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ga3705173c7888d4c2d21a7de35156e9e7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3705173c7888d4c2d21a7de35156e9e7">cm2::vecvec::Herm_axpy_n</a> (T a, const T *CM2_RESTRICT x, T *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:ga3705173c7888d4c2d21a7de35156e9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian AXPY.  <br /></td></tr>
<tr class="memitem:ga0390362e71fb182df8826c784f04becf" id="r_ga0390362e71fb182df8826c784f04becf"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga0390362e71fb182df8826c784f04becf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0390362e71fb182df8826c784f04becf">cm2::vecvec::Herm_axpy_n</a> (T a, IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga0390362e71fb182df8826c784f04becf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian AXPY (serial version).  <br /></td></tr>
<tr class="memitem:gaaefb774ff568c0d13e3ab786f7aa43e2" id="r_gaaefb774ff568c0d13e3ab786f7aa43e2"><td class="memTemplParams" colspan="2">template&lt;class T, class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaaefb774ff568c0d13e3ab786f7aa43e2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaefb774ff568c0d13e3ab786f7aa43e2">cm2::vecvec::Herm_axpy_n_par</a> (T a, IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gaaefb774ff568c0d13e3ab786f7aa43e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian AXPY (parallel version).  <br /></td></tr>
<tr class="memitem:gaebfb0d9c2f304d261aa0f123a54b362b" id="r_gaebfb0d9c2f304d261aa0f123a54b362b"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:gaebfb0d9c2f304d261aa0f123a54b362b template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebfb0d9c2f304d261aa0f123a54b362b">cm2::vecvec::diff_dot2</a> (IterX x, IterY y, IterZ z)</td></tr>
<tr class="memdesc:gaebfb0d9c2f304d261aa0f123a54b362b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between the difference between two vectors and a third vector (serial version).  <br /></td></tr>
<tr class="memitem:ga2bb508b9b9b1e99189043325c4c9665a" id="r_ga2bb508b9b9b1e99189043325c4c9665a"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga2bb508b9b9b1e99189043325c4c9665a template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2bb508b9b9b1e99189043325c4c9665a">cm2::vecvec::diff_dot3</a> (IterX x, IterY y, IterZ z)</td></tr>
<tr class="memdesc:ga2bb508b9b9b1e99189043325c4c9665a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between a vector and the difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga8c0c59a34dc8574988dbfc35831d134b" id="r_ga8c0c59a34dc8574988dbfc35831d134b"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga8c0c59a34dc8574988dbfc35831d134b template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c0c59a34dc8574988dbfc35831d134b">cm2::vecvec::diff_dot_n</a> (IterX x, IterY y, IterZ z, size_t n)</td></tr>
<tr class="memdesc:ga8c0c59a34dc8574988dbfc35831d134b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between a vector and the difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga2e6288e6138eff45168696569e2cd7fa" id="r_ga2e6288e6138eff45168696569e2cd7fa"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY, class IterZ&gt; </td></tr>
<tr class="memitem:ga2e6288e6138eff45168696569e2cd7fa template"><td class="memItemLeft" align="right" valign="top">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e6288e6138eff45168696569e2cd7fa">cm2::vecvec::diff_dot_n_par</a> (IterX x, IterY y, IterZ z, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:ga2e6288e6138eff45168696569e2cd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between a vector and the difference between two vectors (parallel version).  <br /></td></tr>
<tr class="memitem:ga48d0e039318fbf366060a0e22ce0faf8" id="r_ga48d0e039318fbf366060a0e22ce0faf8"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga48d0e039318fbf366060a0e22ce0faf8 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48d0e039318fbf366060a0e22ce0faf8">cm2::vecvec::diff_sqr_two_norm2</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga48d0e039318fbf366060a0e22ce0faf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of two-norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:gac2c57116db0ca1429988fd0574ae142c" id="r_gac2c57116db0ca1429988fd0574ae142c"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gac2c57116db0ca1429988fd0574ae142c template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2c57116db0ca1429988fd0574ae142c">cm2::vecvec::diff_sqr_two_norm3</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:gac2c57116db0ca1429988fd0574ae142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of two-norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga670a257d1a466cdd36ffe2bbed43706e" id="r_ga670a257d1a466cdd36ffe2bbed43706e"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga670a257d1a466cdd36ffe2bbed43706e template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga670a257d1a466cdd36ffe2bbed43706e">cm2::vecvec::diff_sqr_two_norm_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga670a257d1a466cdd36ffe2bbed43706e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of two-norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:gaf51cf641c87bced902c71da17b66e1a9" id="r_gaf51cf641c87bced902c71da17b66e1a9"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gaf51cf641c87bced902c71da17b66e1a9 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf51cf641c87bced902c71da17b66e1a9">cm2::vecvec::diff_sqr_two_norm_n_par</a> (IterX x, IterY y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gaf51cf641c87bced902c71da17b66e1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of two-norm of difference between two vectors (parallel version).  <br /></td></tr>
<tr class="memitem:ga58ae7595ee2d19fe665cb25d3fd11fea" id="r_ga58ae7595ee2d19fe665cb25d3fd11fea"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga58ae7595ee2d19fe665cb25d3fd11fea template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58ae7595ee2d19fe665cb25d3fd11fea">cm2::vecvec::diff_two_norm2</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga58ae7595ee2d19fe665cb25d3fd11fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two-norm of the difference between arrays [<code class="param">x</code>, <code class="param">x</code> + 2[ and [<code class="param">y</code>, <code class="param">y</code> + 2[.  <br /></td></tr>
<tr class="memitem:ga00fc6b135583370573799dda5ba59aba" id="r_ga00fc6b135583370573799dda5ba59aba"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga00fc6b135583370573799dda5ba59aba template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00fc6b135583370573799dda5ba59aba">cm2::vecvec::diff_two_norm3</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga00fc6b135583370573799dda5ba59aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two-norm of the difference between arrays [<code class="param">x</code>, <code class="param">x</code> + 3[ and [<code class="param">y</code>, <code class="param">y</code> + 3[.  <br /></td></tr>
<tr class="memitem:ga0ba53126dcea5a32ba2e2af6e6a0c0b3" id="r_ga0ba53126dcea5a32ba2e2af6e6a0c0b3"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga0ba53126dcea5a32ba2e2af6e6a0c0b3 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ba53126dcea5a32ba2e2af6e6a0c0b3">cm2::vecvec::diff_two_norm_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:ga0ba53126dcea5a32ba2e2af6e6a0c0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-norm of the difference between two vectors.  <br /></td></tr>
<tr class="memitem:gacf7d1777a1d120e62d5310939da70dfd" id="r_gacf7d1777a1d120e62d5310939da70dfd"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gacf7d1777a1d120e62d5310939da70dfd template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf7d1777a1d120e62d5310939da70dfd">cm2::vecvec::diff_max_norm2</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:gacf7d1777a1d120e62d5310939da70dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga6823d6897d534f4341836a96a15bfcb3" id="r_ga6823d6897d534f4341836a96a15bfcb3"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga6823d6897d534f4341836a96a15bfcb3 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6823d6897d534f4341836a96a15bfcb3">cm2::vecvec::diff_max_norm3</a> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga6823d6897d534f4341836a96a15bfcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:gacff63e61253e93476a3bd71b600812c5" id="r_gacff63e61253e93476a3bd71b600812c5"><td class="memTemplParams" colspan="2">template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gacff63e61253e93476a3bd71b600812c5 template"><td class="memItemLeft" align="right" valign="top">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacff63e61253e93476a3bd71b600812c5">cm2::vecvec::diff_max_norm_n</a> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gacff63e61253e93476a3bd71b600812c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max norm of difference between two vectors (serial version).  <br /></td></tr>
<tr class="memitem:ga8d8f4de91b92c83d6e9cece2f9a94e2e" id="r_ga8d8f4de91b92c83d6e9cece2f9a94e2e"><td class="memTemplParams" colspan="2"><a id="ga8d8f4de91b92c83d6e9cece2f9a94e2e" name="ga8d8f4de91b92c83d6e9cece2f9a94e2e"></a>
template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga8d8f4de91b92c83d6e9cece2f9a94e2e template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>cm2::vecvec::equal2</b> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga8d8f4de91b92c83d6e9cece2f9a94e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the equality between arrays [<code class="param">x</code>, <code class="param">x</code> + 2[ and [<code class="param">y</code>, <code class="param">y</code> + 2[. <br /></td></tr>
<tr class="memitem:ga0977f42a24f9fa228f724a1bbd1c4c4d" id="r_ga0977f42a24f9fa228f724a1bbd1c4c4d"><td class="memTemplParams" colspan="2"><a id="ga0977f42a24f9fa228f724a1bbd1c4c4d" name="ga0977f42a24f9fa228f724a1bbd1c4c4d"></a>
template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:ga0977f42a24f9fa228f724a1bbd1c4c4d template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>cm2::vecvec::equal3</b> (IterX x, IterY y)</td></tr>
<tr class="memdesc:ga0977f42a24f9fa228f724a1bbd1c4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the equality between arrays [<code class="param">x</code>, <code class="param">x</code> + 3[ and [<code class="param">y</code>, <code class="param">y</code> + 3[. <br /></td></tr>
<tr class="memitem:gad14d78f9dfc06ab20e74d7b8e94f5915" id="r_gad14d78f9dfc06ab20e74d7b8e94f5915"><td class="memTemplParams" colspan="2"><a id="gad14d78f9dfc06ab20e74d7b8e94f5915" name="gad14d78f9dfc06ab20e74d7b8e94f5915"></a>
template&lt;class IterX, class IterY&gt; </td></tr>
<tr class="memitem:gad14d78f9dfc06ab20e74d7b8e94f5915 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>cm2::vecvec::equal_n</b> (IterX x, IterY y, size_t n)</td></tr>
<tr class="memdesc:gad14d78f9dfc06ab20e74d7b8e94f5915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the equality between arrays [<code class="param">x</code>, <code class="param">x</code> + <code class="param">n</code>[ and [<code class="param">y</code>, <code class="param">y</code> + <code class="param">n</code>[. <br /></td></tr>
<tr class="memitem:gaada6081e00a3cd54f8e5536bfb1c4161" id="r_gaada6081e00a3cd54f8e5536bfb1c4161"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gaada6081e00a3cd54f8e5536bfb1c4161 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaada6081e00a3cd54f8e5536bfb1c4161">cm2::vecvec::mult_sum_n</a> (const T *CM2_RESTRICT x, T *CM2_RESTRICT y, size_t n)</td></tr>
<tr class="memdesc:gaada6081e00a3cd54f8e5536bfb1c4161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mult Sum (serial version).  <br /></td></tr>
<tr class="memitem:gae4af298317878f0e988cf7b717c7e677" id="r_gae4af298317878f0e988cf7b717c7e677"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:gae4af298317878f0e988cf7b717c7e677 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4af298317878f0e988cf7b717c7e677">cm2::vecvec::mult_sum_n_par</a> (const T *CM2_RESTRICT x, T *CM2_RESTRICT y, size_t n, int DUM_OMP(nthreads))</td></tr>
<tr class="memdesc:gae4af298317878f0e988cf7b717c7e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mult Sum (parallel version).  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga9e6ef592ace7645c9101a47593c178b2" name="ga9e6ef592ace7645c9101a47593c178b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e6ef592ace7645c9101a47593c178b2">&#9670;&#160;</a></span>copy2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy (serial version with pointers). </p>
<pre class="fragment">   y[i] = x[i], for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00058">58</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga07c074098e64fefeaa144f6e7874a8e0" name="ga07c074098e64fefeaa144f6e7874a8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c074098e64fefeaa144f6e7874a8e0">&#9670;&#160;</a></span>copy3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy (serial version with pointers). </p>
<pre class="fragment">   y[i] = x[i], for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00078">78</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga64227412d61228fd3c1bfed1ca2e04e8" name="ga64227412d61228fd3c1bfed1ca2e04e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64227412d61228fd3c1bfed1ca2e04e8">&#9670;&#160;</a></span>copy_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy (serial version with pointers). </p>
<pre class="fragment">   y[i] = x[i], for i = 0 ... n-1 
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00098">98</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaea3661b996c334d9e3b20e8084a5ab62" name="gaea3661b996c334d9e3b20e8084a5ab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea3661b996c334d9e3b20e8084a5ab62">&#9670;&#160;</a></span>copy_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterY cm2::vecvec::copy_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] = x[i], for i = 0 ... n-1 
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00130">130</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga34dc8a2626fb6ef60286216f88f8d1a6" name="ga34dc8a2626fb6ef60286216f88f8d1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34dc8a2626fb6ef60286216f88f8d1a6">&#9670;&#160;</a></span>swap2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::swap2 </td>
          <td>(</td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise swap (serial version with pointers). </p>
<pre class="fragment">   swap(x[i], y[i]), for i = 0, 1. 
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00149">149</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga2615b70a9805e5ed9f6583e334964166" name="ga2615b70a9805e5ed9f6583e334964166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2615b70a9805e5ed9f6583e334964166">&#9670;&#160;</a></span>swap3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::swap3 </td>
          <td>(</td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise swap (serial version with pointers). </p>
<pre class="fragment">   swap(x[i], y[i]), for i = 0, 1, 2. 
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00167">167</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga0c0e5386841cb75cac9226672a41ddca" name="ga0c0e5386841cb75cac9226672a41ddca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c0e5386841cb75cac9226672a41ddca">&#9670;&#160;</a></span>swap_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::swap_n </td>
          <td>(</td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise swap (serial version with pointers). </p>
<pre class="fragment">   swap(x[i], y[i]), for i = 0 ... n-1 
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00185">185</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga164106c2ded04788bdda090457c3e3bf" name="ga164106c2ded04788bdda090457c3e3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164106c2ded04788bdda090457c3e3bf">&#9670;&#160;</a></span>swap_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::swap_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise swap. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   swap(x[i], y[i]), for i = 0 ... n-1 
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00234">234</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga5d74314d9a64366505691c34cc4676e6" name="ga5d74314d9a64366505691c34cc4676e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d74314d9a64366505691c34cc4676e6">&#9670;&#160;</a></span>copy_scale2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy_scale2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy with scaling (serial version with pointers). </p>
<pre class="fragment">   y[i] = a * x[i], for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00253">253</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaac21b1bc0b90b3742846bea620892505" name="gaac21b1bc0b90b3742846bea620892505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac21b1bc0b90b3742846bea620892505">&#9670;&#160;</a></span>copy_scale3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy_scale3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy with scaling (serial version with pointers). </p>
<pre class="fragment">   y[i] = a * x[i], for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00273">273</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga388a1e6886c383e616471c26150c8ac7" name="ga388a1e6886c383e616471c26150c8ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga388a1e6886c383e616471c26150c8ac7">&#9670;&#160;</a></span>copy_scale_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TY * cm2::vecvec::copy_scale_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise copy with scaling (serial version with pointers). </p>
<pre class="fragment">   y[i] = a * x[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00293">293</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga65a82eea4d0533f2314ea904ea729855" name="ga65a82eea4d0533f2314ea904ea729855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65a82eea4d0533f2314ea904ea729855">&#9670;&#160;</a></span>copy_scale_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterY cm2::vecvec::copy_scale_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] = a * x[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00349">349</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gad1f3fa5d668f91f4c0fc6ed8e822a9bf" name="gad1f3fa5d668f91f4c0fc6ed8e822a9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f3fa5d668f91f4c0fc6ed8e822a9bf">&#9670;&#160;</a></span>copy_scale_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterY cm2::vecvec::copy_scale_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (parallel version with iterators). </p>
<pre class="fragment">   y[i] = a * x[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00385">385</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gad3c357b5290a959dcb242631d2175c3d" name="gad3c357b5290a959dcb242631d2175c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c357b5290a959dcb242631d2175c3d">&#9670;&#160;</a></span>copy_add2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] + y[i], for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00411">411</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaa44a4fc8a3e8ff7cc85db98a74e35f80" name="gaa44a4fc8a3e8ff7cc85db98a74e35f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa44a4fc8a3e8ff7cc85db98a74e35f80">&#9670;&#160;</a></span>copy_add3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] + y[i], for i = 0, 1, 2. 
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00431">431</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaf2113aa3c7138ccff4379882077b16db" name="gaf2113aa3c7138ccff4379882077b16db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2113aa3c7138ccff4379882077b16db">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] + y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00451">451</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaa7b2e6084e7ebd5b4e47f00938098139" name="gaa7b2e6084e7ebd5b4e47f00938098139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7b2e6084e7ebd5b4e47f00938098139">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = x[i] + y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00508">508</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gae1f8421e03f22db1ba06abbde9b8137f" name="gae1f8421e03f22db1ba06abbde9b8137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f8421e03f22db1ba06abbde9b8137f">&#9670;&#160;</a></span>copy_add_n_par() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_add_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum. </p>
<p>Parallel version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = x[i] + y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">y</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00546">546</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga1c881d2845b9c92b665cdd71cb8ef417" name="ga1c881d2845b9c92b665cdd71cb8ef417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c881d2845b9c92b665cdd71cb8ef417">&#9670;&#160;</a></span>copy_add2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (serial version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] + y[i]), for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00575">575</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gafbd57c31513203dd599889b1ed70dd7e" name="gafbd57c31513203dd599889b1ed70dd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd57c31513203dd599889b1ed70dd7e">&#9670;&#160;</a></span>copy_add3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (serial version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] + y[i]), for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00595">595</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga224428e769d4ac719f784205b33cd97e" name="ga224428e769d4ac719f784205b33cd97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224428e769d4ac719f784205b33cd97e">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] = a * (x[i] + y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00616">616</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gadea1068e723b0588bba7518a95a189bc" name="gadea1068e723b0588bba7518a95a189bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea1068e723b0588bba7518a95a189bc">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = a * (x[i] + y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00673">673</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga8af27f7c9a26f1d1b996f5a679464ab2" name="ga8af27f7c9a26f1d1b996f5a679464ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af27f7c9a26f1d1b996f5a679464ab2">&#9670;&#160;</a></span>copy_add_n_par() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_add_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (parallel version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] + y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00711">711</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaabcd915bb07fcb024b0fd74879ef8257" name="gaabcd915bb07fcb024b0fd74879ef8257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabcd915bb07fcb024b0fd74879ef8257">&#9670;&#160;</a></span>copy_add2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ, class TW&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TW * cm2::vecvec::copy_add2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TW *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (serial version with pointers). </p>
<pre class="fragment">   w[i] = a * (x[i] + y[i] + z[i]), for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">w</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00739">739</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga5345e78c03e25093a34dd4cfdffcfe91" name="ga5345e78c03e25093a34dd4cfdffcfe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5345e78c03e25093a34dd4cfdffcfe91">&#9670;&#160;</a></span>copy_add3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ, class TW&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TW * cm2::vecvec::copy_add3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TW *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (serial version with pointers). </p>
<pre class="fragment">   w[i] = a * (x[i] + y[i] + z[i]), for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">w</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00759">759</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga6bd6ba6c2c6304eacff6b3aa79337f81" name="ga6bd6ba6c2c6304eacff6b3aa79337f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bd6ba6c2c6304eacff6b3aa79337f81">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ, class TW&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TW * cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TW *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling (serial version with pointers). </p>
<pre class="fragment">   w[i] = a * (x[i] + y[i] + z[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">w</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00779">779</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga8c8db799afd6f8fad06e4b6451abe3c4" name="ga8c8db799afd6f8fad06e4b6451abe3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8db799afd6f8fad06e4b6451abe3c4">&#9670;&#160;</a></span>copy_add_n() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ, class IterW&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterW cm2::vecvec::copy_add_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterW</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   w[i] = a * (x[i] + y[i] + z[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00837">837</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga6a524d001b704fd0bfff359908fac5e2" name="ga6a524d001b704fd0bfff359908fac5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a524d001b704fd0bfff359908fac5e2">&#9670;&#160;</a></span>copy_add_n_par() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ, class IterW&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterW cm2::vecvec::copy_add_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterW</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise sum with scaling. </p>
<p>Parallel version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   w[i] = a * (x[i] + y[i] + z[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00877">877</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaea80fb538a89accb1d54d5fd9a8c8e2e" name="gaea80fb538a89accb1d54d5fd9a8c8e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea80fb538a89accb1d54d5fd9a8c8e2e">&#9670;&#160;</a></span>copy_diff2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] - y[i], for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00908">908</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga0420b09374c2d24b75ae6437d705a53a" name="ga0420b09374c2d24b75ae6437d705a53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0420b09374c2d24b75ae6437d705a53a">&#9670;&#160;</a></span>copy_diff3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] - y[i], for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00928">928</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga259e1579ed7b635c7415c46e8959b2cc" name="ga259e1579ed7b635c7415c46e8959b2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga259e1579ed7b635c7415c46e8959b2cc">&#9670;&#160;</a></span>copy_diff_n() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference (serial version with pointers). </p>
<pre class="fragment">   z[i] = x[i] - y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l00948">948</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga51d39d03cb0378ae2c48167113665022" name="ga51d39d03cb0378ae2c48167113665022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d39d03cb0378ae2c48167113665022">&#9670;&#160;</a></span>copy_diff_n() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_diff_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = x[i] - y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01005">1005</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gafbafef6c859fc87b332188a8c9141e92" name="gafbafef6c859fc87b332188a8c9141e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbafef6c859fc87b332188a8c9141e92">&#9670;&#160;</a></span>copy_diff_n_par() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_diff_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference (parallel version with pointers). </p>
<pre class="fragment">   z[i] = x[i] - y[i], for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01043">1043</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga9381312fb5d1505d392be7b0a8f64600" name="ga9381312fb5d1505d392be7b0a8f64600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9381312fb5d1505d392be7b0a8f64600">&#9670;&#160;</a></span>copy_diff2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference with scaling (serial version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] - y[i]), for i = 0, 1.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 2. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01072">1072</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga3497d12c5e845061ba059ef2feb81611" name="ga3497d12c5e845061ba059ef2feb81611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3497d12c5e845061ba059ef2feb81611">&#9670;&#160;</a></span>copy_diff3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference with scaling (serial version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] - y[i]), for i = 0, 1, 2.
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + 3. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01092">1092</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga4f2beab778dcce0f51b0637ee4a6880b" name="ga4f2beab778dcce0f51b0637ee4a6880b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2beab778dcce0f51b0637ee4a6880b">&#9670;&#160;</a></span>copy_diff_n() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY, class TZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TZ * cm2::vecvec::copy_diff_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TZ *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference with scaling (serial version with pointers). </p>
<pre class="fragment">   z[i] = a * (x[i] - y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01112">1112</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga7c3832db9f3b654ffa5ccaee896a27d4" name="ga7c3832db9f3b654ffa5ccaee896a27d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3832db9f3b654ffa5ccaee896a27d4">&#9670;&#160;</a></span>copy_diff_n() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_diff_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference with scaling. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = a * (x[i] - y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01169">1169</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga76e7d359e29150f1ba523514fec3a666" name="ga76e7d359e29150f1ba523514fec3a666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e7d359e29150f1ba523514fec3a666">&#9670;&#160;</a></span>copy_diff_n_par() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterZ cm2::vecvec::copy_diff_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise difference with scaling. </p>
<p>Parallel version with pointers (only dense iterators allowed).</p>
<pre class="fragment">   z[i] = a * (x[i] - y[i]), for i = 0...n-1  
</pre><dl class="section return"><dt>Returns</dt><dd>The iterator <code class="param">z</code> + <code class="param">n</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01207">1207</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga521b31e2953ae75ef76c1068874ad3ef" name="ga521b31e2953ae75ef76c1068874ad3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga521b31e2953ae75ef76c1068874ad3ef">&#9670;&#160;</a></span>add2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::add2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise add (serial version with pointers). </p>
<pre class="fragment">   y[i] += x[i], for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01235">1235</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga90e04db4a98bcf86410ea01cfd156b59" name="ga90e04db4a98bcf86410ea01cfd156b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90e04db4a98bcf86410ea01cfd156b59">&#9670;&#160;</a></span>add3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::add3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise add (serial version with pointers). </p>
<pre class="fragment">   y[i] += x[i], for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01253">1253</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga249ef68503ce3ac8f897da9d9c8c26be" name="ga249ef68503ce3ac8f897da9d9c8c26be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249ef68503ce3ac8f897da9d9c8c26be">&#9670;&#160;</a></span>add_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::add_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise add (serial version with pointers). </p>
<pre class="fragment">   y[i] += x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01271">1271</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gac997c2b5d217724672f0d6d2063e044f" name="gac997c2b5d217724672f0d6d2063e044f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac997c2b5d217724672f0d6d2063e044f">&#9670;&#160;</a></span>add_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::add_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise add. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] += x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01322">1322</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga60a44636b534ea2f789538528a7a85bd" name="ga60a44636b534ea2f789538528a7a85bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60a44636b534ea2f789538528a7a85bd">&#9670;&#160;</a></span>add_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::add_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise add. </p>
<p>Parallel version with pointers (only dense iterators allowed).</p>
<pre class="fragment">   y[i] += x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01355">1355</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga9473e8a9c13b3d50022a3b89cb82b691" name="ga9473e8a9c13b3d50022a3b89cb82b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9473e8a9c13b3d50022a3b89cb82b691">&#9670;&#160;</a></span>subtract2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::subtract2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise subtract (serial version with pointers). </p>
<pre class="fragment">   y[i] -= x[i], for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01380">1380</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga7f4822b5f6a30a4faf19c0dced5dc868" name="ga7f4822b5f6a30a4faf19c0dced5dc868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f4822b5f6a30a4faf19c0dced5dc868">&#9670;&#160;</a></span>subtract3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::subtract3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise subtract (serial version with pointers). </p>
<pre class="fragment">   y[i] -= x[i], for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01398">1398</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga9f1992265d68192b12e44b0164e0d0da" name="ga9f1992265d68192b12e44b0164e0d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f1992265d68192b12e44b0164e0d0da">&#9670;&#160;</a></span>subtract_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::subtract_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise subtract (serial version with pointers). </p>
<pre class="fragment">   y[i] -= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01416">1416</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga8d8ecdb7f072b43c856d5dc8adfa1017" name="ga8d8ecdb7f072b43c856d5dc8adfa1017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8ecdb7f072b43c856d5dc8adfa1017">&#9670;&#160;</a></span>subtract_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::subtract_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise subtract. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] -= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01467">1467</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga4c7f8ce85cbe553bc3360e5e74b47c27" name="ga4c7f8ce85cbe553bc3360e5e74b47c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c7f8ce85cbe553bc3360e5e74b47c27">&#9670;&#160;</a></span>subtract_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::subtract_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise subtract. </p>
<p>Parallel version with pointers (only dense iterators allowed).</p>
<pre class="fragment">   y[i] -= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01500">1500</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gadf1b81c36fe815c71e2b53780452d4df" name="gadf1b81c36fe815c71e2b53780452d4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1b81c36fe815c71e2b53780452d4df">&#9670;&#160;</a></span>mult2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::mult2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise mult (serial version with pointers). </p>
<pre class="fragment">   y[i] *= x[i], for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01525">1525</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga2cab962350c3d5f9e2c81ef29135ddb6" name="ga2cab962350c3d5f9e2c81ef29135ddb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cab962350c3d5f9e2c81ef29135ddb6">&#9670;&#160;</a></span>mult3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::mult3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise mult (serial version with pointers). </p>
<pre class="fragment">   y[i] *= x[i], for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01543">1543</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gadb732691fe89ad630be64d2fbac01dd0" name="gadb732691fe89ad630be64d2fbac01dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb732691fe89ad630be64d2fbac01dd0">&#9670;&#160;</a></span>mult_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::mult_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise mult (serial version with pointers). </p>
<pre class="fragment">   y[i] *= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01561">1561</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga19dc8ded1fc3a2b506cfe0cd0d2024f7" name="ga19dc8ded1fc3a2b506cfe0cd0d2024f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19dc8ded1fc3a2b506cfe0cd0d2024f7">&#9670;&#160;</a></span>mult_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::mult_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise mult. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] *= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01612">1612</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga31bfc80412345363190bfff19a623346" name="ga31bfc80412345363190bfff19a623346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31bfc80412345363190bfff19a623346">&#9670;&#160;</a></span>mult_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::mult_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise mult. </p>
<p>Parallel version with pointers (only dense iterators allowed).</p>
<pre class="fragment">   y[i] *= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01645">1645</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga6492a1347950fb57e784c852a0fa86ad" name="ga6492a1347950fb57e784c852a0fa86ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6492a1347950fb57e784c852a0fa86ad">&#9670;&#160;</a></span>div2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::div2 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise div (serial version with pointers). </p>
<pre class="fragment">   y[i] /= x[i], for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01671">1671</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaf65db05e268e1b5b810c5af079ec373e" name="gaf65db05e268e1b5b810c5af079ec373e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf65db05e268e1b5b810c5af079ec373e">&#9670;&#160;</a></span>div3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::div3 </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise div (serial version with pointers). </p>
<pre class="fragment">   y[i] /= x[i], for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01689">1689</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga934a999755e021f7523a77b61134fd32" name="ga934a999755e021f7523a77b61134fd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga934a999755e021f7523a77b61134fd32">&#9670;&#160;</a></span>div_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::div_n </td>
          <td>(</td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise div (serial version with pointers). </p>
<pre class="fragment">   y[i] /= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01707">1707</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga1ccd891a914ba269f30d2d66d7a0c173" name="ga1ccd891a914ba269f30d2d66d7a0c173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ccd891a914ba269f30d2d66d7a0c173">&#9670;&#160;</a></span>div_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::div_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise div. </p>
<p>Serial version with iterators (only dense iterators allowed).</p>
<pre class="fragment">   y[i] /= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01758">1758</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaa9efdc83c79f607d3dee41c55f9d55aa" name="gaa9efdc83c79f607d3dee41c55f9d55aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9efdc83c79f607d3dee41c55f9d55aa">&#9670;&#160;</a></span>div_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::div_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise div. </p>
<p>Parallel version with pointers (only dense iterators allowed).</p>
<pre class="fragment">   y[i] /= x[i], for i = 0.. n-1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01791">1791</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gad23b018f10e937f524be274ab051b7f5" name="gad23b018f10e937f524be274ab051b7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad23b018f10e937f524be274ab051b7f5">&#9670;&#160;</a></span>axpy2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axpy2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXPY (serial version with pointers). </p>
<pre class="fragment">   y[i] += a * x[i], for i = 0, 1 .
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01817">1817</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gab79ffb425c4da6757752091d670c467a" name="gab79ffb425c4da6757752091d670c467a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79ffb425c4da6757752091d670c467a">&#9670;&#160;</a></span>axpy3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axpy3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXPY (serial version with pointers). </p>
<pre class="fragment">   y[i] += a * x[i], for i = 0, 1, 2.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01835">1835</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga1f8efd3305242cc05e3044ee54ba1bd9" name="ga1f8efd3305242cc05e3044ee54ba1bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8efd3305242cc05e3044ee54ba1bd9">&#9670;&#160;</a></span>axpy_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class TX, class TY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axpy_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TX *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TY *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXPY (serial version with pointers). </p>
<pre class="fragment">   y[i] += a * x[i], for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01853">1853</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga9b2a27c13914a8ce9f89d4f0d45b1f05" name="ga9b2a27c13914a8ce9f89d4f0d45b1f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b2a27c13914a8ce9f89d4f0d45b1f05">&#9670;&#160;</a></span>axpy_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axpy_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXPY (serial version). </p>
<pre class="fragment">   y[i] += a * x[i], for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd>
<dd>
IterY must be dense. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01914">1914</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaa1182729b3933e546198fbf67da43849" name="gaa1182729b3933e546198fbf67da43849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1182729b3933e546198fbf67da43849">&#9670;&#160;</a></span>axpy_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axpy_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXPY (parallel version). </p>
<pre class="fragment">   y[i] += a * x[i], for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd>
<dd>
IterY must be dense. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01960">1960</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gac4395bdd23a0d2769df2c53b95ddf1e0" name="gac4395bdd23a0d2769df2c53b95ddf1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4395bdd23a0d2769df2c53b95ddf1e0">&#9670;&#160;</a></span>axypz2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axypz2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXYPZ. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] += a * (x[i] * y[i]), for i = 0, 1.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l01986">1986</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gadf9662a212ee92c5af852a728f8a84f6" name="gadf9662a212ee92c5af852a728f8a84f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9662a212ee92c5af852a728f8a84f6">&#9670;&#160;</a></span>axypz3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axypz3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXYPZ. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] += a * (x[i] * y[i]), for i = 0, 1, 2.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02005">2005</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gac51eed9dea9c17eb1df71c2488657a55" name="gac51eed9dea9c17eb1df71c2488657a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51eed9dea9c17eb1df71c2488657a55">&#9670;&#160;</a></span>axypz_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axypz_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXYPZ. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] += a * (x[i] * y[i]), for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02024">2024</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga50944f876805890658b3b5cd5cdbd8ce" name="ga50944f876805890658b3b5cd5cdbd8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50944f876805890658b3b5cd5cdbd8ce">&#9670;&#160;</a></span>axypz_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axypz_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXYPZ. </p>
<p>Serial version with iterators (may alias).</p>
<pre class="fragment">   z[i] += a * (x[i] * y[i]), for i = 0...n-1  
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02065">2065</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga71206cf9ed67809672a228552fc7883a" name="ga71206cf9ed67809672a228552fc7883a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71206cf9ed67809672a228552fc7883a">&#9670;&#160;</a></span>axypz_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::axypz_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise AXYPZ. </p>
<p>Parallel version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] += a * (x[i] * y[i]), for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02084">2084</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gab97910f3160fabdd6a7714c59eb76d86" name="gab97910f3160fabdd6a7714c59eb76d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97910f3160fabdd6a7714c59eb76d86">&#9670;&#160;</a></span>interpol2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::interpol2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise interpolation. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] = x[i] + a * (y[i]-x[i]), for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02115">2115</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaff32fbdd39ac34ec03acf35f292f169e" name="gaff32fbdd39ac34ec03acf35f292f169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff32fbdd39ac34ec03acf35f292f169e">&#9670;&#160;</a></span>interpol3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::interpol3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise interpolation. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] = x[i] + a * (y[i]-x[i]), for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02134">2134</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga51cf028980f59d6294c1f7301ffdd6ba" name="ga51cf028980f59d6294c1f7301ffdd6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51cf028980f59d6294c1f7301ffdd6ba">&#9670;&#160;</a></span>interpol_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::interpol_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise interpolation. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] = x[i] + a * (y[i]-x[i]), for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02153">2153</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaddccb4e76a033a078c71afce440ae61b" name="gaddccb4e76a033a078c71afce440ae61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddccb4e76a033a078c71afce440ae61b">&#9670;&#160;</a></span>interpol_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::interpol_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise interpolation. </p>
<p>Serial version with iterators (may alias).</p>
<pre class="fragment">   z[i] = x[i] + a * (y[i]-x[i]), for i = 0...n-1  
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02194">2194</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga427db881b6c8ac76667097e2408665e2" name="ga427db881b6c8ac76667097e2408665e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427db881b6c8ac76667097e2408665e2">&#9670;&#160;</a></span>interpol_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::interpol_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element-wise interpolation. </p>
<p>Parallel version with pointers (no aliasing allowed).</p>
<pre class="fragment">   z[i] = x[i] + a * (y[i]-x[i]), for i = 0...n-1  
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02213">2213</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gae9ae0a973ddbfda73fa7deeadca4791f" name="gae9ae0a973ddbfda73fa7deeadca4791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ae0a973ddbfda73fa7deeadca4791f">&#9670;&#160;</a></span>dot2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::dot2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product (serial version). </p>
<pre class="fragment">   s = sum(x[i] * y[i]), for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02243">2243</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga30b1bf24378e2be63709cd98c5cd7fc9" name="ga30b1bf24378e2be63709cd98c5cd7fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30b1bf24378e2be63709cd98c5cd7fc9">&#9670;&#160;</a></span>dot3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::dot3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product (serial version). </p>
<pre class="fragment">   s = sum(x[i] * y[i]), for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02260">2260</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaec08ae8bb8acd77f531a5d8aa89906a8" name="gaec08ae8bb8acd77f531a5d8aa89906a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec08ae8bb8acd77f531a5d8aa89906a8">&#9670;&#160;</a></span>dot_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::dot_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product (serial version). </p>
<pre class="fragment">   s = sum (x[i] * y[i]), for i = 0,..n-1  
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02341">2341</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga15066c5806e60da0df9efedd7b3951af" name="ga15066c5806e60da0df9efedd7b3951af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15066c5806e60da0df9efedd7b3951af">&#9670;&#160;</a></span>dot_n_par() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::dot_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product (parallel version). </p>
<pre class="fragment">   s = sum (x[i] * y[i]), for i = 0,..n-1  
</pre><dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02411">2411</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga3f8a2950bc4cc6cf61623bbc5a8762bc" name="ga3f8a2950bc4cc6cf61623bbc5a8762bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8a2950bc4cc6cf61623bbc5a8762bc">&#9670;&#160;</a></span>dot2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::dot2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between three vectors (serial version). </p>
<pre class="fragment">   s = sum (x[i] * y[i] * z[i]), for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02437">2437</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gafe1a41396521f76e92e6e68ac5051ebc" name="gafe1a41396521f76e92e6e68ac5051ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1a41396521f76e92e6e68ac5051ebc">&#9670;&#160;</a></span>dot3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::dot3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between three vectors (serial version). </p>
<pre class="fragment">   s = sum (x[i] * y[i] * z[i]), for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02455">2455</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga5c92dc26794f85b47b9322a1b6db051c" name="ga5c92dc26794f85b47b9322a1b6db051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c92dc26794f85b47b9322a1b6db051c">&#9670;&#160;</a></span>dot_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::dot_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between three vectors (serial version). </p>
<pre class="fragment">   s = sum (x[i] * y[i] * z[i]), for i = 0,..n-1  
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02471">2471</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga847437ccb7559e3988194dc938f18070" name="ga847437ccb7559e3988194dc938f18070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847437ccb7559e3988194dc938f18070">&#9670;&#160;</a></span>dot_n_par() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::dot_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between three vectors (parallel version). </p>
<pre class="fragment">   s = sum (x[i] * y[i] * z[i]), for i = 0,..n-1  
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02518">2518</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga61c68f7a5413e733682ff9a123f89abc" name="ga61c68f7a5413e733682ff9a123f89abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61c68f7a5413e733682ff9a123f89abc">&#9670;&#160;</a></span>Herm_dot2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::Herm_dot2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian inner (dot) product (serial version). </p>
<pre class="fragment">   s = sum(conj(x[i]) * y[i]), for i = 0, 1.
   x is complex, s is complex.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02550">2550</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga70b8818370b2d60bc89ded76dff99280" name="ga70b8818370b2d60bc89ded76dff99280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70b8818370b2d60bc89ded76dff99280">&#9670;&#160;</a></span>Herm_dot3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::Herm_dot3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian inner (dot) product (serial version). </p>
<pre class="fragment">   s = sum(conj(x[i]) * y[i]), for i = 0, 1, 2. 
   x is complex, s is complex.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02568">2568</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gafe39635e5a5608b71148ee86dafa7303" name="gafe39635e5a5608b71148ee86dafa7303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe39635e5a5608b71148ee86dafa7303">&#9670;&#160;</a></span>__Herm_dot_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::__Herm_dot_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cm2::full_tag</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cm2::full_tag</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian inner (dot) product (serial version). </p>
<pre class="fragment">   s = sum(conj(x[i]) * y[i]), for i = 0,..n-1.
   x is complex, s is complex.
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02584">2584</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gab5f271b996cef5f0ac5a666a07286e9e" name="gab5f271b996cef5f0ac5a666a07286e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f271b996cef5f0ac5a666a07286e9e">&#9670;&#160;</a></span>Herm_dot_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::Herm_dot_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian inner (dot) product (serial version). </p>
<pre class="fragment">   s = sum(conj(x[i]) * y[i]), for i = 0,..n-1.
   x is complex, s is complex.
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02660">2660</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gad6713f700091253f38d2aee5f9a77471" name="gad6713f700091253f38d2aee5f9a77471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6713f700091253f38d2aee5f9a77471">&#9670;&#160;</a></span>Herm_dot_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::Herm_dot_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian inner (dot) product (parallel version). </p>
<pre class="fragment">   s = sum(conj(x[i]) * y[i]), for i = 0,..n-1.
   x is complex, s is complex.
</pre><dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02731">2731</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gab9521c62c97a7f5221acf644a58db6ad" name="gab9521c62c97a7f5221acf644a58db6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9521c62c97a7f5221acf644a58db6ad">&#9670;&#160;</a></span>Herm_axpy2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::Herm_axpy2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian AXPY. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   y[i] += a * conj(x[i]), for i = 0, 1.
   x and y are complexes.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02759">2759</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga2c1d98f8207a7573cd43aae62da1086c" name="ga2c1d98f8207a7573cd43aae62da1086c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c1d98f8207a7573cd43aae62da1086c">&#9670;&#160;</a></span>Herm_axpy3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::Herm_axpy3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian AXPY. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   y[i] += a * conj(x[i]), for i = 0, 1, 2.
   x and y are complexes.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02779">2779</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga3705173c7888d4c2d21a7de35156e9e7" name="ga3705173c7888d4c2d21a7de35156e9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3705173c7888d4c2d21a7de35156e9e7">&#9670;&#160;</a></span>Herm_axpy_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::Herm_axpy_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian AXPY. </p>
<p>Serial version with pointers (no aliasing allowed).</p>
<pre class="fragment">   y[i] += a * conj(x[i]), for i = 0...n-1.
   x and y are complexes.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02799">2799</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga0390362e71fb182df8826c784f04becf" name="ga0390362e71fb182df8826c784f04becf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0390362e71fb182df8826c784f04becf">&#9670;&#160;</a></span>Herm_axpy_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::Herm_axpy_n </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian AXPY (serial version). </p>
<pre class="fragment">   y[i] += a * conj(x[i]), for i = 0...n-1.
   x and y are complexes.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd>
<dd>
IterY must be dense. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02870">2870</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaaefb774ff568c0d13e3ab786f7aa43e2" name="gaaefb774ff568c0d13e3ab786f7aa43e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaefb774ff568c0d13e3ab786f7aa43e2">&#9670;&#160;</a></span>Herm_axpy_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cm2::vecvec::Herm_axpy_n_par </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hermitian AXPY (parallel version). </p>
<pre class="fragment">   y[i] += a * conj(x[i]), for i = 0...n-1.
   x and y are complexes.
</pre><dl class="section warning"><dt>Warning</dt><dd>No aliasing/overlapping allowed. </dd>
<dd>
IterY must be dense. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02916">2916</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaebfb0d9c2f304d261aa0f123a54b362b" name="gaebfb0d9c2f304d261aa0f123a54b362b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebfb0d9c2f304d261aa0f123a54b362b">&#9670;&#160;</a></span>diff_dot2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::diff_dot2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between the difference between two vectors and a third vector (serial version). </p>
<pre class="fragment">   d = sum ((x[i]-y[i])*z[i]), for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02944">2944</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga2bb508b9b9b1e99189043325c4c9665a" name="ga2bb508b9b9b1e99189043325c4c9665a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb508b9b9b1e99189043325c4c9665a">&#9670;&#160;</a></span>diff_dot3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::diff_dot3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between a vector and the difference between two vectors (serial version). </p>
<pre class="fragment">   d = sum ((x[i]-y[i])*z[i]), for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02972">2972</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga8c0c59a34dc8574988dbfc35831d134b" name="ga8c0c59a34dc8574988dbfc35831d134b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0c59a34dc8574988dbfc35831d134b">&#9670;&#160;</a></span>diff_dot_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::diff_dot_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between a vector and the difference between two vectors (serial version). </p>
<pre class="fragment">   d = sum ((x[i]-y[i])*z[i]), for i = 0.. n-1. 
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l02999">2999</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga2e6288e6138eff45168696569e2cd7fa" name="ga2e6288e6138eff45168696569e2cd7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6288e6138eff45168696569e2cd7fa">&#9670;&#160;</a></span>diff_dot_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY, class IterZ&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest3_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type, typenamestd::iterator_traits&lt; IterZ &gt;::value_type &gt;::type cm2::vecvec::diff_dot_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterZ</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between a vector and the difference between two vectors (parallel version). </p>
<pre class="fragment">   d = sum ((x[i]-y[i])*z[i]), for i = 0.. n-1. 
</pre><dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03055">3055</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga48d0e039318fbf366060a0e22ce0faf8" name="ga48d0e039318fbf366060a0e22ce0faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d0e039318fbf366060a0e22ce0faf8">&#9670;&#160;</a></span>diff_sqr_two_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_sqr_two_norm2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of two-norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = sum((x[i]-y[i])*(x[i]-y[i])), for i = 0, 1.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03094">3094</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gac2c57116db0ca1429988fd0574ae142c" name="gac2c57116db0ca1429988fd0574ae142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c57116db0ca1429988fd0574ae142c">&#9670;&#160;</a></span>diff_sqr_two_norm3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_sqr_two_norm3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of two-norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = sum((x[i]-y[i])*(x[i]-y[i])), for i = 0, 1, 2.
</pre><dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03120">3120</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga670a257d1a466cdd36ffe2bbed43706e" name="ga670a257d1a466cdd36ffe2bbed43706e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga670a257d1a466cdd36ffe2bbed43706e">&#9670;&#160;</a></span>diff_sqr_two_norm_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_sqr_two_norm_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of two-norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = sum((x[i]-y[i])*(x[i]-y[i])), for i = 0.. n-1.
</pre> 
<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03145">3145</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaf51cf641c87bced902c71da17b66e1a9" name="gaf51cf641c87bced902c71da17b66e1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51cf641c87bced902c71da17b66e1a9">&#9670;&#160;</a></span>diff_sqr_two_norm_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_sqr_two_norm_n_par </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of two-norm of difference between two vectors (parallel version). </p>
<pre class="fragment">   s = sum((x[i]-y[i])*(x[i]-y[i])), for i = 0.. n-1.
</pre><dl class="section note"><dt>Note</dt><dd>The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03205">3205</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga58ae7595ee2d19fe665cb25d3fd11fea" name="ga58ae7595ee2d19fe665cb25d3fd11fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ae7595ee2d19fe665cb25d3fd11fea">&#9670;&#160;</a></span>diff_two_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_two_norm2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two-norm of the difference between arrays [<code class="param">x</code>, <code class="param">x</code> + 2[ and [<code class="param">y</code>, <code class="param">y</code> + 2[. </p>
<pre class="fragment">   sqrt(sum((x[i]-y[i])*(x[i]-y[i])), for i = 0, 1.
</pre><dl class="section pre"><dt>Precondition</dt><dd>For <span class="tt">double</span> arrays only. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03247">3247</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga00fc6b135583370573799dda5ba59aba" name="ga00fc6b135583370573799dda5ba59aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00fc6b135583370573799dda5ba59aba">&#9670;&#160;</a></span>diff_two_norm3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_two_norm3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two-norm of the difference between arrays [<code class="param">x</code>, <code class="param">x</code> + 3[ and [<code class="param">y</code>, <code class="param">y</code> + 3[. </p>
<pre class="fragment">   sqrt (sum ((x[i]-y[i])*(x[i]-y[i])), for i = 0, 1, 2.
</pre><dl class="section pre"><dt>Precondition</dt><dd>For <span class="tt">double</span> arrays only. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03272">3272</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga0ba53126dcea5a32ba2e2af6e6a0c0b3" name="ga0ba53126dcea5a32ba2e2af6e6a0c0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ba53126dcea5a32ba2e2af6e6a0c0b3">&#9670;&#160;</a></span>diff_two_norm_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_two_norm_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two-norm of the difference between two vectors. </p>
<pre class="fragment">   sqrt(sum((x[i]-y[i])*(x[i]-y[i]))), for i = 0...n-1  
</pre><dl class="section pre"><dt>Precondition</dt><dd>For <span class="tt">double</span> arrays only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03296">3296</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gacf7d1777a1d120e62d5310939da70dfd" name="gacf7d1777a1d120e62d5310939da70dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf7d1777a1d120e62d5310939da70dfd">&#9670;&#160;</a></span>diff_max_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_max_norm2 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = max(|x[i]-y[i]|), for i = 0, 1.
</pre><dl class="section pre"><dt>Precondition</dt><dd>Operator <span class="tt">Tabs</span> must be defined for the element type. </dd>
<dd>
Operator <span class="tt">&lt;</span> must be defined for the element type. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03322">3322</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="ga6823d6897d534f4341836a96a15bfcb3" name="ga6823d6897d534f4341836a96a15bfcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6823d6897d534f4341836a96a15bfcb3">&#9670;&#160;</a></span>diff_max_norm3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_max_norm3 </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = max(|x[i]-y[i]|), for i = 0, 1, 2.
</pre><dl class="section pre"><dt>Precondition</dt><dd>Operator <span class="tt">Tabs</span> must be defined for the element type. </dd>
<dd>
Operator <span class="tt">&lt;</span> must be defined for the element type. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This specialization makes the optimizer's job easier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03348">3348</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gacff63e61253e93476a3bd71b600812c5" name="gacff63e61253e93476a3bd71b600812c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff63e61253e93476a3bd71b600812c5">&#9670;&#160;</a></span>diff_max_norm_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterX, class IterY&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cm2::biggest2_type&lt; typenamestd::iterator_traits&lt; IterX &gt;::value_type, typenamestd::iterator_traits&lt; IterY &gt;::value_type &gt;::type cm2::vecvec::diff_max_norm_n </td>
          <td>(</td>
          <td class="paramtype">IterX</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterY</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max norm of difference between two vectors (serial version). </p>
<pre class="fragment">   s = max(|x[i]-y[i]|), for i = 0.. n-1.
</pre><dl class="section pre"><dt>Precondition</dt><dd>Operator <span class="tt">Tabs</span> must be defined for the element type. </dd>
<dd>
Operator <span class="tt">&lt;</span> must be defined for the element type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03374">3374</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gaada6081e00a3cd54f8e5536bfb1c4161" name="gaada6081e00a3cd54f8e5536bfb1c4161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaada6081e00a3cd54f8e5536bfb1c4161">&#9670;&#160;</a></span>mult_sum_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cm2::vecvec::mult_sum_n </td>
          <td>(</td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mult Sum (serial version). </p>
<pre class="fragment">   s += y[i] * (y[i] * x[i])
   y[i] *= x[i]
</pre><dl class="section note"><dt>Note</dt><dd>No overlapping allowed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03468">3468</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
<a id="gae4af298317878f0e988cf7b717c7e677" name="gae4af298317878f0e988cf7b717c7e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4af298317878f0e988cf7b717c7e677">&#9670;&#160;</a></span>mult_sum_n_par()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T cm2::vecvec::mult_sum_n_par </td>
          <td>(</td>
          <td class="paramtype">const T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *CM2_RESTRICT</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>          <td class="paramname"><span class="paramname"><em>DUM_OMP</em></span>nthreads&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mult Sum (parallel version). </p>
<pre class="fragment">   s += y[i] * (y[i] * x[i])
   y[i] *= x[i]
</pre><dl class="section note"><dt>Note</dt><dd>No overlapping allowed. </dd>
<dd>
The computation is done in parallel only when vectors are long enough (size &gt; CM2_OMP_MIN_LOOP), <code class="param">nthreads</code> &gt; 1 and if OMP is enabled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vecvec_8h_source.html#l03497">3497</a> of file <a class="el" href="vecvec_8h_source.html">vecvec.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <a href="https://www.computing-objects.com">Computing Objects SARL</a>, 
    25 rue du Mar&eacute;chal Foch, F-78000 Versailles, France. &copy;&nbsp;1999-2025.
    Generated on Fri Jun 27 2025 16:11:34 by <a href="http://www.doxygen.org">Doxygen</a>. 
    </li>
  </ul>
</div>
</body>
</html>
