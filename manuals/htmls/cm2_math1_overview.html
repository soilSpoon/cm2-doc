<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .page {
            page-break-after: always;
            margin-bottom: 50px;
            padding: 20px;
            border: 1px solid #ddd;
        }
        .page-header {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #333;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }
        table td, table th {
            border: 1px solid #ddd;
            padding: 8px;
        }
        pre, code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
        }
        pre {
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
<!-- Model: document-parse-250618 -->
<div class="page">
<div class="page-header">Page 1</div>
<h1 id='0' style='font-size:20px'>CM2 Math1</h1>
<br><h1 id='1' style='font-size:16px'>Version 5.6</h1>
<p id='2' data-category='paragraph' style='font-size:18px'>overview</p>
<p id='3' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>
</div>
<div class="page">
<div class="page-header">Page 2</div>
<h1 id='4' style='font-size:20px'>Forewords</h1>
<p id='5' data-category='paragraph' style='font-size:16px'>CM2 Math1 is the core mathematical library used by the mesh generators of CM2 MeshTools® SDK and the FEA<br>CM2 FEM® SDK.</p>
<p id='6' data-category='paragraph' style='font-size:16px'>For maximum performance all the CM2 software components are developed using standard C++ with efficient<br>object-oriented programming techniques (templates, very few virtual classes).</p>
<br><p id='7' data-category='paragraph' style='font-size:16px'>They have been ported to most major platforms (Windows®, Linux, macOS®).</p>
<br><p id='8' data-category='paragraph' style='font-size:16px'>With a binary license these libraries are shipped as C++ headers files together with dynamic libraries – Win32/<br>Win64 .dll/.lib, shared Linux x86/x86-64 .so or macOS .dylib.</p>
<br><p id='9' data-category='paragraph' style='font-size:16px'>Source codes are also available.</p>
<table id='10' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>2</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 3</div>
<h1 id='11' style='font-size:20px'>Table of contents</h1>
<p id='12' data-category='index' style='font-size:16px'>Forewords .................................................................................................................................................. 2<br>Introduction .............................................................................................................................................. 4<br>Variable-size containers and fixed-size containers .............................................................................. 5<br>Views of the variable-size containers .................................................................................................... 7<br>Fixed-size containers ................................................................................................................................ 8<br>STL-like iterators and the template math library ................................................................................. 9<br>Bound checking ...................................................................................................................................... 10<br>Interoperability with other math containers ...................................................................................... 10<br>Appendix - template math functions list ............................................................................................. 13<br>Vector - Scalar functions (cm2::vecscal) 13<br>Vector - Vector functions (cm2::vecvec) 15<br>Matrix - Scalar functions (cm2::matscal) 18<br>Matrix - Vector functions (cm2::matvec) 20<br>Matrix - Matrix functions (cm2::matmat) 22</p>
<table id='13' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>3</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 4</div>
<h1 id='14' style='font-size:22px'>Introduction</h1>
<p id='15' data-category='paragraph' style='font-size:20px'>We intend here to give only a short description of the classes in the CM2 Math1 library and its associated<br>template libraries. We’ll simply explain the basic traits of these math containers and show a few usages of the<br>template functions. Please read the CM2 Math1 HTML reference manual (Doxygen© generated)1 for full<br>description.</p>
<p id='16' data-category='paragraph' style='font-size:20px'>To use CM2 Math1 you must include the header math1.h and link against the cm2math1 lib (for example<br>cm2math1_x64_56.lib for version 5.6, Windows x64).</p>
<br><p id='17' data-category='paragraph' style='font-size:20px'>Classes of CM2 Math1 are defined in the cm2 namespace. The template math functions are nested in<br>cm2::vecscal, cm2::vecvec, cm2::matscal, cm2::matvec and cm2::matmat (see Appendix for lists of<br>functions).</p>
<br><p id='18' data-category='paragraph' style='font-size:20px'>For sake of simplification we’ll assume in the rest of this document a using namespace cm2 directive to allow<br>us omitting the cm2:: namespace before any of the CM2 Math1 class and any nested template math library.</p>
<br><p id='19' data-category='paragraph' style='font-size:20px'>The CM2 Math1 library exports 21 types of vector, 17 types of rectangular matrix and 14 types of symmetric<br>matrix2.</p>
<br><p id='20' data-category='paragraph' style='font-size:20px'>They can be divided into two main categories:</p>
<br><p id='21' data-category='list' style='font-size:20px'>• The variable-size containers such as DoubleVec, DoubleMat, DoubleSym, DoubleSparse.<br>• The fixed-size containers such as DoubleVec3, DoubleMat2x2, DoubleSym2.</p>
<p id='22' data-category='paragraph' style='font-size:20px'>☞ Following the C usage, all these math containers are zero based: a vector of size N extends from index 0 to N-1.</p>
<p id='23' data-category='list' style='font-size:14px'>1 See math1.html or math1.chm.</p>
<p id='24' data-category='footnote' style='font-size:16px'>2 Based on the template classes: cm2::vector_fixed<T, N>, cm2::matrix_fixed<T, M, N>, cm2::dense1D<T>, cm2::dense2D<T>,<br>cm2::symmetric_full<T>, cm2::symmetric_sparse<T>.</p>
<table id='25' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 4</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 5</div>
<h1 id='26' style='font-size:22px'>Variable-size containers and fixed-size containers</h1>
<br><p id='27' data-category='paragraph' style='font-size:18px'>The containers of variable-sized category can be resized, automatically or manually. They have also shallow<br>copy constructors and copy operators. A variable-size container holds a reference to a data array (mere view)<br>and a copy implies only a copy of that reference not the data (shallow copy).</p>
<br><p id='28' data-category='paragraph' style='font-size:18px'>On the other hand, a fixed-size container actually holds the data as a member array and a copy actually copies<br>the data (deep copy).</p>
<p id='29' data-category='paragraph' style='font-size:20px'>Example</p>
<table id='30' style='font-size:16px'><thead></thead><tbody><tr><td>DoubleVec V1;</td><td>// Empty vector.</td></tr><tr><td>DoubleVec V2(10, +1.); V1.push_back(1.)</td><td>// Vector of 10 values, all initialized to 1. // V1.size() = 1</td></tr><tr><td>V1.push_back(2.)</td><td>// V1.size() = 2</td></tr><tr><td>V1.push_back(3., 4., 5.);</td><td>// V1.size() = 5</td></tr><tr><td>V1.push_back_n(6., 10);</td><td>// V1.size() = 15</td></tr><tr><td>V1 = V2;</td><td>// Shallow copy3 (V1.size() = 10). // Previous values of V1 are lost.</td></tr><tr><td>V1[0] = 0.;</td><td>// V2[0] = 0. (because the data are shared). 10</td></tr><tr><td>V2.clear();</td><td>// V2.size() = 0 but V1.size() = // The data are not deleted because still viewed // from V1.</td></tr></tbody></table>
<table id='31' style='font-size:14px'><thead></thead><tbody><tr><td>3 A deep copy can be obtained with the template function vecvec::copy</td><td>:</td></tr><tr><td>V1.resize(V2.size()); vecvec::copy(V2, V1); or with the "copy" member: V1.copy(V2);</td><td>// Resize V1 to V2.size(). // Copy all V2 values into V1. // Resize V1 to V2.size() and copies the data.</td></tr></tbody></table>
<table id='32' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 5</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 6</div>
<table id='33' style='font-size:16px'><thead><tr><td>Vectors</td><td>Rectangular matrices</td><td>Symmetric matrices</td><td>Symmetric sparse matrices</td></tr></thead><tbody><tr><td>DoubleVec</td><td>DoubleMat</td><td>DoubleSym</td><td>DoubleSymSparse</td></tr><tr><td>FloatVec</td><td>FloatMat</td><td>FloatSym</td><td>FloatSymSparse</td></tr><tr><td>IntVec</td><td>IntMat</td><td>IntSym</td><td>IntSymSparse</td></tr><tr><td>UIntVec</td><td>UIntMat</td><td>UIntSym</td><td>UIntSymSparse</td></tr><tr><td>DoubleZVec</td><td>DoubleZMat</td><td>DoubleZSym</td><td>DoubleZSymSparse</td></tr><tr><td>DoubleVec2</td><td></td><td></td><td></td></tr><tr><td>DoubleVec3</td><td>DoubleMat3x1</td><td>DoubleSym2</td><td></td></tr><tr><td>DoubleVec4</td><td>DoubleMat2x2</td><td></td><td></td></tr><tr><td>DoubleVec5</td><td></td><td></td><td></td></tr><tr><td>DoubleVec6</td><td>DoubleMat3x2</td><td></td><td></td></tr><tr><td>DoubleMat2x3</td><td>DoubleSym3</td><td></td><td></td></tr><tr><td>DoubleVec7</td><td></td><td></td><td></td></tr><tr><td>DoubleVec8</td><td></td><td></td><td></td></tr><tr><td>DoubleVec9</td><td>DoubleMat3x3</td><td></td><td></td></tr><tr><td></td><td>DoubleMat3x4</td><td></td><td></td></tr><tr><td>UIntVec2</td><td></td><td></td><td></td></tr><tr><td>UIntVec3</td><td>UIntMat3x1</td><td>UIntSym2</td><td></td></tr><tr><td>UIntVec4</td><td>UIntMat2x2</td><td></td><td></td></tr><tr><td>UIntVec5</td><td></td><td></td><td></td></tr><tr><td>UIntVec6</td><td>UIntMat3x2</td><td></td><td></td></tr><tr><td>UIntMat2x3</td><td>UIntSym3</td><td></td><td></td></tr><tr><td>UIntVec7</td><td></td><td></td><td></td></tr><tr><td>UIntVec8</td><td></td><td></td><td></td></tr><tr><td>UIntVec9</td><td>UIntMat3x3</td><td></td><td></td></tr><tr><td></td><td>UIntMat3x4</td><td></td><td></td></tr></tbody></table>
<p id='34' data-category='paragraph' style='font-size:14px'>Table 1 – The CM2 Math1 vector and matrix types<br>(first 5 lines are variable-size containers, the other lines are fixed-size containers).</p>
<table id='35' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>6</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 7</div>
<h1 id='36' style='font-size:22px'>Views of the variable-size containers</h1>
<br><p id='37' data-category='paragraph' style='font-size:16px'>Several variable-sized containers can have view on the same array of data but the views can be different from<br>each other. The beginning and the size in the array are specific to each container.<br>For instance, in an array of 30 items, a first vector views items from 0 to 9 and a second one views items from 5<br>to 20.</p>
<figure id='38'><img style='font-size:18px' alt="beg = 0 beg = 5
size = 10 size = 16
data data
DATA ARRAY" data-coord="top-left:(403,301); bottom-right:(833,634)" /></figure>
<br><caption id='39' style='font-size:14px'>Figure 1 – Views and data in variable-sized vectors</caption>
<p id='40' data-category='paragraph' style='font-size:16px'>Elements from 5 to 9 are accessible from the two vectors.</p>
<br><p id='41' data-category='paragraph' style='font-size:16px'>When a destructor is called on a variable-size container the data is destroyed only when no other container<br>references this data anymore. A smart pointer mechanism is used to count the number of references on the<br>data and the deallocation actually occurs when the count reaches zero. The memory management is automatic<br>(automatic garbage collection).</p>
<h1 id='42' style='font-size:20px'>Example</h1>
<table id='43' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleVec</td><td>*V1(new DoubleVec(10, -1.));</td></tr><tr><td>DoubleVec</td><td>*V2(new DoubleVec(*V1)); // Shallow copy (share the data).</td></tr><tr><td>delete V1; delete V2;</td><td>// Data is still referenced by V2. // Now data is destroyed too.</td></tr></tbody></table>
<p id='44' data-category='paragraph' style='font-size:16px'>The variable-size matrix types (IntMat, UIntMat, DoubleMat, DoubleZMat...) have similar behavior with<br>respect to the memory management and the copy operators (and copy-constructors). Data is shared, copies<br>are shallow.</p>
<table id='45' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>7</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 8</div>
<h1 id='46' style='font-size:20px'>Fixed-size containers</h1>
<p id='47' data-category='paragraph' style='font-size:16px'>The fixed-size math containers are deep-copy containers.</p>
<br><p id='48' data-category='paragraph' style='font-size:16px'>The copy-constructor and the copy-operator do not share the data anymore but leads to actually different<br>arrays in memory. They are simpler than the variable-size containers and faster for short arrays whereas the<br>variable-size containers are more suited for big arrays.</p>
<br><p id='49' data-category='paragraph' style='font-size:16px'>The fixed-size vectors are similar to the STL std::array class.</p>
<p id='50' data-category='paragraph' style='font-size:18px'>Example</p>
<table id='51' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleVec2 DoubleVec2</td><td>V1; // Vector of 2 uninitialized values (double). V2(1.); // Vector of 2 values initialized to 1.</td></tr><tr><td>V1[0] = 0.; V1[1] = -1.; V1 = V2; V2[0] = 0.; V1[1] = 0.;</td><td>// Deep copy: V1 = {1, 1}, V2 = {1, 1}. // V1 = {1, 1}, V2 = {0, 1} // V1 = {1, 0}, V2 = {0, 1}</td></tr></tbody></table>
<p id='52' data-category='paragraph' style='font-size:16px'>The fixed-size matrix types (DoubleMat3x3, UIntMat2x3...) have similar behavior with respect to the memory<br>management and the copy operators (and copy-constructors). Data are not shared, copies are deep.</p>
<table id='53' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>8</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 9</div>
<h1 id='54' style='font-size:20px'>STL-like iterators and the template math library</h1>
<br><p id='55' data-category='paragraph' style='font-size:16px'>The vector containers - variable-size and fixed-size - are equipped with STL-like iterators begin() and end()<br>to make them compatible with most of the C++ Standard Template Library (STL) algorithms.</p>
<br><p id='56' data-category='paragraph' style='font-size:16px'>They also have access operators such as operator[] and the usual functions for a vector class: size(),<br>empty(), front(), back()...</p>
<br><p id='57' data-category='paragraph' style='font-size:16px'>The variable-size vectors are also equipped with members such as reserve, resize, push_back and pop_<br>back.</p>
<br><p id='58' data-category='paragraph' style='font-size:16px'>Aside from the STL algorithms, one can also use the CM2 Math1 template functions in cm2::vecscal, cm2:<br>:vecvec, cm2::matscal, cm2::matvec and cm2::matmat (cf. CM2 Math1 HTML reference manual).</p>
<p id='59' data-category='paragraph' style='font-size:18px'>Example</p>
<table id='60' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleVec</td><td>V1(3), V2(3,-1.);</td></tr><tr><td>DoubleMat</td><td>M(3, 10, 0.); // Matrix of doubles 3 by 10 set to 0. <table><thead></thead><tbody><tr><td>vecvec::copy(V2, V1);</td><td>// Hard copy of V2 into V1 (sizes match).</td></tr><tr><td>vecvec::axpy(2., V1, V2); vecscal::mult(-1., V1);</td><td>// V2 += 2 * V1 // V1 = -V1</td></tr></tbody></table></td></tr></tbody></table>
<p id='61' data-category='paragraph' style='font-size:16px'>In matrix classes (variable-sized or fixed-sized), the rows and the columns are equipped with iterators just like<br>the vectors and the same template functions can be used on them.</p>
<p id='62' data-category='paragraph' style='font-size:18px'>Example</p>
<table id='63' style='font-size:14px'><thead></thead><tbody><tr><td>const size_t</td><td>N(10);</td></tr><tr><td>const double</td><td>PI(3.14159);</td></tr><tr><td>DoubleMat</td><td>pos(2, N); // Uninitialized 2xN matrix.</td></tr><tr><td>DoubleVec2</td><td>V; // Uninitialized vector of size 2.</td></tr></tbody></table>
<br><p id='64' data-category='paragraph' style='font-size:14px'>// Points on a circle.<br>for (size_t j = 0; j < N; ++j)</p>
<br><p id='65' data-category='paragraph' style='font-size:14px'>{</p>
<br><p id='66' data-category='paragraph' style='font-size:14px'>pos(0, j) = ::cos(j*2*PI/N);<br>pos(1, j) = ::sin(j*2*PI/N);</p>
<br><p id='67' data-category='paragraph' style='font-size:14px'>}</p>
<br><p id='68' data-category='paragraph' style='font-size:14px'>// Set radius to 3.<br>matscal::mult(3., pos);</p>
<br><p id='69' data-category='paragraph' style='font-size:14px'>// Copy segment/column #2 to V (ok dimensions match).<br>vecvec::copy(pos.seg(2), V);</p>
<br><p id='70' data-category='paragraph' style='font-size:14px'>// Copy V to segment/column #9 (the last one).<br>vecvec::copy(V, pos.seg(9));</p>
<br><p id='71' data-category='paragraph' style='font-size:14px'>// Copy segment/column #9 to segment/column #0.<br>vecvec::copy(pos.seg(9), pos.seg(0));</p>
<br><p id='72' data-category='paragraph' style='font-size:14px'>// Append V in a new column of pos (dimensions match).<br>pos.push_back(V); // pos.cols() = 11 after this line.</p>
<table id='73' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 9</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 10</div>
<h1 id='74' style='font-size:20px'>Bound checking</h1>
<br><p id='75' data-category='paragraph' style='font-size:16px'>In debug mode (with macro NDEBUG not defined) bound violations abort the program. In release mode<br>however, for best performance, no check is performed and the user must take care not to out-value the limits<br>of the vectors and matrices.</p>
<br><h1 id='76' style='font-size:20px'>Interoperability with other math containers</h1>
<br><p id='77' data-category='paragraph' style='font-size:16px'>The API of the CM2 MeshTools library use exclusively vectors and matrices of the CM2 Math1 library (such as<br>DoubleMat, UIntMat, FloatVec...)</p>
<br><p id='78' data-category='paragraph' style='font-size:16px'>To use the meshers with other types of vectors and matrices, the variable-size containers are equipped with<br>constructors with raw pointers as arguments. Hence they can view the data in any other math containers as<br>long as the latter provide a way to get a raw pointer to their data and that these data are contiguous in<br>memory.</p>
<br><p id='79' data-category='paragraph' style='font-size:16px'>Remember that the variable-size containers implement shallow copies. This means that the arrays are shared<br>not copied. Therefore the memory management becomes a point to take care of and the user must keep in<br>mind which library is responsible for deleting the memory upon exit. The default is that the allocator of the<br>array remains responsible for its deletion.</p>
<p id='80' data-category='paragraph' style='font-size:18px'>Example</p>
<table id='81' style='font-size:14px'><thead></thead><tbody><tr><td>double</td><td>buff1[100]; // Static-allocated C array.</td></tr><tr><td>double*</td><td>buff2(new double[100]); // Dynamic-allocated C array.</td></tr><tr><td>std::vector<double></td><td>buff3(100); // STL vector.</td></tr><tr><td>std::array<double, 100></td><td>buff4; // STL array.</td></tr></tbody></table>
<br><table id='82' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleVec</td><td>V1(50, buff1); // Views the first 50 elements in buff1.</td></tr><tr><td>DoubleVec</td><td>V2(50, buff2); // Views the first 50 elements in buff2.</td></tr><tr><td>DoubleVec</td><td>V3(50, buff3.begin()); // Views the first 50 elements in buff3.</td></tr><tr><td>DoubleVec</td><td>V4(50, buff4.begin()); // Views the first 50 elements in buff4.</td></tr></tbody></table>
<br><table id='83' style='font-size:14px'><thead></thead><tbody><tr><td>V2.clear();</td><td>//</td><td>buff2 is not deallocated.</td></tr><tr><td>V2 = V1;</td><td>//</td><td>buff2 is not deallocated.</td></tr><tr><td>V3.clear();</td><td>//</td><td>buff3 is not deallocated.</td></tr><tr><td>V4.clear();</td><td>//</td><td>buff4 is not deallocated.</td></tr><tr><td>delete[] buff2;</td><td>// //</td><td>Dangerous: V2 is still alive (though emptied). Don’t use V2 anymore or use V2.clear_hard().</td></tr><tr><td>buff3.clear();</td><td>// //</td><td>Dangerous: data in buff3 may has been deallocated. Don't use V3 anymore or use V3.clear_hard().</td></tr></tbody></table>
<p id='84' data-category='paragraph' style='font-size:16px'>This can be done also with the fixed-size containers of CM2 Math1:</p>
<p id='85' data-category='paragraph' style='font-size:14px'>DoubleVec3 V3(1., 0., -1.);<br>DoubleVec V(3, V1.begin()); // Views the elements in V3.</p>
<p id='86' data-category='paragraph' style='font-size:16px'>Similarly, the matrices of CM2 Math1 can view the data in an external container. Together with the raw pointer<br>to the data, the user must provide the number of rows, the number of columns and the stride between two<br>columns (so-called leading dimension):</p>
<table id='87' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 10</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 11</div>
<p id='88' data-category='paragraph' style='font-size:16px'>unsigned* buff(new unsigned[30]);<br>UIntMat M(3, 10, /*ld=>*/ 3, buff);</p>
<p id='89' data-category='paragraph' style='font-size:20px'>As before, the matrix is not responsible for the deletion of the underlying buffer4.</p>
<br><p id='90' data-category='paragraph' style='font-size:20px'>In the case where a container constructed this way is subsequently resized, it may "point" to another array of<br>memory but the initial buffer remains valid:</p>
<p id='91' data-category='paragraph' style='font-size:16px'>double* buff(new double[6]);<br>DoubleVec V(5, buff);</p>
<br><table id='92' style='font-size:16px'><thead></thead><tbody><tr><td>V.push_back(2.0);</td><td>// Reallocation and copy performed.</td></tr><tr><td>V.clear_hard();</td><td>// buff is still alive, but V does not "point" to // it anymore. // The new array of V is deallocated, not buff.</td></tr></tbody></table>
<p id='93' data-category='paragraph' style='font-size:20px'>☞ As a rule of thumb, the lifetime of the external buffer must span the lifetime of the math1 container.</p>
<h1 id='94' style='font-size:16px'>double* buff(new double[6]);</h1>
<br><p id='95' data-category='paragraph' style='font-size:16px'>{</p>
<br><p id='96' data-category='paragraph' style='font-size:16px'>DoubleVec V(5, buff);<br>... // Use V here.<br>} // V is killed here but the buffer is spared.</p>
<br><p id='97' data-category='paragraph' style='font-size:16px'>delete[] buff; // So long with buff.</p>
<p id='98' data-category='paragraph' style='font-size:14px'>4 A default parameter protect in the constructors can be used to change this behavior.</p>
<table id='99' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 11</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 12</div>
<p id='100' data-category='paragraph' style='font-size:16px'>We have seen how to construct CM2 Math1 variable-size container upon other containers or buffers.<br>To do the other way, we use the data() or begin() members to access the underlying data:</p>
<p id='101' data-category='paragraph' style='font-size:20px'>Example</p>
<p id='102' data-category='paragraph' style='font-size:14px'>DoubleVec V(50, 0.);<br>double* buff(V.data());<br>size_t N(V.size()); // Equals to 50</p>
<br><p id='103' data-category='paragraph' style='font-size:14px'>for (size_t i = 0; i < N; ++i, ++buff)<br>*buff = double(i);</p>
<br><p id='104' data-category='paragraph' style='font-size:14px'>assert (V[10] == 10.); // Changes in buff have been seen in V.</p>
<table id='105' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleMat</td><td>P(3, 40);</td></tr><tr><td>double*</td><td>buff(P.data());</td></tr><tr><td>size_t</td><td>M(P.rows()); // Equals to 3</td></tr><tr><td>size_t</td><td>N(P.cols()); // Equals to 40</td></tr><tr><td>size_t</td><td>LD(P.ld()); // Equals to 3 (here stride = rows).</td></tr></tbody></table>
<br><p id='106' data-category='paragraph' style='font-size:14px'>for (size_t j = 0; j < N; ++j)<br>for (size_t i = 0; i < M; ++i)<br>buff[i + j*LD] = double(i + j*LD);</p>
<br><p id='107' data-category='paragraph' style='font-size:14px'>assert(P(0,10) == 30.); // Changes in buff have been seen in P.</p>
<p id='108' data-category='paragraph' style='font-size:16px'>Here the CM2 Math1 vectors and matrices are responsible for the deletion of its data:</p>
<p id='109' data-category='paragraph' style='font-size:14px'>DoubleMat P(3, 40);<br>double* buff(P.data());</p>
<br><p id='110' data-category='paragraph' style='font-size:14px'>delete[] buff; // Don't do that!<br>P.resize(3, 80); // Crash now or maybe later...</p>
<table id='111' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>12</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 13</div>
<h1 id='112' style='font-size:20px'>Appendix - template math functions list</h1>
<br><h1 id='113' style='font-size:18px'>Vector - Scalar functions (cm2::vecscal)</h1>
<p id='114' data-category='paragraph' style='font-size:14px'>// Inserts a value inside a vector.<br>template <class Vec><br>void insert (typename Vec::value_type v, size_t i, Vec &X);</p>
<br><p id='115' data-category='paragraph' style='font-size:14px'>// Removes a value inside a vector.</p>
<br><p id='116' data-category='paragraph' style='font-size:14px'>template <class Vec><br>void remove (size_t i, Vec &X);</p>
<br><p id='117' data-category='paragraph' style='font-size:14px'>// Copies a value into a vector.</p>
<br><p id='118' data-category='paragraph' style='font-size:14px'>template <class Vec><br>void copy (typename Vec::value_type v, Vec &X);</p>
<br><p id='119' data-category='paragraph' style='font-size:14px'>// Adds a value to a vector.<br>template <class Vec><br>void add (typename Vec::value_type v, Vec &X);</p>
<br><p id='120' data-category='paragraph' style='font-size:14px'>// Subtracts a value from a vector.<br>template <class Vec><br>void subtract (typename Vec::value_type v, Vec &X);</p>
<br><p id='121' data-category='paragraph' style='font-size:14px'>// Multiplies a vector by a scalar.<br>template <class Vec><br>void mult (typename Vec::value_type v, Vec &X);</p>
<br><p id='122' data-category='paragraph' style='font-size:14px'>// Divides a vector by a scalar.<br>template <class Vec><br>void div (typename Vec::value_type v, Vec &X);</p>
<br><p id='123' data-category='paragraph' style='font-size:14px'>// Negates a vector.<br>template <class Vec><br>void negate (Vec &X);</p>
<br><p id='124' data-category='paragraph' style='font-size:14px'>// Sets a vector to its reciprocal (element by element).</p>
<br><p id='125' data-category='paragraph' style='font-size:14px'>template <class Vec><br>void reciprocal (Vec &X);</p>
<br><p id='126' data-category='paragraph' style='font-size:14px'>// The index of the max in a vector.</p>
<br><p id='127' data-category='paragraph' style='font-size:14px'>template <class Vec><br>size_t max_index (const Vec &x);</p>
<br><p id='128' data-category='paragraph' style='font-size:14px'>// The index of the min in a vector.<br>template <class Vec><br>size_t min_index (const Vec &x);</p>
<br><p id='129' data-category='paragraph' style='font-size:14px'>// The index of the max magnitude (max(|x[i]|) in a vector.<br>template <class Vec><br>size_t max_norm_index (const Vec &x);</p>
<br><p id='130' data-category='paragraph' style='font-size:14px'>// The index of the min magnitude (min(|x[i]|) in a vector.<br>template <class Vec><br>size_t min_norm_index (const Vec &x);</p>
<br><p id='131' data-category='paragraph' style='font-size:14px'>// The maximum value in a vector.<br>template <class Vec><br>typename Vec::value_type max_value (const Vec &x);</p>
<br><p id='132' data-category='paragraph' style='font-size:14px'>// The minimum value in a vector.</p>
<br><p id='133' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type min_value (const Vec &x);</p>
<br><p id='134' data-category='paragraph' style='font-size:14px'>// Increases range R with the range of a vector.<br>template <class Vec, class Range><br>void inc_range (const Vec &X, Range &R);</p>
<br><p id='135' data-category='paragraph' style='font-size:14px'>// The range of values in a vector (first = min, second = max)<br>template <class Vec><br>std::pair<typename Vec::value_type, typename Vec::value_type> range (const Vec &X);</p>
<br><p id='136' data-category='paragraph' style='font-size:14px'>// The sum of the elements in a vector.</p>
<br><p id='137' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type sum (const Vec &X);</p>
<br><p id='138' data-category='paragraph' style='font-size:14px'>// The product of the elements in a vector.<br>template <class Vec><br>typename Vec::value_type prod (const Vec &X);</p>
<table id='139' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 13</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 14</div>
<p id='140' data-category='paragraph' style='font-size:14px'>// The one-norm of a vector (the sum of absolute elements).</p>
<br><p id='141' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type one_norm (const Vec &X);</p>
<br><p id='142' data-category='paragraph' style='font-size:14px'>// The two-norm of a vector (usual Euclidean norm).<br>template <class Vec><br>typename Vec::value_type two_norm (const Vec &X);</p>
<br><p id='143' data-category='paragraph' style='font-size:14px'>// The max-norm (infinite norm).</p>
<br><p id='144' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type max_norm (const Vec &X);</p>
<br><p id='145' data-category='paragraph' style='font-size:14px'>// The square of the two-norm of a vector.<br>template <class Vec><br>typename Vec::value_type sqr_two_norm (const Vec &X);</p>
<br><p id='146' data-category='paragraph' style='font-size:14px'>// Normalizes a vector (if not null).</p>
<br><p id='147' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type normalize (Vec &X);</p>
<br><p id='148' data-category='paragraph' style='font-size:14px'>// The arithmetic mean of a vector.</p>
<br><p id='149' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type mean (const Vec &X);</p>
<br><p id='150' data-category='paragraph' style='font-size:14px'>// Statistics on a vector (mean and variance).<br>template <class Vec, class T><br>void statistics (const Vec &X, T &mean, T &variance);</p>
<br><p id='151' data-category='paragraph' style='font-size:14px'>// The number of elements in a vector that match a predicate.<br>template <class Vec , class Predicate><br>size_t count_if (const Vec &X, Predicate pred);</p>
<br><p id='152' data-category='paragraph' style='font-size:14px'>// Tests all elements in a vector against a scalar.<br>template <class Vec><br>bool equal (const Vec &X, typename Vec::value_type v);</p>
<br><p id='153' data-category='paragraph' style='font-size:14px'>// Has the vector only finite values (float and double only).<br>template <class Vec><br>bool isfinite (const Vec &X);</p>
<br><p id='154' data-category='paragraph' style='font-size:14px'>// Adds random values between 0 and v to all elements of a vector.<br>template <class Vec><br>void randomize (Vec &X, typename Vec::value_type v);</p>
<br><p id='155' data-category='paragraph' style='font-size:14px'>// Adds random values between v1 and v2 to all elements of a vector.<br>template <class Vec><br>void randomize_range (Vec &X, typename Vec::value_type v1, typename Vec::value_type v2);</p>
<br><p id='156' data-category='paragraph' style='font-size:14px'>// Multiplies the elements of a vector by random values between 1-v and 1+v.</p>
<br><p id='157' data-category='paragraph' style='font-size:14px'>template <class Vec><br>void randomize_mult (Vec &X, typename Vec::value_type v);</p>
<br><p id='158' data-category='paragraph' style='font-size:14px'>// Adds random values between 0 and v to all elements of a vector.<br>template <class Vec, class RandGen><br>void randomize (Vec &X, typename Vec::value_type v, RandGen &randg);</p>
<br><p id='159' data-category='paragraph' style='font-size:14px'>// Adds random values between v1 and v2 to all elements of a vector.<br>template <class Vec, class RandGen><br>void randomize_range (Vec &X, typename Vec::value_type v1, typename Vec::value_type v2, RandGen<br>&randg)</p>
<br><p id='160' data-category='paragraph' style='font-size:14px'>// Multiplies the elements of a vector by random values between 1-v and 1+v.<br>template <class Vec, class RandGen><br>void randomize_mult (Vec &X, typename Vec::value_type v, RandGen &randg);</p>
<caption id='161' style='font-size:14px'>Table 2 – The cm2::vecscal template math library.</caption>
<table id='162' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>14</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 15</div>
<h1 id='163' style='font-size:20px'>Vector - Vector functions (cm2::vecvec)</h1>
<p id='164' data-category='paragraph' style='font-size:14px'>// Inserts some values at specific positions inside a vector.<br>template <class Vec1, class VecI, class Vec><br>void insert (const Vec1& V1, const VecI& indices, Vec &X);</p>
<br><p id='165' data-category='paragraph' style='font-size:14px'>// Removes some values at specific positions inside a vector.<br>template <class VecI, class Vec><br>void remove (const VecI& indices, Vec &X);</p>
<br><p id='166' data-category='paragraph' style='font-size:14px'>// Appends a vector to another vector.</p>
<br><p id='167' data-category='paragraph' style='font-size:14px'>template <class Vec1 , class Vec2><br>bool push_back (const Vec1 &V1, Vec2 &V2);</p>
<br><p id='168' data-category='paragraph' style='font-size:14px'>// Appends a specific batch of elements to a vector.<br>template <class Vec1, class Vec2, class Vector><br>bool push_back (const Vec1 &V1, const Vector &V1_indices, Vec2 &V2);</p>
<br><p id='169' data-category='paragraph' style='font-size:14px'>// Copies a vector to another.</p>
<br><p id='170' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>void copy (const VecX &X, VecY &Y);</p>
<br><p id='171' data-category='paragraph' style='font-size:14px'>// Swaps the values between two vectors.<br>template <class VecX, class VecY><br>void swap (VecX &X, VecY &Y)</p>
<br><p id='172' data-category='paragraph' style='font-size:14px'>// Copies the scaling of a vector to another.<br>template <class T, class VecX, class VecY><br>void copy_scale (T a, const VecX &X, VecY &Y);</p>
<br><p id='173' data-category='paragraph' style='font-size:14px'>// Adds a vector to another.<br>template <class VecX, class VecY><br>void add (const VecX &X, VecY &Y);</p>
<br><p id='174' data-category='paragraph' style='font-size:14px'>// Subtracts a vector from another.<br>template <class VecX, class VecY><br>void subtract (const VecX &X, VecY &Y);</p>
<br><p id='175' data-category='paragraph' style='font-size:14px'>// Multiplies a vector by another (element by element).<br>template <class VecX, class VecY><br>void mult (const VecX &X, VecY &Y);</p>
<br><p id='176' data-category='paragraph' style='font-size:14px'>// Divides a vector by another (element by element).<br>template <class VecX, class VecY><br>void div (const VecX &X, VecY &Y);</p>
<br><p id='177' data-category='paragraph' style='font-size:14px'>// The reciprocal vector.</p>
<br><p id='178' data-category='paragraph' style='font-size:14px'>template <class Vec><br>typename Vec::value_type reciprocal (const Vec &x, Vec &inv_x);</p>
<br><p id='179' data-category='paragraph' style='font-size:14px'>// Multiplies two vectors and adds into a third (element by element).<br>template <class VecX, class VecY, class VecZ><br>void mult (const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='180' data-category='paragraph' style='font-size:14px'>// Dot product between two vectors.</p>
<br><p id='181' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type><br>dot (const VecX &X, const VecY &Y);</p>
<br><p id='182' data-category='paragraph' style='font-size:14px'>// AXPY between two vectors.<br>template <class T, class VecX, class VecY><br>void axpy (T a, const VecX &X, VecY &Y)</p>
<br><p id='183' data-category='paragraph' style='font-size:14px'>// Element-wise multiplication between three vectors.<br>template <class T, class VecX, class VecY, class VecZ><br>void axypz (T a, const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='184' data-category='paragraph' style='font-size:14px'>// Interpolation between two vectors.<br>template <class T, class VecX, class VecY, class VecZ><br>void interpol (T a, const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='185' data-category='paragraph' style='font-size:14px'>// Copies the sum of two vectors (element by element).</p>
<br><p id='186' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY, class VecZ><br>void copy_add (const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='187' data-category='paragraph' style='font-size:14px'>// Copies the sum with scaling of two vectors (element by element).<br>template <class T, class VecX, class VecY, class VecZ><br>void copy_add (T a, const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='188' data-category='paragraph' style='font-size:14px'>// Copies the difference between two vectors (element by element).<br>template <class VecX, class VecY, class VecZ><br>void copy_diff (const VecX &X, const VecY &Y, VecZ &Z);</p>
<table id='189' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 15</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 16</div>
<p id='190' data-category='paragraph' style='font-size:14px'>// Copies the difference with scaling between two vectors (element by element).</p>
<br><p id='191' data-category='paragraph' style='font-size:14px'>template <class T, class VecX, class VecY, class VecZ></p>
<br><p id='192' data-category='paragraph' style='font-size:14px'>void copy_diff (T a, const VecX &X, const VecY &Y, VecZ &Z);</p>
<br><p id='193' data-category='paragraph' style='font-size:14px'>// The square of the two norm of the difference between two vectors.</p>
<br><p id='194' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY></p>
<br><p id='195' data-category='paragraph' style='font-size:14px'>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type></p>
<br><p id='196' data-category='paragraph' style='font-size:14px'>diff_sqr_two_norm (const VecX &X, const VecY &Y);</p>
<br><p id='197' data-category='paragraph' style='font-size:14px'>// The two norm of the difference between two vectors.</p>
<br><p id='198' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY></p>
<br><p id='199' data-category='paragraph' style='font-size:14px'>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type></p>
<br><p id='200' data-category='paragraph' style='font-size:14px'>diff_two_norm (const VecX &X, const VecY &Y);</p>
<br><p id='201' data-category='paragraph' style='font-size:14px'>// The max norm of the difference between two vectors.</p>
<br><p id='202' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type><br>diff_max_norm (const VecX &X, const VecY &Y);</p>
<br><p id='203' data-category='paragraph' style='font-size:14px'>// The dot product of the difference between two vectors and a third vector.<br>template <class VecX, class VecY, class VecZ><br>cm2::biggest3_type<typename VecX::value_type, typename VecY::value_type, typename VecZ::value_<br>type>::type><br>diff_dot (const VecX &X, const VecY &Y, const VecZ &Z);</p>
<br><p id='204' data-category='paragraph' style='font-size:14px'>// Cross product between two vectors.</p>
<br><p id='205' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY, class VecZ><br>void cross (const VecX &x, const VecY &y, VecZ &z);</p>
<br><p id='206' data-category='paragraph' style='font-size:14px'>// Cross product between two vectors, with a scaling factor.<br>template <class T, class VecX, class VecY, class VecZ><br>void cross (T a, const VecX &x, const VecY &y, VecZ &z);</p>
<br><p id='207' data-category='paragraph' style='font-size:14px'>// Copies the cross product between two vectors.</p>
<br><p id='208' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY, class VecZ><br>void copy_cross (const VecX &x, const VecY &y, VecZ &z);</p>
<br><p id='209' data-category='paragraph' style='font-size:14px'>// Copies the cross product between two vectors, with a scaling factor.<br>template <class T, class VecX, class VecY, class VecZ><br>void copy_cross (T a, const VecX &x, const VecY &y, VecZ &z);</p>
<br><p id='210' data-category='paragraph' style='font-size:14px'>// The cross product between two vectors (2-D version).</p>
<br><p id='211' data-category='paragraph' style='font-size:14px'>template <class IterX , class IterY><br>cm2::biggest2_type<typenamestd::iterator_traits<IterX>::value_type, typenamestd::iterator_<br>traits<IterY>::value_type>::type><br>cross2 (IterX x, IterY y);</p>
<br><p id='212' data-category='paragraph' style='font-size:14px'>// The square of the two-norm of the cross product between two vectors.</p>
<br><p id='213' data-category='paragraph' style='font-size:14px'>template <class IterX , class IterY><br>cm2::biggest2_type<typenamestd::iterator_traits< IterX>::value_type, typenamestd::iterator_<br>traits<IterY>::value_type>::type><br>cross_sqr_two_norm3 (IterX x, IterY y);</p>
<br><p id='214' data-category='paragraph' style='font-size:14px'>// The two-norm of the cross product between two vectors.</p>
<br><p id='215' data-category='paragraph' style='font-size:14px'>template <class IterX , class IterY><br>cm2::biggest2_type<typenamestd::iterator_traits<IterX>::value_type, typenamestd::iterator_<br>traits<IterY>::value_type>::type><br>cross_two_norm3 (IterX x, IterY y);</p>
<br><p id='216' data-category='paragraph' style='font-size:14px'>// The square of the two-norm of the cross product between two vectors.</p>
<br><p id='217' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type><br>cross_sqr_two_norm (const VecX &x, const VecY &y);</p>
<br><p id='218' data-category='paragraph' style='font-size:14px'>// The two-norm of the cross product between two vectors.</p>
<br><p id='219' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>cm2::biggest2_type<typename VecX::value_type, typename VecY::value_type>::type><br>cross_two_norm (const VecX &x, const VecY &y);</p>
<br><p id='220' data-category='paragraph' style='font-size:14px'>// The mixed product of two vectors.</p>
<br><p id='221' data-category='paragraph' style='font-size:14px'>template <class IterX, class IterY , class IterZ><br>cm2::biggest3_type<typename std::iterator_traits<IterX>::value_type, typename std::iterator_<br>traits<IterY>::value_type, typename std::iterator_traits<IterZ>::value_type>::type><br>mixed_product (IterX x, IterY y, IterZ z);</p>
<br><p id='222' data-category='paragraph' style='font-size:14px'>// Tests the equality between two vectors.</p>
<p id='223' data-category='paragraph' style='font-size:14px'>// Tests the collinearity between two vectors.</p>
<br><p id='224' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>bool equal (const VecX &X, const VecY &Y);</p>
<table id='225' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 16</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 17</div>
<p id='226' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>bool are_collinear (const VecX &x, const VecY &y, double tol = CM2_EPSILON);</p>
<br><p id='227' data-category='paragraph' style='font-size:14px'>// Tests the orthogonality between two vectors.</p>
<br><p id='228' data-category='paragraph' style='font-size:14px'>template <class VecX, class VecY><br>bool are_orthogonal (const VecX &x, const VecY &y, double tol = CM2_EPSILON);</p>
<footer id='229' style='font-size:14px'>Table 3 – The cm2::vecvec template math library.</footer>
<table id='230' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>17</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 18</div>
<h1 id='231' style='font-size:20px'>Matrix - Scalar functions (cm2::matscal)</h1>
<p id='232' data-category='paragraph' style='font-size:14px'>// Appends a scalar to a 1-row matrix.</p>
<br><p id='233' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>bool push_back (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='234' data-category='paragraph' style='font-size:14px'>// The determinant of a 1x1, 2x2 or 3x3 matrix.</p>
<br><p id='235' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type det (const Matrix &A);</p>
<br><p id='236' data-category='paragraph' style='font-size:14px'>// A cofactor of a 2x2 or 3x3 matrix.</p>
<br><p id='237' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type cofactor (size_t i, size_t j, const Matrix &A);</p>
<br><p id='238' data-category='paragraph' style='font-size:14px'>// Sets the diagonal of a matrix to a scalar value.</p>
<br><p id='239' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void copy_diag (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='240' data-category='paragraph' style='font-size:14px'>// Adds a scalar to the diagonal of a matrix.</p>
<br><p id='241' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void add_diag (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='242' data-category='paragraph' style='font-size:14px'>// Multiplies the diagonal of a matrix by a scalar value.<br>template <class Matrix><br>void mult_diag (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='243' data-category='paragraph' style='font-size:14px'>// Divides the diagonal of a matrix by a scalar value.<br>template <class Matrix><br>void div_diag (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='244' data-category='paragraph' style='font-size:14px'>// The trace of a matrix.</p>
<br><p id='245' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type trace (const Matrix &A);</p>
<br><p id='246' data-category='paragraph' style='font-size:14px'>// Sets a row of a matrix to a scalar value.<br>template <class Matrix><br>void copy_row (typename Matrix::value_type v, Matrix &A, size_t i);</p>
<br><p id='247' data-category='paragraph' style='font-size:14px'>// Adds a scalar value to a row of a matrix.</p>
<br><p id='248' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void add_row (typename Matrix::value_type v, Matrix &A, size_t i);</p>
<br><p id='249' data-category='paragraph' style='font-size:14px'>// Multiplies a row of a matrix by a scalar value.</p>
<br><p id='250' data-category='paragraph' style='font-size:14px'>template <class Matrix></p>
<br><p id='251' data-category='paragraph' style='font-size:14px'>void mult_row (typename Matrix::value_type v, Matrix &A, size_t i);</p>
<br><p id='252' data-category='paragraph' style='font-size:14px'>// Divides a row of a matrix by a scalar value.<br>template <class Matrix><br>void div_row (typename Matrix::value_type v, Matrix &A, size_t i);</p>
<br><p id='253' data-category='paragraph' style='font-size:14px'>// Negates a matrix.<br>template <class Matrix><br>void negate (Matrix &A);</p>
<br><p id='254' data-category='paragraph' style='font-size:14px'>// Copies a scalar to a matrix.<br>template <class Matrix><br>void copy (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='255' data-category='paragraph' style='font-size:14px'>// Adds a scalar to a matrix.</p>
<br><p id='256' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void add (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='257' data-category='paragraph' style='font-size:14px'>// Subtract a scalar to a matrix.</p>
<br><p id='258' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void subtract (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='259' data-category='paragraph' style='font-size:14px'>// Multiplies a matrix by a scalar.</p>
<br><p id='260' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void mult (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='261' data-category='paragraph' style='font-size:14px'>// Divides a matrix by a scalar.</p>
<br><p id='262' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>void div (typename Matrix::value_type v, Matrix &A);</p>
<br><p id='263' data-category='paragraph' style='font-size:14px'>// The one-norm.</p>
<br><p id='264' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type one_norm (const Matrix &A);</p>
<br><p id='265' data-category='paragraph' style='font-size:14px'>// The square of two-norm.<br>template <class Matrix><br>typename Matrix::value_type sqr_two_norm (const Matrix &A);</p>
<table id='266' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 18</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 19</div>
<p id='267' data-category='paragraph' style='font-size:14px'>// The two-norm (usual Euclidean norm).</p>
<br><p id='268' data-category='paragraph' style='font-size:14px'>template <class Matrix></p>
<br><p id='269' data-category='paragraph' style='font-size:14px'>typename Matrix::value_type two_norm (const Matrix &A);</p>
<br><p id='270' data-category='paragraph' style='font-size:14px'>// Normalizes a matrix (divides by its two norm).<br>template <class Matrix><br>typename Matrix::value_type normalize (Matrix &A);</p>
<br><p id='271' data-category='paragraph' style='font-size:14px'>// The max-norm (infinite norm).</p>
<br><p id='272' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type max_norm (const Matrix &A);</p>
<br><p id='273' data-category='paragraph' style='font-size:14px'>// The maximum value.</p>
<br><p id='274' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>Matrix::value_type max_value (const Matrix &A);</p>
<br><p id='275' data-category='paragraph' style='font-size:14px'>// The minimum value.</p>
<br><p id='276' data-category='paragraph' style='font-size:14px'>template <class Matrix><br>typename Matrix::value_type min_value (const Matrix &A);</p>
<br><p id='277' data-category='paragraph' style='font-size:14px'>// Increases a range by the range of a matrix.</p>
<br><p id='278' data-category='paragraph' style='font-size:14px'>template <class Matrix , class Range><br>void inc_range (const Matrix &A, Range &R);</p>
<br><p id='279' data-category='paragraph' style='font-size:14px'>// The range of a matrix (first = min, second = max).<br>template <class Matrix><br>std::pair<typename Matrix::value_type, typename Matrix::value_type> range (const Matrix &A);</p>
<br><p id='280' data-category='paragraph' style='font-size:14px'>// The number of elements in a vector that match a predicate.<br>template <class Matrix , class Predicate><br>size_t count_if (const Matrix &A, Predicate pred);</p>
<br><p id='281' data-category='paragraph' style='font-size:14px'>// Tests all elements in a matrix against a scalar.<br>template <class Matrix><br>bool equal (const Matrix &A, typename Matrix::value_type v);</p>
<br><p id='282' data-category='paragraph' style='font-size:14px'>// Has the matrix only normal values (float and double only).<br>template <class Matrix><br>bool isfinite (const Matrix &A);</p>
<br><p id='283' data-category='paragraph' style='font-size:14px'>// The pseudo determinant of a matrix A of size MxN.<br>template <class Matrix><br>typename Matrix::value_type pseudo_det (const Matrix &A);</p>
<br><p id='284' data-category='paragraph' style='font-size:14px'>// Symmetrizes a matrix by adding its transpose matrix.<br>template <class MatA ><br>void symmetrize (MatA &A);</p>
<footer id='285' style='font-size:14px'>Table 4 – The cm2::matscal template math library.</footer>
<table id='286' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>19</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 20</div>
<h1 id='287' style='font-size:20px'>Matrix - Vector functions (cm2::matvec)</h1>
<p id='288' data-category='paragraph' style='font-size:14px'>// Inserts a new column inside a matrix.<br>template <class Vec, class Mat><br>void insert (const Vec& V, size_t j, Mat& A);</p>
<br><p id='289' data-category='paragraph' style='font-size:14px'>// Removes a column from a matrix.</p>
<br><p id='290' data-category='paragraph' style='font-size:14px'>template <class Mat><br>void remove (size_t j, Mat& A);</p>
<br><p id='291' data-category='paragraph' style='font-size:14px'>// Appends a column to a matrix.<br>template <class Matrix, class Vector><br>bool push_back (const Vector &V, Matrix &A);</p>
<br><p id='292' data-category='paragraph' style='font-size:14px'>// Copies a vector to the diagonal of a matrix.<br>template <class Matrix, class Vec><br>void set_diag (const Vec &V, Matrix &A);</p>
<br><p id='293' data-category='paragraph' style='font-size:14px'>// Copies the diagonal of a matrix into a vector.<br>template <class Matrix, class Vec><br>void get_diag (const Matrix &A, Vec &V);</p>
<br><p id='294' data-category='paragraph' style='font-size:14px'>// Adds a vector to the diagonal of a matrix.<br>template <class Matrix, class Vec><br>void add_diag (const Vec &V, Matrix &A);</p>
<br><p id='295' data-category='paragraph' style='font-size:14px'>// Subtracts a vector to the diagonal of a matrix.<br>template <class Matrix, class Vec><br>void subtract_diag (const Vec &V, Matrix &A);</p>
<br><p id='296' data-category='paragraph' style='font-size:14px'>// Multiplies the diagonal of a matrix by a vector (element by element).<br>template <class Matrix, class Vec><br>void mult_diag (const Vec &V, Matrix &A);</p>
<br><p id='297' data-category='paragraph' style='font-size:14px'>// Divides the diagonal of a matrix by a vector (element by element).<br>template <class Matrix, class Vec><br>void div_diag (const Vec &V, Matrix &A);</p>
<br><p id='298' data-category='paragraph' style='font-size:14px'>// Copies a row of a matrix into a vector.<br>template <class Matrix, class Vector><br>void get_row (const Matrix &A, size_t i, Vector &V);</p>
<br><p id='299' data-category='paragraph' style='font-size:14px'>// Copies a vector into a row of a matrix.<br>template <class Matrix, class Vector><br>void set_row (const Vector &V, Matrix &A, size_t i);</p>
<br><p id='300' data-category='paragraph' style='font-size:14px'>// Adds a vector to a row of a matrix.<br>template <class Matrix, class Vector><br>void add_row (const Vector &V, Matrix &A, size_t i);</p>
<br><p id='301' data-category='paragraph' style='font-size:14px'>// Adds a row of a matrix to a vector.<br>template <class Matrix, class Vector><br>void add_row (const Matrix &A, size_t i, Vector &V);</p>
<br><p id='302' data-category='paragraph' style='font-size:14px'>// AXPY between a row of a matrix and a vector.<br>template <class T, class Matrix, class Vector><br>void axpy_row (T a, const Vector &V, Matrix &A, size_t i);</p>
<br><p id='303' data-category='paragraph' style='font-size:14px'>// AXPY between a row of a matrix and a vector.<br>template <class T, class Matrix, class Vector><br>void axpy_row (T a, const Matrix &A, size_t i, Vector &V);</p>
<br><p id='304' data-category='paragraph' style='font-size:14px'>// Multiplies a matrix by a vector, with scaling.<br>template <class T, class Matrix, class VecX , class VecY><br>void mult (T a, const Matrix &A, const VecX &x, VecY &y, int nthreads=1);</p>
<br><p id='305' data-category='paragraph' style='font-size:14px'>// Multiplies a matrix by a vector.</p>
<br><p id='306' data-category='paragraph' style='font-size:14px'>template <class Matrix, class VecX , class VecY><br>void mult (const Matrix &A, const VecX &x, VecY &y, int nthreads=1);</p>
<br><p id='307' data-category='paragraph' style='font-size:14px'>// Multiplies a transposed matrix by a vector, with scaling.<br>template <class T, class Matrix, class VecX , class VecY><br>void transpose_mult (T a, const Matrix &A, const VecX &x, VecY &y, int nthreads=1);</p>
<br><p id='308' data-category='paragraph' style='font-size:14px'>// Multiplies a transposed matrix by a vector.</p>
<br><p id='309' data-category='paragraph' style='font-size:14px'>template <class Matrix, class VecX , class VecY><br>void transpose_mult (const Matrix &A, const VecX &x, VecY &y, int nthreads=1)</p>
<br><p id='310' data-category='paragraph' style='font-size:14px'>// transpose(V) % A % V</p>
<br><p id='311' data-category='paragraph' style='font-size:14px'>template <class Matrix, class Vec><br>cm2::biggest2_type<typenameMatrix::value_type, typenameVec::value_type>::type><br>Vt_A_V (const Matrix &A, const Vec &V, int nthreads=1);</p>
<table id='312' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 20</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 21</div>
<p id='313' data-category='paragraph' style='font-size:14px'>// Rank-1 update with one vector.<br>template <class T, class Vec, class Matrix><br>void rank1 (T a, const Vec &x, Matrix &A);</p>
<br><p id='314' data-category='paragraph' style='font-size:14px'>// Rank-1 update with one vector.<br>template <class Vec, class Matrix><br>void rank1 (const Vec &x, Matrix &A);</p>
<br><p id='315' data-category='paragraph' style='font-size:14px'>// Rank-2 update between two vectors.</p>
<br><p id='316' data-category='paragraph' style='font-size:14px'>template <class T, class VecX, class VecY, class Matrix><br>void rank2 (T a, const VecX &x, const VecY &y, Matrix &A);</p>
<br><p id='317' data-category='paragraph' style='font-size:14px'>// Symmetric rank-2 update between two vectors.<br>template <class T, class VecX, class VecY, class Matrix><br>void rank2sym (T a, const VecX &x, const VecY &y, Matrix &A);</p>
<br><p id='318' data-category='paragraph' style='font-size:14px'>// Cross products between all columns of a matrix and a vector.<br>template <class Vec, class Matrix><br>void cross (const Matrix &A, const Vec &x, Matrix &B);</p>
<br><p id='319' data-category='paragraph' style='font-size:14px'>// Cross products between a vector and all columns of a matrix.<br>template <class Vec, class Matrix><br>void cross (const Vec &x, const Matrix &A, Matrix &B);</p>
<br><p id='320' data-category='paragraph' style='font-size:14px'>// Skew matrix update (hat operator).<br>template <class Vec, class Matrix><br>void skew (const Vec &x, Matrix &A);</p>
<br><p id='321' data-category='paragraph' style='font-size:14px'>// Skew matrix update, with scaling (hat operator).<br>template <class T, class Vec, class Matrix><br>void skew (T a, const Vec &x, Matrix &A);</p>
<br><p id='322' data-category='paragraph' style='font-size:14px'>// Square skew matrix update, with scaling (square hat operator).<br>template <class T, class Vec, class Matrix><br>void square_skew (T a, const Vec &V, Matrix &A);</p>
<br><p id='323' data-category='paragraph' style='font-size:14px'>// Square skew matrix update(square hat operator).</p>
<br><p id='324' data-category='paragraph' style='font-size:14px'>template <class Vec, class Matrix><br>void square_skew (const Vec &V, Matrix &A);</p>
<footer id='325' style='font-size:14px'>Table 5 – The cm2::matvec template math library.</footer>
<table id='326' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview 21</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 22</div>
<h1 id='327' style='font-size:20px'>Matrix - Matrix functions (cm2::matmat)</h1>
<p id='328' data-category='paragraph' style='font-size:14px'>// Inserts some new columns at specific positions in a matrix.<br>template <class Mat1, class VecI, class Mat><br>void insert (const Mat1& M1, const VecI& indices, Mat& M);</p>
<br><p id='329' data-category='paragraph' style='font-size:14px'>// Removes some columns from a matrix.</p>
<br><p id='330' data-category='paragraph' style='font-size:14px'>template <class VecI, class Mat><br>void remove (const VecI& indices, Mat& A);</p>
<br><p id='331' data-category='paragraph' style='font-size:14px'>// Appends a matrix to another one.</p>
<br><p id='332' data-category='paragraph' style='font-size:14px'>template <class Mat1, class Mat2><br>bool push_back (const Mat1 &M1, Mat2 &M2);</p>
<p id='333' data-category='paragraph' style='font-size:14px'>// Appends a batch of matrices to another one.<br>template <class Mat1Iterator, class Mat2><br>bool push_back (Mat1Iterator M1_beg, Mat1Iterator M1_end, Mat2 &M2);</p>
<br><p id='334' data-category='paragraph' style='font-size:14px'>// Appends a specific batch of columns to a matrix.</p>
<br><p id='335' data-category='paragraph' style='font-size:14px'>template <class Mat1, class Mat2, class Vector><br>bool push_back (const Mat1 &M1, const Vector &M1_cols, Mat2 &M2);</p>
<br><p id='336' data-category='paragraph' style='font-size:14px'>// Appends a specific column of a matrix to another a matrix.<br>template <class Mat1, class Mat2><br>bool push_back (const Mat1 &M1, size_t j1, Mat2 &M2);</p>
<br><p id='337' data-category='paragraph' style='font-size:14px'>// Tests the equality between two matrices.<br>template <class Mat1, class Mat2><br>bool equal (const Mat1 &M1, const Mat2 &M2);</p>
<br><p id='338' data-category='paragraph' style='font-size:14px'>// Copies between the diagonal of two matrices, with shift.<br>template <class T, class MatA, class MatB><br>void copy_diag (T a, const MatA &A, MatB &B, size_t shift=0);</p>
<br><p id='339' data-category='paragraph' style='font-size:14px'>// AXPY between the diagonal of two matrices.<br>template <class T, class MatA, class MatB><br>void axpy_diag (T a, const MatA &A, MatB &B, size_t shift=0);</p>
<br><p id='340' data-category='paragraph' style='font-size:14px'>// Copies a row of a matrix to a row of another matrix.<br>template <class MatA, class MatB><br>void copy_row (const MatA &A, size_t ia, MatB &B, size_t ib);</p>
<br><p id='341' data-category='paragraph' style='font-size:14px'>// Adds a row of a matrix to a row of another matrix.<br>template <class MatA, class MatB><br>void add_row (const MatA &A, size_t ia, MatB &B, size_t ib);</p>
<br><p id='342' data-category='paragraph' style='font-size:14px'>// AXPY a row of a matrix to a row of another matrix.<br>template <class MatA, class MatB, class T><br>void axpy_row (T a, const MatA &A, size_t ia, MatB &B, size_t ib);</p>
<br><p id='343' data-category='paragraph' style='font-size:14px'>// AXPY between two matrices.<br>template <class MatA, class MatB, class T><br>void axpy (T a, const MatA &A, MatB &B);</p>
<br><p id='344' data-category='paragraph' style='font-size:14px'>// Adds a matrix to another matrix.<br>template <class MatA, class MatB><br>void add (const MatA &A, MatB &B);</p>
<br><p id='345' data-category='paragraph' style='font-size:14px'>// Subtracts a matrix to another matrix.<br>template <class MatA, class MatB><br>void subtract (const MatA &A, MatB &B);</p>
<br><p id='346' data-category='paragraph' style='font-size:14px'>// Copies with scaling a matrix to another matrix.<br>template <class MatA, class MatB, class T><br>void copy_scale (T a, const MatA &A, MatB &B);</p>
<br><p id='347' data-category='paragraph' style='font-size:14px'>// Copies a matrix to another matrix.</p>
<br><p id='348' data-category='paragraph' style='font-size:14px'>template <class MatA, class MatB><br>void copy (const MatA &A, MatB &B);</p>
<br><p id='349' data-category='paragraph' style='font-size:14px'>// Adds the transpose of a matrix into another matrix.<br>template <class MatA, class MatB><br>void transpose (const MatA &A, MatB &B);</p>
<br><p id='350' data-category='paragraph' style='font-size:14px'>// Matrix-matrix multiplication, with scaling.</p>
<br><p id='351' data-category='paragraph' style='font-size:14px'>template <class T, class MatA, class MatB, class MatC><br>void mult (T a, const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int nthreads=1);</p>
<br><h1 id='352' style='font-size:14px'>// Matrix-matrix multiplication.</h1>
<br><p id='353' data-category='paragraph' style='font-size:14px'>template <class MatA, class MatB, class MatC><br>void mult (const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int nthreads=1)</p>
<table id='354' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>22</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 23</div>
<p id='355' data-category='paragraph' style='font-size:14px'>// Matrix-matrix transpose multiplication, with scaling.</p>
<br><p id='356' data-category='paragraph' style='font-size:14px'>template <class T, class MatA, class MatB, class MatC><br>void transpose_mult (T a, const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int<br>nthreads=1);</p>
<br><p id='357' data-category='paragraph' style='font-size:14px'>// Matrix-matrix transpose multiplication.<br>template <class MatA, class MatB, class MatC><br>void transpose_mult (const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int<br>nthreads=1);</p>
<p id='358' data-category='paragraph' style='font-size:14px'>// Diagonal mult (with scaling).<br>template <class T, class DiagD, class MatB, class MatC><br>void diag_mult (T a, const DiagD &D, MatB &B, MatC &C, int nthreads=1);</p>
<br><p id='359' data-category='paragraph' style='font-size:14px'>// Diagonal mult (with scaling).</p>
<br><p id='360' data-category='paragraph' style='font-size:14px'>template <class DiagD, class MatB><br>void diag_mult (const DiagD &D, MatB &B, int nthreads=1);</p>
<br><p id='361' data-category='paragraph' style='font-size:14px'>// transpose(B) % A % B</p>
<br><p id='362' data-category='paragraph' style='font-size:14px'>template <class T, class MatA, class MatB, class MatC><br>void Bt_A_B (T a, const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int nthreads=1);</p>
<br><p id='363' data-category='paragraph' style='font-size:14px'>// B % A % transpose(B)</p>
<br><p id='364' data-category='paragraph' style='font-size:14px'>template <class T, class MatA, class MatB, class MatC><br>void B_A_Bt (T a, const MatA &A, const MatB &B, MatC &C, size_t cache_size=0, int nthreads=1);</p>
<br><p id='365' data-category='paragraph' style='font-size:14px'>// Generalized transposed inverse of a MxN matrix, with (M,N) = (2,2), (3,2) or (3,3).<br>template <class Matrix , class T><br>void transpose_inverse (const Matrix &A, Matrix &invT_A, T &det);</p>
<br><p id='366' data-category='paragraph' style='font-size:14px'>// Compute the lower-left Cholesky factorization of a small symmetric real matrix.<br>template <class Matrix , class Factor><br>bool Cholesky_factor (const Matrix &A, Factor &L);</p>
<footer id='367' style='font-size:14px'>Table 6 – The cm2::matmat template math library.</footer>
<table id='368' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Math1 - overview</td><td>23</td></tr></tbody></table>
</div>
<div class="page">
<div class="page-header">Page 24</div>
<p id='369' data-category='paragraph' style='font-size:14px'>https://www.computing-objects.com</p>
<br><p id='370' data-category='paragraph' style='font-size:14px'>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>
<br><p id='371' data-category='paragraph' style='font-size:14px'>Limited Liability Company with a capital of 100 000 €.<br>Registered at Versailles RCS under SIRET number 422 791 038 00033.<br>EU VAT registration FR59422791038.</p>
</div>

</body>
</html>
