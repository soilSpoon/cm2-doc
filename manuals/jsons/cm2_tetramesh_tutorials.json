{"api": "2.0", "content": {"html": "<h1 id='0' style='font-size:20px'>CM2 TetraMesh® Iso/Aniso</h1>\n<br><h1 id='1' style='font-size:16px'>Version 5.6</h1>\n<p id='2' data-category='paragraph' style='font-size:18px'>tutorials</p>\n<p id='3' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>\n<h1 id='4' style='font-size:20px'>Forewords</h1>\n<p id='5' data-category='paragraph' style='font-size:16px'>This manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:</p>\n<br><p id='6' data-category='list' style='font-size:16px'>• The isotropic mesher CM2 TetraMesh® Iso,<br>• The anisotropic mesher CM2 TetraMesh® Aniso.</p>\n<br><p id='7' data-category='paragraph' style='font-size:16px'>These two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and<br>the internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh.</p>\n<br><p id='8' data-category='paragraph' style='font-size:16px'>Based on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality<br>elements with smooth grading size according to the length of the boundary elements, to the user-specified<br>sizes or to the metric map supported by a background mesh.</p>\n<br><p id='9' data-category='paragraph' style='font-size:16px'>They can generate very big meshes – several millions of elements – with a limited amount of memory. The<br>speed is near independent of the number of the elements to be generated.</p>\n<br><p id='10' data-category='paragraph' style='font-size:16px'>Option switches can be used to adapt the meshers to the various needs of the user concerning mesh<br>refinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already<br>existing tetrahedral meshes.</p>\n<br><p id='11' data-category='paragraph' style='font-size:16px'>Many data concerning the mesh are available upon exit: histograms of the shape qualities and the size<br>qualities, matrix of the neighbors, number of sub-domains, meshed volume...</p>\n<br><p id='12' data-category='paragraph' style='font-size:16px'>Like many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the<br>settings the maximum number of threads the generator can use).<br>The generated meshes are reproducible (same mesh with same input data and same mesh with any number of<br>threads).</p>\n<p id='13' data-category='paragraph' style='font-size:16px'>Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners<br>should start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers.</p>\n<br><p id='14' data-category='paragraph' style='font-size:16px'>For a complete description of the data and settings structures used with these meshers please refer to the<br>CM2 TetraMesh Iso/Aniso - reference manual.</p>\n<p id='15' data-category='paragraph' style='font-size:16px'>The source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit<br>number IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and<br>IDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.</p>\n\n<table id='17' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>2</td></tr></tbody><br><caption id='16' style='font-size:16px'>The source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly<br>deposited since then.</caption></table>\n<h1 id='18' style='font-size:20px'>Table of contents</h1>\n<p id='19' data-category='index' style='font-size:16px'>Forewords .................................................................................................................................................. 2<br>1. Getting started ...................................................................................................................................... 5<br>Some declarations .................................................................................................................................................................... 6<br>Authorization of the library .................................................................................................................................................... 6<br>Boundary mesh ......................................................................................................................................................................... 7<br>Tetrahedral mesh ..................................................................................................................................................................... 7<br>2. Simple cube ......................................................................................................................................... 10<br>Some declarations .................................................................................................................................................................. 11<br>Boundary mesh ....................................................................................................................................................................... 11<br>Tetrahedral mesh ................................................................................................................................................................... 13<br>3. Cube with an internal hard line ........................................................................................................ 15<br>4. Cube with an internal hard node ..................................................................................................... 18<br>5. Internal cavity ..................................................................................................................................... 20<br>6. Quadratic elements & high-order nodes ........................................................................................ 23<br>7. Multiple meshes ................................................................................................................................. 25<br>8. Repairing the boundary mesh .......................................................................................................... 26<br>9. Background mesh .............................................................................................................................. 28<br>10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31<br>Mesh gallery ............................................................................................................................................ 39</p>\n<table id='20' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>3</td></tr></tbody></table>\n<p id='21' data-category='paragraph' style='font-size:20px'>This manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options<br>of the meshers CM2 TetraMesh® Iso/Aniso.</p>\n<br><p id='22' data-category='paragraph' style='font-size:20px'>Each example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the<br>classes and the functions of the library (API).</p>\n<p id='23' data-category='paragraph' style='font-size:20px'>The general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:<br>:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.<br>h file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to<br>avoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.</p>\n<br><p id='24' data-category='paragraph' style='font-size:20px'>File stdafx.h:</p>\n<p id='25' data-category='paragraph' style='font-size:14px'>// CM2 MESHTOOLS</p>\n<br><table id='26' style='font-size:14px'><thead></thead><tbody><tr><td>#include \"meshtools.h\" //</td><td>General purpose mesh routines.</td></tr><tr><td>#include \"meshtools2d.h\" //</td><td>To generate 1D meshes.</td></tr><tr><td>#include \"meshtools2d.h\" //</td><td>To generate 2D meshes.</td></tr><tr><td>#include \"tetramesh_iso.h\" //</td><td>CM2 TetraMesh Iso.</td></tr><tr><td>#include \"tetramesh_aniso.h\" //</td><td>CM2 TetraMesh Aniso (Section 10 only).</td></tr></tbody></table>\n<br><p id='27' data-category='paragraph' style='font-size:14px'>using namespace cm2;</p>\n<br><p id='28' data-category='paragraph' style='font-size:14px'>// Main cm2 namespace can now be omitted.</p>\n<p id='29' data-category='paragraph' style='font-size:20px'>Required libraries1:</p>\n<p id='30' data-category='list' style='font-size:20px'>• cm2math1<br>• cm2misc<br>• cm2meshtools<br>• cm2meshtools2d<br>• cm2meshtools2d<br>• cm2meshtools3d<br>• cm2tetramesh_iso<br>• cm2tetramesh_aniso (Section 10 only)</p>\n\n<table id='32' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>4</td></tr></tbody><caption id='31' style='font-size:14px'>1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.<br>On Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static<br>archive), .so or .dylib (dynamic lib).</caption></table>\n<h1 id='33' style='font-size:22px'>1. Getting started</h1>\n<br><p id='34' data-category='paragraph' style='font-size:18px'>The simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We<br>assume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is<br>quite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a<br>3xNT matrix2. For each matrix the format is:</p>\n<p id='35' data-category='paragraph' style='font-size:20px'>n X m [<br>d0,0 d0,1 d0,2 ... d0,m-1<br>d1,0 d1,1 d1,2 ... d1,m-1<br>...<br>dn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]</p>\n<p id='36' data-category='paragraph' style='font-size:18px'>For instance, a mesh with 4 nodes and 2 triangles could write3:</p>\n<p id='37' data-category='paragraph' style='font-size:18px'>3 X 4 [<br>0. 1. 1. 0.<br>0. 0. 1. 1.<br>0. 0. 0.5 0. ]</p>\n<br><p id='38' data-category='paragraph' style='font-size:18px'>3 X 2 [<br>0 1<br>1 2<br>3 3 ]</p>\n<p id='39' data-category='paragraph' style='font-size:18px'>The source code to generate the tetrahedral mesh writes:</p>\n<p id='40' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream><br>#include <fstream></p>\n<br><p id='41' data-category='paragraph' style='font-size:14px'>// Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }</p>\n<br><p id='42' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='43' data-category='paragraph' style='font-size:14px'>{</p>\n<br><p id='44' data-category='paragraph' style='font-size:14px'>std::ifstream istrm(\"part.dat\");<br>cm2::tetramesh_iso::mesher the_mesher;<br>cm2::tetramesh_iso::mesher::data_type data;</p>\n<br><p id='45' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='46' data-category='paragraph' style='font-size:14px'>// READ THE BOUNDARY TRIANGLE MESH.<br>cm2::matio::read(istrm, data.pos);<br>cm2::matio::read(istrm, data.connectB);</p>\n<br><p id='47' data-category='paragraph' style='font-size:14px'>// GENERATE THE 3D MESH.<br>the_mesher.run(data);</p>\n<br><p id='48' data-category='paragraph' style='font-size:14px'>// SOME OUTPUT INFO (OPTIONAL).<br>data.print_info(&display_hdl);</p>\n<br><p id='49' data-category='paragraph' style='font-size:14px'>// VISUALISATION (OPTIONAL).<br>cm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>\n<br><p id='50' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>\n<br><p id='51' data-category='paragraph' style='font-size:14px'>}</p>\n<p id='52' data-category='list' style='font-size:14px'>2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.<br>3 The format for each value is free.</p>\n<table id='53' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>5</td></tr></tbody></table>\n<figure id='54'><img style='font-size:16px' alt=\"Figure 1 – A simple mechanical part.\" data-coord=\"top-left:(302,105); bottom-right:(941,685)\" /></figure>\n<p id='55' data-category='paragraph' style='font-size:20px'>Let us explain this program line by line.</p>\n<br><h1 id='56' style='font-size:22px'>Some declarations</h1>\n<p id='57' data-category='paragraph' style='font-size:20px'>A standard input stream istrm is built with the data file name part.dat. We create then an instance of the<br>tet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the<br>nodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB<br>and final tet mesh in data.connectM).</p>\n<p id='58' data-category='paragraph' style='font-size:20px'>Matrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and<br>data.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This<br>integer refers to the column number in matrix data.pos where the coordinates of this node can be found5.</p>\n<h1 id='59' style='font-size:22px'>Authorization of the library</h1>\n<p id='60' data-category='paragraph' style='font-size:20px'>The tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two<br>strings must be provided for each library: the name of your company or organization that has acquired the<br>license and a secret code6. Note that both strings are case sensitive and the registration call must be made<br>each time the library is loaded into memory and before any run of the mesher.</p>\n<p id='61' data-category='paragraph' style='font-size:16px'>cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<p id='62' data-category='list' style='font-size:14px'>4 See manual CM2 Math1 - overview.<br>5 Recall that array indices are zero based (from 0 to N-1).<br>6 Contact license@computing-objects.com for any licensing inquiry.</p>\n<table id='63' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>6</td></tr></tbody></table>\n<h1 id='64' style='font-size:22px'>Boundary mesh</h1>\n<p id='65' data-category='paragraph' style='font-size:20px'>The cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.<br>We use it to load the nodes’ coordinates and the triangle connectivity from the same file.</p>\n<p id='66' data-category='paragraph' style='font-size:16px'>cm2::matio::read(istrm, data.pos);<br>cm2::matio::read(istrm, data.connectB);</p>\n<h1 id='67' style='font-size:22px'>Tetrahedral mesh</h1>\n<p id='68' data-category='paragraph' style='font-size:16px'>the_mesher.run(data);</p>\n<p id='69' data-category='paragraph' style='font-size:20px'>Upon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the<br>tetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary<br>mesh are left untouched in the first columns.</p>\n<br><p id='70' data-category='paragraph' style='font-size:20px'>The connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of<br>the nodes for an element. connectM(i, j) is the ith local node of the jth element.</p>\n<br><h1 id='71' style='font-size:22px'>Output information</h1>\n<br><p id='72' data-category='paragraph' style='font-size:20px'>Printed information about the generated mesh and a MEDIT8 output file are obtained with:</p>\n<p id='73' data-category='paragraph' style='font-size:16px'>data.print_info(&display_hdl);<br>cm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>\n<p id='74' data-category='paragraph' style='font-size:20px'>Figure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of<br>2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces<br>and hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9.</p>\n<br><p id='75' data-category='paragraph' style='font-size:20px'>The first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the<br>second step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the<br>last step concerns geometrical and topological optimizations to improve the quality of the elements.</p>\n<br><p id='76' data-category='paragraph' style='font-size:20px'>The formula used to compute the shape quality of a tetrahedron is given by:</p>\n<br><table id='77' style='font-size:20px'><thead></thead><tbody><tr><td>V</td><td>V Volume of the tetrahedron.</td></tr><tr><td>Qs 6� 6 Lmax S</td><td>with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron.</td></tr></tbody></table>\n<p id='78' data-category='footnote' style='font-size:14px'>7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:<br>:transpose_read function exists to read a matrix and transpose it on the fly.<br>8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),<br>VTK and Wavefront OBJ.<br>9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-<br>threading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®<br>Aniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased<br>further by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster.</p>\n<table id='79' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>7</td></tr></tbody></table>\n<p id='80' data-category='paragraph' style='font-size:18px'>This quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet).</p>\n<br><p id='81' data-category='paragraph' style='font-size:18px'>On the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2).</p>\n<br><p id='82' data-category='paragraph' style='font-size:18px'>Note that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There<br>is an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator<br>cannot produce a mesh with a minimum quality better than 0.56 in this case.</p>\n<br><p id='83' data-category='paragraph' style='font-size:18px'>The size quality is also an important parameter to take into account. The size quality of an edge is a measure<br>based upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the<br>edge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always<br>positive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it<br>should be.</p>\n<p id='84' data-category='paragraph' style='font-size:18px'>The formula used to compute the length quality of an edge AB writes:</p>\n<br><p id='85' data-category='equation'>$$Q_{h}^{A B}=L_{A B}\\,\\frac{\\left|\\mathrm{h}_{A}\\right|}{h_{B}}$$</p>\n<br><p id='86' data-category='paragraph' style='font-size:18px'>with:</p>\n<br><p id='87' data-category='list' style='font-size:16px'>LAB Actual length of edge AB.<br>hA Target size at node A (expected edge length at A).<br>hB Target size at node B (expected edge length at B).</p>\n<p id='88' data-category='paragraph' style='font-size:18px'>Let’s introduce also at this point the h-shock measure of an edge:</p>\n<p id='89' data-category='equation'>$$h s^{4B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{b}^{4B}}}-1$$</p>\n<p id='90' data-category='paragraph' style='font-size:18px'>These two measure are dimensionless and positive.</p>\n<p id='91' data-category='paragraph' style='font-size:18px'>LAB<br>When hA = hB the h-shock is null and the length writes hQ AB � .<br>hA<br>When ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB.</p>\n<br><p id='92' data-category='paragraph' style='font-size:18px'>To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size<br>quality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure<br>smooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this<br>makes the job of the optimizer difficult and heuristics must be used.</p>\n<br><p id='93' data-category='paragraph' style='font-size:18px'>The mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.<br>settings.compute_Qh_flag10 is set to true11.</p>\n<br><p id='94' data-category='paragraph' style='font-size:18px'>On this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance<br>(Figure 3).</p>\n<p id='95' data-category='paragraph' style='font-size:14px'>10 See reference manual for details on the settings of the meshers.</p>\n<p id='96' data-category='paragraph' style='font-size:14px'>11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities.</p>\n<table id='97' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>8</td></tr></tbody></table>\n<figure id='98'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74\" data-coord=\"top-left:(112,122); bottom-right:(1142,843)\" /><figcaption id='99' style='font-size:16px'>Figure 2 – Output info for the “mechanical part” example.</figcaption></figure>\n\n<figure id='100'><img style='font-size:14px' alt=\"************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(107,948); bottom-right:(1141,1463)\" /><figcaption id='101' style='font-size:16px'>Figure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example.</figcaption></figure>\n\n<table id='102' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>9</td></tr></tbody></table>\n<h1 id='103' style='font-size:20px'>2. Simple cube</h1>\n<br><p id='104' data-category='paragraph' style='font-size:18px'>This second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.<br>This will also help introduce some options of CM2 TetraMesh Iso in following examples.</p>\n<br><p id='105' data-category='paragraph' style='font-size:18px'>The following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):</p>\n<p id='106' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream></p>\n<br><p id='107' data-category='paragraph' style='font-size:14px'>// Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }</p>\n<br><p id='108' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='109' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='110' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6);</td><td>// The discretization along each edge.</td></tr><tr><td>const double</td><td>L(4.);</td><td>// The sides length.</td></tr><tr><td>DoubleMat</td><td>pos;</td><td></td></tr><tr><td>UIntMat</td><td>connectE,</td><td>connectB, connectB1, connectB2;</td></tr><tr><td>UIntVec</td><td>indices;</td><td></td></tr></tbody></table>\n<br><p id='111' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='112' data-category='paragraph' style='font-size:14px'>// BOUNDARY TRIANGLE MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);</p>\n<br><p id='113' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='114' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='115' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>\n<br><p id='116' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>\n<p id='117' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>\n<br><p id='118' data-category='paragraph' style='font-size:14px'>// VISUALISATION (OPTIONAL).<br>data.print_info(&display_hdl);<br>meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>\n<br><p id='119' data-category='paragraph' style='font-size:14px'>return 0;<br>} // main</p>\n<table id='120' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>10</td></tr></tbody></table>\n<figure id='121'><img style='font-size:14px' alt=\"Figure 4 – Simple cube.\" data-coord=\"top-left:(335,112); bottom-right:(904,750)\" /></figure>\n<p id='122' data-category='paragraph' style='font-size:18px'>Let us again explain this program line by line.</p>\n<br><p id='123' data-category='paragraph' style='font-size:18px'>Most of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only<br>three lines in the program.</p>\n<h1 id='124' style='font-size:20px'>Some declarations</h1>\n<p id='125' data-category='paragraph' style='font-size:18px'>Matrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the<br>final mesh (many of them are in both).</p>\n<br><p id='126' data-category='paragraph' style='font-size:18px'>Matrix connectB stores the connectivity matrix of the boundary triangle mesh.</p>\n<br><p id='127' data-category='paragraph' style='font-size:18px'>Matrices connectB1, connectB2 and connectE are temporaries as well as vector indices.</p>\n<h1 id='128' style='font-size:20px'>Boundary mesh</h1>\n<p id='129' data-category='paragraph' style='font-size:18px'>In this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to<br>generate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher<br>needs this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix<br>connectB of connectivity of the boundary triangles.</p>\n<br><p id='130' data-category='paragraph' style='font-size:18px'>We choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of<br>the cube.</p>\n<br><p id='131' data-category='paragraph' style='font-size:18px'>The first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):</p>\n<p id='132' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);</p>\n<table id='133' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>11</td></tr></tbody></table>\n<p id='134' data-category='paragraph' style='font-size:20px'>This generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos<br>matrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This<br>vector contains upon exit of this function (N = 6):</p>\n<p id='135' data-category='paragraph' style='font-size:20px'>[0 1 2 3 4 5 6]</p>\n<p id='136' data-category='paragraph' style='font-size:20px'>And the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).<br>The vector of indices is used to create the connectivity matrix of the first edge mesh:</p>\n<p id='137' data-category='paragraph' style='font-size:16px'>meshtools2d::indices_to_connectE2(indices, connectE);</p>\n<p id='138' data-category='paragraph' style='font-size:20px'>connectE is now a 2x6 matrix:</p>\n<p id='139' data-category='paragraph' style='font-size:20px'>2x6 [0 1 2 3 4 5<br>1 2 3 4 5 6]</p>\n<p id='140' data-category='paragraph' style='font-size:20px'>This line mesh is then extruded into a mesh of triangles along vector (0, L, 0):</p>\n<p id='141' data-category='paragraph' style='font-size:16px'>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);</p>\n<p id='142' data-category='paragraph' style='font-size:20px'>The 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”<br>pattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to<br>matrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix<br>connectB as new columns of indices of nodes.</p>\n<p id='143' data-category='paragraph' style='font-size:20px'>We now have to copy and rotate this mesh:</p>\n<p id='144' data-category='paragraph' style='font-size:16px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>\n<p id='145' data-category='paragraph' style='font-size:20px'>After the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix<br>pos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),<br>Y}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB.</p>\n<p id='146' data-category='paragraph' style='font-size:14px'>12 Several variants of this function are available in the meshtools2d library and are described in the API.</p>\n\n<table id='148' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>12</td></tr></tbody><caption id='147' data-category='footnote' style='font-size:14px'>13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and<br>copies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged.</caption></table>\n<p id='149' data-category='paragraph' style='font-size:20px'>The two faces together are then copied and rotated twice in order to generate the other four missing faces of<br>the cube:</p>\n<p id='150' data-category='paragraph' style='font-size:16px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>\n<p id='151' data-category='paragraph' style='font-size:20px'>At this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.<br>However, some points are coincident and need to be merged together:</p>\n<p id='152' data-category='paragraph' style='font-size:16px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>\n<p id='153' data-category='paragraph' style='font-size:20px'>This function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the<br>index of the first node encountered replaces all the others subsequent coincident nodes14.</p>\n<h1 id='154' style='font-size:22px'>Tetrahedral mesh</h1>\n<p id='155' data-category='paragraph' style='font-size:20px'>Now we have generated the boundary mesh, we can call the 3-D mesher on it:</p>\n<p id='156' data-category='paragraph' style='font-size:16px'>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>\n<p id='157' data-category='paragraph' style='font-size:20px'>The difference with the previous example is that matrices pos and connect are built first and then passed to<br>the data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.<br>There is no significant difference between the two approaches. We can either modify directly data.pos and<br>data.connectB or build some separated matrices pos and connect and then pass them to the data<br>constructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -<br>overview.</p>\n<br><p id='158' data-category='paragraph' style='font-size:20px'>Upon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the<br>tetrahedral mesher on top of the initial surface points.</p>\n<p id='159' data-category='paragraph' style='font-size:14px'>14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify.</p>\n\n<table id='161' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>13</td></tr></tbody><caption id='160' style='font-size:14px'>15 But the pos matrix still has 294 columns.</caption></table>\n<figure id='162'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58\" data-coord=\"top-left:(112,120); bottom-right:(1142,844)\" /><br><figcaption id='163' style='font-size:16px'>Figure 5 – Output info for the cube example.</figcaption></figure>\n\n<figure id='164'><img style='font-size:14px' alt=\"************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(106,921); bottom-right:(1143,1439)\" /><figcaption id='165' style='font-size:16px'>Figure 6 – Histogram of the size-qualities of all the edges in the cube example.</figcaption></figure>\n\n<table id='166' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>14</td></tr></tbody></table>\n<h1 id='167' style='font-size:20px'>3. Cube with an internal hard line</h1>\n<br><p id='168' data-category='paragraph' style='font-size:18px'>Starting from the previous example, we add a hard line inside the cube:</p>\n<p id='169' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>\n<br><p id='170' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='171' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='172' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6); // The discretization along each edge.</td></tr><tr><td>const double</td><td>L(4.); // The sides length.</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectE, connectB, connectB1, connectB2, connectM2;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr></tbody></table>\n<br><p id='173' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='174' data-category='paragraph' style='font-size:14px'>// BOUNDARY TRIANGLE MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);</p>\n<br><p id='175' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='176' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='177' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>\n<br><p id='178' data-category='paragraph' style='font-size:14px'>indices.clear(); connectE.clear();<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);</p>\n<br><p id='179' data-category='paragraph' style='font-size:14px'>// 3D MESH.</p>\n<br><p id='180' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>data.connectE = connectE;<br>the_mesher.run(data);</p>\n<p id='181' data-category='paragraph' style='font-size:14px'>// MESH VISUALIZATION.<br>meshtools::clip(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>\n<br><p id='182' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>\n<br><p id='183' data-category='paragraph' style='font-size:14px'>}</p>\n<table id='184' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>15</td></tr></tbody></table>\n<figure id='185'><img alt=\"\" data-coord=\"top-left:(320,114); bottom-right:(916,601)\" /><br><figcaption id='186' style='font-size:14px'>Figure 7 – Half cube with internal line (mesh cut).</figcaption></figure>\n\n<p id='187' data-category='paragraph' style='font-size:20px'>The mesh of the internal line is generated like the mesh of the first edge of the cube:</p>\n<p id='188' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);</p>\n<p id='189' data-category='paragraph' style='font-size:20px'>This mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh<br>is four times finer along this line than on the cube edges, in order to make the line more visible and also to get<br>a graded mesh size.</p>\n<br><p id='190' data-category='paragraph' style='font-size:20px'>To avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two<br>matching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary<br>mesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is<br>done concurrently with the merging of the nodes of the edges of the cube already discussed in the previous<br>section:</p>\n<p id='191' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);</p>\n<p id='192' data-category='paragraph' style='font-size:20px'>The new internal prescribed edges are given to the mesher with:</p>\n<figure id='193'><img style='font-size:14px' alt=\"data.connectE = connectE;\" data-coord=\"top-left:(106,1356); bottom-right:(1139,1437)\" /></figure>\n<table id='194' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>16</td></tr></tbody></table>\n<p id='195' data-category='paragraph' style='font-size:20px'>To visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets<br>with at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.<br>pos, or on the connectivity matrix of the full mesh data.connectM:</p>\n<p id='196' data-category='paragraph' style='font-size:14px'>meshtools::clip<br>(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>\n<p id='197' data-category='paragraph' style='font-size:20px'>To constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface<br>mesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard<br>faces into the matrix data.connectB for instance with a push-back (see next example).</p>\n<table id='198' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>17</td></tr></tbody></table>\n<h1 id='199' style='font-size:20px'>4. Cube with an internal hard node</h1>\n<p id='200' data-category='paragraph' style='font-size:18px'>There are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with<br>different or varying size on the boundary and interior surface or line, like in the previous example. The mesher<br>computes a size value on each hard node16, interpolates these values inside the domain and generates<br>elements accordingly.</p>\n<br><p id='201' data-category='paragraph' style='font-size:18px'>A second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all<br>the hard nodes. This is explained in this section.</p>\n<br><p id='202' data-category='paragraph' style='font-size:18px'>So far, we have seen only four fields of the data structure used by the mesher:</p>\n<br><p id='203' data-category='list' style='font-size:18px'>• The pos matrix for the coordinates of the points.<br>• The connectB matrix for the connectivity of the hard faces.<br>• The connectE matrix for the connectivity of the hard edges (seen in Example 2).<br>• The connectM matrix for the connectivity of the output 3-D mesh.</p>\n<br><p id='204' data-category='paragraph' style='font-size:18px'>In this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target<br>size for the elements near this node. This is done using two new fields: isolated_nodes and metrics:</p>\n<p id='205' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>\n<br><p id='206' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='207' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='208' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6);</td></tr><tr><td>const double</td><td>L(4.);</td></tr><tr><td>DoubleMat</td><td>pos(3, 1, L/2.);</td></tr><tr><td>UIntMat</td><td>connectB, connectB1, connectB2, connectE, connectM2;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr></tbody></table>\n<br><p id='209' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='210' data-category='paragraph' style='font-size:14px'>// BOUNDARY 2D MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,</p>\n<br><p id='211' data-category='paragraph' style='font-size:14px'>indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,<br>connectB);</p>\n<p id='212' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='213' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='214' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);<br>connectB.push_back(connectB2);<br>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>\n<br><p id='215' data-category='paragraph' style='font-size:14px'>// 3D MESH.</p>\n<br><p id='216' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>data.isolated_nodes.push_back(0);<br>data.metrics.resize(1, 0.05*L/N);<br>the_mesher.run(data);</p>\n<br><p id='217' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>\n<br><p id='218' data-category='paragraph' style='font-size:14px'>return 0;<br>} // main</p>\n<p id='219' data-category='paragraph' style='font-size:18px'>Initializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into<br>account by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:</p>\n<table id='220' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>18</td></tr></tbody></table>\n<h1 id='221' style='font-size:16px'>data.isolated_nodes.push_back(0);</h1>\n<p id='222' data-category='paragraph' style='font-size:20px'>The vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or<br>negative or not present), the automatically computed value will be used instead18. In this example the vector is<br>resized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:</p>\n<p id='223' data-category='paragraph' style='font-size:16px'>data.metrics.resize(1, 0.05*L/N);</p>\n<p id='224' data-category='paragraph' style='font-size:20px'>For all the other nodes, we let the mesher compute suitable values.</p>\n<figure id='225'><img alt=\"\" data-coord=\"top-left:(317,543); bottom-right:(920,1095)\" /><br><figcaption id='226' style='font-size:16px'>Figure 8 – Half cube with internal hard node (mesh cut).</figcaption></figure>\n\n<p id='227' data-category='list' style='font-size:14px'>16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.<br>17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));<br>18 For an isolated node, the computed size is based on the values of the nearest nodes.</p>\n<table id='228' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>19</td></tr></tbody></table>\n<h1 id='229' style='font-size:22px'>5. Internal cavity</h1>\n<br><p id='230' data-category='paragraph' style='font-size:20px'>A cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This<br>implies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we<br>have the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1.</p>\n<p id='231' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"<br>#include <fstream></p>\n<br><p id='232' data-category='paragraph' style='font-size:16px'>int main()</p>\n<br><p id='233' data-category='paragraph' style='font-size:16px'>{</p>\n<br><table id='234' style='font-size:16px'><thead></thead><tbody><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr><tr><td>std::ifstream</td><td>istrm(\"sphere.dat\");</td></tr></tbody></table>\n<br><p id='235' data-category='paragraph' style='font-size:16px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='236' data-category='paragraph' style='font-size:16px'>// READ THE BOUNDARY TRIANGLE MESH.<br>matio::read(istrm, pos);<br>matio::read(istrm, connectB);</p>\n<br><p id='237' data-category='paragraph' style='font-size:16px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>\n<br><p id='238' data-category='paragraph' style='font-size:16px'>// MESH VISUALISATION.<br>meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>\n<br><p id='239' data-category='paragraph' style='font-size:16px'>return 0;<br>// main</p>\n<br><p id='240' data-category='paragraph' style='font-size:16px'>}</p>\n<figure id='241'><img style='font-size:16px' alt=\"Figure 9 – Full sphere.\" data-coord=\"top-left:(348,811); bottom-right:(897,1395)\" /></figure>\n<p id='242' data-category='paragraph' style='font-size:20px'>The surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing<br>the orientation of the triangles:</p>\n\n<table id='244' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>20</td></tr></tbody><caption id='243' style='font-size:14px'>19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary.</caption></table>\n<p id='245' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <fstream></p>\n<br><p id='246' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='247' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='248' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectB, connectB2, connectM2;</td></tr><tr><td>std::ifstream</td><td>istrm(\"sphere.dat\");</td></tr></tbody></table>\n<br><p id='249' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='250' data-category='paragraph' style='font-size:14px'>// OUTER BOUNDARY TRIANGLE MESH.<br>matio::read(istrm, pos);<br>matio::read(istrm, connectB);</p>\n<br><p id='251' data-category='paragraph' style='font-size:14px'>// INNER BOUNDARY.<br>meshtools::copy_mesh(pos, connectB2, connectB);<br>meshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);<br>meshtools2d::flip_T3(connectB2); // Reverse the orientation.<br>connectB.push_back(connectB2);</p>\n<br><p id='252' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>\n<br><p id='253' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>\n<br><p id='254' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>\n<br><p id='255' data-category='paragraph' style='font-size:14px'>}</p>\n<figure id='256'><img alt=\"\" data-coord=\"top-left:(320,764); bottom-right:(925,1245)\" /><br><figcaption id='257' style='font-size:14px'>Figure 10 – Hollow sphere (mesh cut).</figcaption></figure>\n\n<p id='258' data-category='paragraph' style='font-size:20px'>Note that the matrix connectB contains both the external and the internal faces.<br>Nested shells can be generated simply by changing the orientation of the spheres:</p>\n<table id='259' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>21</td></tr></tbody></table>\n<figure id='260'><img alt=\"\" data-coord=\"top-left:(320,112); bottom-right:(923,585)\" /><br><figcaption id='261' style='font-size:14px'>Figure 11 – Nested shells (mesh cut).</figcaption></figure>\n\n<table id='262' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>22</td></tr></tbody></table>\n<h1 id='263' style='font-size:22px'>6. Quadratic elements & high-order nodes</h1>\n<br><p id='264' data-category='paragraph' style='font-size:20px'>Let us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here<br>again that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6<br>elements can be curved or not.</p>\n<figure id='265'><img style='font-size:16px' alt=\"#include 'stdafx.h'\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm('sphere_t6.dat');\n// UNLOCK THE DLL.\ntetramesh_iso::registration('Licensed to SMART Inc.', 'F53EA108BCWX');\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output('TH.mesh', data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main\" data-coord=\"top-left:(102,280); bottom-right:(1143,822)\" /></figure>\n<p id='266' data-category='paragraph' style='font-size:20px'>The mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,<br>we have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the<br>above example (view to the first 3 rows from index 0, 0)20.</p>\n<br><p id='267' data-category='paragraph' style='font-size:20px'>After the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:</p>\n<p id='268' data-category='paragraph' style='font-size:16px'>meshtools3d::convert_into_quadratic(data.pos, data.connectM);</p>\n<p id='269' data-category='paragraph' style='font-size:20px'>But in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an<br>overload function with additional matrix parameters:</p>\n<p id='270' data-category='paragraph' style='font-size:16px'>meshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());</p>\n<p id='271' data-category='paragraph' style='font-size:20px'>This forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match<br>(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of<br>the tetrahedrons in data.connectM).</p>\n<p id='272' data-category='footnote' style='font-size:14px'>20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension).</p>\n\n<table id='274' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>23</td></tr></tbody><caption id='273' data-category='footnote' style='font-size:14px'>21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_<br>order. Refer to the HTML reference manual for detailed information.</caption></table>\n<p id='275' data-category='paragraph' style='font-size:20px'>The connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the<br>linear faces)22.</p>\n<p id='276' data-category='paragraph' style='font-size:16px'>Linear nodes</p>\n<br><table id='277' style='font-size:18px'><thead></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>5</td><td>5</td><td>1</td><td>3</td><td>4</td></tr><tr><td>1</td><td>3</td><td>3</td><td>2</td><td>0</td><td>6</td><td>6</td><td>3</td></tr><tr><td>2</td><td>2</td><td>4</td><td>4</td><td>2</td><td>3</td><td>7</td><td>7</td></tr><tr><td>8</td><td>11</td><td>13</td><td>14</td><td>9</td><td>18</td><td>20</td><td>21</td></tr><tr><td>9</td><td>8</td><td>14</td><td>15</td><td>16</td><td>12</td><td>21</td><td>22</td></tr><tr><td>10</td><td>12</td><td>11</td><td>16</td><td>17</td><td>19</td><td>18</td><td>13</td></tr></tbody></table>\n<p id='278' data-category='paragraph' style='font-size:16px'>Figure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3).</p>\n<footer id='279' style='font-size:20px'>The connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_<br>quadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons).</footer>\n<p id='280' data-category='paragraph' style='font-size:14px'>22 The empty matrix parameter stands for specific high-order edges. Here none of them.</p>\n<table id='281' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>24</td></tr></tbody></table>\n<h1 id='282' style='font-size:20px'>7. Multiple meshes</h1>\n<p id='283' data-category='paragraph' style='font-size:18px'>As seen before, matrix connectB can contain several internal surfaces. It can also contain several external<br>boundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the<br>previous example, some care must be taken in the orientation of these surfaces. They must be oriented the<br>same way (for instance all normal outside) and these boundaries must not cross each other.</p>\n<figure id='284'><img alt=\"\" data-coord=\"top-left:(127,326); bottom-right:(1110,710)\" /><br><figcaption id='285' style='font-size:14px'>Figure 13 – Multiple disconnected sub-domains.</figcaption></figure>\n\n<table id='286' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>25</td></tr></tbody></table>\n<h1 id='287' style='font-size:22px'>8. Repairing the boundary mesh</h1>\n<br><p id='288' data-category='paragraph' style='font-size:20px'>It is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not<br>watertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes.</p>\n<br><p id='289' data-category='paragraph' style='font-size:20px'>CM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23.</p>\n<br><p id='290' data-category='paragraph' style='font-size:20px'>To illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple<br>extrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some<br>nodes are also coincident.</p>\n<figure id='291'><img style='font-size:16px' alt=\"Figure 14 – Intersecting meshes.\" data-coord=\"top-left:(164,392); bottom-right:(1079,969)\" /></figure>\n<p id='292' data-category='paragraph' style='font-size:20px'>In strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,<br>they remove the intersecting and overlapping triangles and fill all the gaps.</p>\n<p id='293' data-category='paragraph' style='font-size:14px'>23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual).</p>\n<table id='294' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>26</td></tr></tbody></table>\n<figure id='295'><img alt=\"\" data-coord=\"top-left:(406,97); bottom-right:(841,678)\" /></figure>\n<br><p id='296' data-category='paragraph' style='font-size:14px'>Figure 15 – Repaired mesh.</p>\n<p id='297' data-category='paragraph' style='font-size:20px'>Note that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry<br>of the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by<br>adding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials.</p>\n<table id='298' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>27</td></tr></tbody></table>\n<h1 id='299' style='font-size:20px'>9. Background mesh</h1>\n<p id='300' data-category='paragraph' style='font-size:18px'>Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially<br>when automatic mesh adaptivity is involved. The background mesh option is the solution in this case.</p>\n<br><p id='301' data-category='paragraph' style='font-size:18px'>The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside<br>the domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher.</p>\n<br><p id='302' data-category='paragraph' style='font-size:18px'>As always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices<br>or vectors (such as connectM or connectB).</p>\n<br><p id='303' data-category='paragraph' style='font-size:18px'>The nodes of the background mesh can be all different from the nodes of connectB or some can be common.<br>They must all have a valid associated size value in the metrics array. The size map (also called metrics map) is<br>interpolated inside the background mesh.</p>\n<br><p id='304' data-category='paragraph' style='font-size:18px'>In the following example, a simple regular background mesh is used to support a sinusoidal metrics map<br>varying in the three directions. The domain to be meshed is a simple cube regularly discretized on its<br>boundaries.</p>\n<p id='305' data-category='paragraph' style='font-size:18px'>To simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a<br>cube centered at the origin.</p>\n<p id='306' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>\n<p id='307' data-category='paragraph' style='font-size:14px'>// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),<br>// with edge length equal to \"L\" and with \"N\" elements along each edge.<br>void<br>cube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)</p>\n<br><p id='308' data-category='paragraph' style='font-size:14px'>{</p>\n<br><p id='309' data-category='paragraph' style='font-size:14px'>UIntVec indices;<br>UIntMat connectE, connectB1, connectB2;</p>\n<br><p id='310' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),<br>DoubleVec3(L, 0., 0.), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);</p>\n<br><p id='311' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB2);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB2.push_back(connectB1);</p>\n<br><p id='312' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB2);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB2.push_back(connectB1);</p>\n<br><p id='313' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB1);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);<br>connectB2.push_back(connectB1);</p>\n<br><p id='314' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);<br>connectB.push_back(connectB2);</p>\n<br><p id='315' data-category='paragraph' style='font-size:14px'>}</p>\n<p id='316' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='317' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='318' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L(4.), h0(0.5), h1(0.1);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB1, connectB2, BGM, connectM2;</td></tr><tr><td>DoubleVec</td><td>sizes;</td></tr><tr><td>unsigned</td><td>N, N_BGM, n;</td></tr><tr><td>double</td><td>w, h;</td></tr><tr><td>tetramesh_iso::mesher</td><td>the_mesher;</td></tr><tr><td>tetramesh_iso::mesher::data_type</td><td>dataTH;</td></tr></tbody></table>\n<br><p id='319' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>\n<br><p id='320' data-category='paragraph' style='font-size:14px'>// THE BOUNDARY OF THE BACKGROUND MESH<br>N_BGM = unsigned(std::max(L/h0, L/h1));</p>\n<table id='321' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>28</td></tr></tbody></table>\n<h1 id='322' style='font-size:14px'>cube_boundary(L, N_BGM, pos, connectB1);</h1>\n<br><p id='323' data-category='paragraph' style='font-size:14px'>// THE 3D BACKGROUND MESH.<br>dataTH.pos = pos;<br>dataTH.connectB = connectB1;<br>the_mesher.run(dataTH);<br>dataTH.extract(pos, BGM);</p>\n<br><p id='324' data-category='paragraph' style='font-size:14px'>// THE METRICS ON THE 3D BACKGROUND MESH.<br>meshtools::unique_indices(indices, BGM);<br>sizes.resize (pos.cols(), 0.);<br>for (size_t i = 0; i < indices.size(); ++i)</p>\n<br><p id='325' data-category='paragraph' style='font-size:14px'>{</p>\n<br><p id='326' data-category='paragraph' style='font-size:14px'>n = indices[i];<br>w = vecscal::max_norm(pos.col(n));<br>h = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;<br>sizes[n] = h;</p>\n<br><p id='327' data-category='paragraph' style='font-size:14px'>}</p>\n<br><p id='328' data-category='paragraph' style='font-size:14px'>// THE BOUNDARY OF THE FINAL MESH.<br>cube_boundary(L, N, pos, connectB2);</p>\n<br><p id='329' data-category='paragraph' style='font-size:14px'>// THE 3D MESH.<br>dataTH.pos = pos;<br>dataTH.connectB = connectB2;<br>dataTH.background_mesh = BGM;<br>dataTH.metrics = sizes;<br>the_mesher.run(dataTH);</p>\n<br><p id='330' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.</p>\n<br><p id='331' data-category='paragraph' style='font-size:14px'>meshtools::clip(dataTH.pos, dataTH.connectM,<br>DoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>\n<br><p id='332' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>\n<br><p id='333' data-category='paragraph' style='font-size:14px'>}</p>\n<figure id='334'><img alt=\"\" data-coord=\"top-left:(318,821); bottom-right:(919,1385)\" /><figcaption id='335' style='font-size:14px'>Figure 16 – Use of a background mesh to support a metric map on the domain (mesh cut).</figcaption></figure>\n\n<p id='336' data-category='paragraph' style='font-size:20px'>The background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be<br>partially outside of the domain. In the zones not covered by the background mesh, the default interpolation of<br>the sizes from the hard nodes is used instead.</p>\n<table id='337' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>29</td></tr></tbody></table>\n<p id='338' data-category='paragraph' style='font-size:20px'>Here is an example where the domain and the background mesh are both spheres but the latter is half the<br>radius of the former. We have set a uniform value for the metric map on the background mesh to get a finer<br>mesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still<br>conformal.</p>\n<figure id='339'><img alt=\"\" data-coord=\"top-left:(320,246); bottom-right:(924,703)\" /><figcaption id='340' style='font-size:16px'>Figure 17 – Background mesh covering only a fraction of the domain (mesh cut).</figcaption></figure>\n\n<p id='341' data-category='paragraph' style='font-size:20px'>The background mesh is a very useful feature to control precisely the size of the elements all over the domain.<br>It can however be time consuming. The finer the background mesh, the longer the meshing process. The<br>background mesh should be coarse wherever the metric is slowly varying and fine only in the regions where<br>the metric is sharply varying and should be approximated with accuracy.</p>\n<br><p id='342' data-category='paragraph' style='font-size:20px'>We can also consider the case where the boundary surface mesh of the domain must also be governed by<br>background mesh. Two steps with two different background meshes are required24. First, the surface mesh is<br>generated with the help of a surface background mesh. An anisotropic mesher supporting the background<br>mesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -<br>CM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to<br>generate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final<br>adapted 3-D mesh.</p>\n<p id='343' data-category='paragraph' style='font-size:20px'>☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a<br>changed metrics map (saving a new meshing from scratch).</p>\n<p id='344' data-category='paragraph' style='font-size:14px'>24 A third kind of background mesh can be needed to generate the line meshes.</p>\n<table id='345' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>30</td></tr></tbody></table>\n<h1 id='346' style='font-size:22px'>10. Anisotropic meshes (CM2 TetraMesh Aniso)</h1>\n<br><p id='347' data-category='paragraph' style='font-size:18px'>CM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.<br>It’s sometimes useful however to have elements stretched in some special directions. To deal with complex<br>domains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator<br>CM2 TetraMesh Aniso.<br>CM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This<br>array is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define<br>the size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in<br>the metrics array.</p>\n<figure id='348'><img style='font-size:18px' alt=\"h\nP\" data-coord=\"top-left:(227,448); bottom-right:(408,623)\" /></figure>\n<figure id='349'><img alt=\"\" data-coord=\"top-left:(263,713); bottom-right:(371,819)\" /></figure>\n<p id='350' data-category='paragraph' style='font-size:14px'>Isotropic tet<br>(size 1 in the isotropic metric h)</p>\n<br><figure id='351'><img style='font-size:18px' alt=\"h2\nh0\nP\nh1\" data-coord=\"top-left:(657,435); bottom-right:(947,829)\" /></figure>\n<p id='352' data-category='paragraph' style='font-size:14px'>Anisotropic tet<br>(size 1 in the anisotropic metric M)</p>\n<p id='353' data-category='paragraph' style='font-size:14px'>Figure 18 – A single scalar defines an isotropic metric (left).<br>A 3-D anisotropic metric needs three vectors (right).</p>\n<p id='354' data-category='paragraph' style='font-size:18px'>3-D anisotropic metrics are defined as below:</p>\n<br><figure id='355' data-category='chart'><img data-coord=\"top-left:(136,1071); bottom-right:(906,1533)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>a</td><td>b</td><td>c</td><td>d</td></tr></thead><tbody><tr><td>item_01</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></figure></table>\n<br><caption id='356' style='font-size:14px'>Figure 19 – Definition and storage of the 3-D anisotropic metrics.</caption>\n<table id='357' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>31</td></tr></tbody></table>\n<p id='358' data-category='paragraph' style='font-size:18px'>Let (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:</p>\n<p id='359' data-category='equation'>$$\\begin{array}{l}{{\\mathbf{v}_{0}\\lVert=\\lVert\\mathbf{v}_{1}\\rVert=\\lVert\\mathbf{v}_{2}\\rVert=1}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{2}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0}\\times\\mathbf{v}_{1},\\mathbf{v}_{2}\\rfloor=1}}\\end{array}$$</p>\n<p id='360' data-category='paragraph' style='font-size:20px'>Then, the metric Mj writes:</p>\n<br><p id='361' data-category='equation'>$$\\begin{array}{c c c}{{}}&{{}}&{{\\left[\\frac{1}{h_{0}^{~2}}~}&{{}}&{{}}&{{0}}\\\\ {{}}&{{}}&{{}}\\\\ {{0~~~~~{\\frac{1}{h_{1}^{~2}}}}}&{{}}\\\\ {{}}&{{}}&{{}}&{{}}\\\\ {{}}&{{}}&{{}}&{{\\displaystyle{\\frac{1}{h_{2}^{~2}}}\\right]}}\\end{array}$$</p>\n<br><p id='362' data-category='paragraph' style='font-size:16px'>T B</p>\n<br><h1 id='363' style='font-size:20px'>B � �v 0 v1 v 2 �</h1>\n<br><p id='364' data-category='paragraph' style='font-size:18px'>with:</p>\n<br><h1 id='365' style='font-size:20px'>stored column � wise</h1>\n<p id='366' data-category='paragraph' style='font-size:18px'>The h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are<br>the inverse of the square root of the eigen values of metric Mj.</p>\n<br><p id='367' data-category='paragraph' style='font-size:18px'>The 3-D metric equivalent of an isotropic size of h writes:</p>\n<p id='368' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$</p>\n<p id='369' data-category='paragraph' style='font-size:18px'>A null matrix would lead to infinite sizes in the three directions (infinite sphere).</p>\n<br><p id='370' data-category='paragraph' style='font-size:18px'>When the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic<br>case we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.<br>This leads to the same default behavior as their related isotropic counterparts. Take the previous examples and<br>replace:</p>\n<p id='371' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;</p>\n<p id='372' data-category='paragraph' style='font-size:18px'>with</p>\n<p id='373' data-category='paragraph' style='font-size:14px'>tetramesh_aniso::mesher the_mesher;</p>\n<p id='374' data-category='paragraph' style='font-size:18px'>and you get the same output meshes25.</p>\n<br><p id='375' data-category='paragraph' style='font-size:14px'>25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower).</p>\n<table id='376' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>32</td></tr></tbody></table>\n<p id='377' data-category='paragraph' style='font-size:16px'>The following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements<br>along each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic<br>metric. Here, the metric is uniform on all the beam and equals simply:</p>\n<p id='378' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{{\\displaystyle{\\left[\\frac{1}{h_{0}^{2}}}}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\displaystyle{{\\frac{1}{h_{0}^{2}}}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\displaystyle{{\\bar{h}_{1}^{2}}}}}\\end{array}\\right]$$</p>\n<br><p id='379' data-category='paragraph' style='font-size:16px'>with:</p>\n<br><h1 id='380' style='font-size:18px'>h0� �</h1>\n<br><p id='381' data-category='paragraph' style='font-size:20px'>L0</p>\n<br><p id='382' data-category='paragraph' style='font-size:14px'>N 0</p>\n<br><h1 id='383' style='font-size:18px'>h1� �</h1>\n<br><p id='384' data-category='paragraph' style='font-size:20px'>L1</p>\n<br><p id='385' data-category='paragraph' style='font-size:14px'>N 1</p>\n<p id='386' data-category='paragraph' style='font-size:16px'>Here, the directions of anisotropy are identical to the global axes X, Y, Z.</p>\n<table id='387' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>33</td></tr></tbody></table>\n<h1 id='388' style='font-size:14px'>#include \"stdafx.h\"</h1>\n<p id='389' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><h1 id='390' style='font-size:20px'>{{</h1>\n<br><table id='391' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L0(10.), L1(100.);</td></tr><tr><td>const unsigned</td><td>N0(10), N1(10);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectE, connectB1, connectB2, connectB;</td></tr><tr><td>UIntMat</td><td>connectM, connectM2;</td></tr><tr><td>DoubleMat</td><td>metrics;</td></tr><tr><td>double</td><td>D0, D1;</td></tr></tbody></table>\n<br><p id='392' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");</p>\n<br><p id='393' data-category='paragraph' style='font-size:14px'>// BOUNDARY 2D MESH.</p>\n<br><p id='394' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0.),<br>DoubleVec3(0., L0, 0.), N0, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),<br>N0, 2, connectB);</p>\n<p id='395' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools2d::flip_T3(connectB1);<br>meshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);<br>connectB.push_back(connectB1);</p>\n<br><p id='396' data-category='paragraph' style='font-size:14px'>connectB1.clear();<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),</p>\n<br><p id='397' data-category='paragraph' style='font-size:14px'>N1, 2, connectB1);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),<br>DoubleVec3(0,0,M_PI/2), connectB2);<br>connectB1.push_back(connectB2);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),<br>DoubleVec3(0., 0., M_PI), connectB2);<br>connectB1.push_back(connectB2);<br>connectB.push_back(connectB1);</p>\n<br><p id='398' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>\n<br><p id='399' data-category='paragraph' style='font-size:14px'>// METRICS.<br>metrics.resize(6, pos.cols(), 0.);</p>\n<br><p id='400' data-category='paragraph' style='font-size:14px'>D0 = 1. / ((L0 / N0) * (L0 / N0));<br>D1 = 1. / ((L1 / N1) * (L1 / N1));</p>\n<br><p id='401' data-category='paragraph' style='font-size:14px'>for (size_t n = 0; n < pos.cols(); ++n)</p>\n<br><p id='402' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='403' style='font-size:14px'><thead></thead><tbody><tr><td>metrics(0,n) = D0;</td><td>//</td><td>Mxx</td></tr><tr><td>metrics(1,n) = 0.0;</td><td>//</td><td>Mxy</td></tr><tr><td>metrics(2,n) = D0;</td><td>//</td><td>Myy = Mxx</td></tr><tr><td>metrics(3,n) = 0.0;</td><td>//</td><td>Mxz</td></tr><tr><td>metrics(4,n) = 0.0;</td><td>//</td><td>Myz</td></tr><tr><td>metrics(5,n) = D1;</td><td>//</td><td>Mzz</td></tr></tbody></table>\n<br><p id='404' data-category='paragraph' style='font-size:14px'>}</p>\n<p id='405' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_aniso::mesher the_mesher;<br>tetramesh_aniso::mesher::data_type data(pos, connectB);<br>the_mesher.settings.compute_Qh_flag = true;<br>data.metrics = metrics;<br>the_mesher.run(data);<br>data.extract(pos, connectM);<br>data.print_info(&display_hdl);</p>\n<p id='406' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),<br>DoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0<br>meshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);</p>\n<br><p id='407' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>\n<br><p id='408' data-category='paragraph' style='font-size:14px'>}</p>\n<table id='409' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>34</td></tr></tbody></table>\n<figure id='410'><img alt=\"\" data-coord=\"top-left:(294,164); bottom-right:(944,1256)\" /></figure>\n<p id='411' data-category='paragraph' style='font-size:14px'>Figure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom).</p>\n<p id='412' data-category='paragraph' style='font-size:20px'>Here is the output given by data.print_info. Note that the qualities (shape and edge) are computed using<br>the local anisotropic metrics.</p>\n<table id='413' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>35</td></tr></tbody></table>\n<figure id='414'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23\" data-coord=\"top-left:(113,123); bottom-right:(1141,839)\" /><figcaption id='415' style='font-size:16px'>Figure 21 – Output info. Shape qualities are computed in the anisotropic metrics.</figcaption></figure>\n\n<figure id='416'><img style='font-size:14px' alt=\"************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(107,947); bottom-right:(1142,1462)\" /><figcaption id='417' style='font-size:16px'>Figure 22 – Edge quality histogram in the anisotropic metrics.</figcaption></figure>\n\n<table id='418' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>36</td></tr></tbody></table>\n<p id='419' data-category='paragraph' style='font-size:16px'>In the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We<br>used the following metric map:</p>\n<br><figure id='420'><img style='font-size:22px' alt=\"� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�\" data-coord=\"top-left:(155,180); bottom-right:(561,398)\" /></figure>\n<br><p id='421' data-category='equation'>$$\\mathrm{\\bf{B}}{\\bf{\\tilde{(}}}(r)\\!\\!\\mathrm{\\bf{\\tilde{|}}_{r}}{\\bf{\\tilde{|}}_{l e}}{\\bf{\\tilde{u}}_{\\mathrm{spheric}}\\mathrm{\\basi}_{\\mathrm{\\tilde{l}}}}.$$</p>\n<br><p id='422' data-category='paragraph' style='font-size:16px'>with:</p>\n<br><p id='423' data-category='equation'>$$h{\\binom{\\alpha}{\\alpha}}=h_{1}{\\frac{\\displaystyle r}{R}}+h_{0}\\Biggl(1-{\\frac{\\displaystyle r}{R}}\\Biggr)$$</p>\n<p id='424' data-category='paragraph' style='font-size:16px'>Radially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the<br>boundary of the sphere.</p>\n<br><p id='425' data-category='paragraph' style='font-size:16px'>The mesher input metric map is only given at the boundary nodes of the external sphere and at the center<br>node. The mesher will do the interpolation in-between.</p>\n<figure id='426'><img alt=\"\" data-coord=\"top-left:(315,587); bottom-right:(927,1057)\" /></figure>\n<table id='427' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>37</td></tr></tbody></table>\n<figure id='428'><img alt=\"\" data-coord=\"top-left:(316,110); bottom-right:(928,728)\" /><br><figcaption id='429' style='font-size:14px'>Figure 23 – An anisotropic sphere (mesh cut).</figcaption></figure>\n\n<p id='430' data-category='paragraph' style='font-size:20px'>Background meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic<br>counter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid<br>(three strictly positive eigen-values).</p>\n<table id='431' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>38</td></tr></tbody></table>\n<h1 id='432' style='font-size:20px'>CM2 TetraMesh® Iso</h1>\n<br><h1 id='433' style='font-size:16px'>Version 5.6</h1>\n<h1 id='434' style='font-size:18px'>mesh gallery</h1>\n<p id='435' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>\n<figure id='436'><img style='font-size:16px' alt=\"Figure 1 – Block-stop.\" data-coord=\"top-left:(390,406); bottom-right:(858,1005)\" /></figure>\n<figure id='437'><img style='font-size:14px' alt=\"Nodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)\" data-coord=\"top-left:(374,1152); bottom-right:(916,1375)\" /></figure>\n<footer id='438' style='font-size:20px'>The output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)<br>on Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled).</footer>\n<table id='439' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>40</td></tr></tbody></table>\n<figure id='440'><img alt=\"\" data-coord=\"top-left:(393,410); bottom-right:(846,965)\" /><br><figcaption id='441' style='font-size:16px'>Figure 2 – Hammer.</figcaption></figure>\n\n<figure id='442'><img style='font-size:14px' alt=\"odes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)\" data-coord=\"top-left:(377,1176); bottom-right:(914,1373)\" /></figure>\n<table id='443' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>41</td></tr></tbody></table>\n<figure id='444'><img style='font-size:16px' alt=\"Figure 3 – Driving Rod.\" data-coord=\"top-left:(258,402); bottom-right:(975,991)\" /></figure>\n<figure id='445'><img style='font-size:14px' alt=\"Nodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)\" data-coord=\"top-left:(376,1171); bottom-right:(916,1372)\" /></figure>\n<table id='446' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>42</td></tr></tbody></table>\n<figure id='447'><img alt=\"\" data-coord=\"top-left:(280,403); bottom-right:(954,973)\" /><br><figcaption id='448' style='font-size:16px'>Figure 4 – Blade.</figcaption></figure>\n\n<figure id='449'><img style='font-size:14px' alt=\"Nodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)\" data-coord=\"top-left:(374,1163); bottom-right:(915,1378)\" /></figure>\n<table id='450' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>43</td></tr></tbody></table>\n<figure id='451'><img alt=\"\" data-coord=\"top-left:(398,405); bottom-right:(849,966)\" /><br><figcaption id='452' style='font-size:16px'>Figure 5 – Rim.</figcaption></figure>\n\n<figure id='453'><img style='font-size:14px' alt=\"Nodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)\" data-coord=\"top-left:(381,1177); bottom-right:(907,1369)\" /></figure>\n<table id='454' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>44</td></tr></tbody></table>\n<figure id='455'><img alt=\"\" data-coord=\"top-left:(284,409); bottom-right:(946,956)\" /><br><figcaption id='456' style='font-size:16px'>Figure 6 – Crank.</figcaption></figure>\n\n<figure id='457'><img style='font-size:14px' alt=\"Nodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)\" data-coord=\"top-left:(374,1165); bottom-right:(918,1377)\" /></figure>\n<table id='458' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>45</td></tr></tbody></table>\n<p id='459' data-category='paragraph' style='font-size:14px'>https://www.computing-objects.com</p>\n<br><p id='460' data-category='paragraph' style='font-size:14px'>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>\n<br><p id='461' data-category='paragraph' style='font-size:14px'>Limited Liability Company with a capital of 100 000 €.<br>Registered at Versailles RCS under SIRET number 422 791 038 00033.<br>EU VAT registration FR59422791038.</p>", "markdown": "# CM2 TetraMesh® Iso/Aniso\n\n# Version 5.6\n\ntutorials\n\nRevision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\n\n# Forewords\n\nThis manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:\n\n- • The isotropic mesher CM2 TetraMesh® Iso,\n- • The anisotropic mesher CM2 TetraMesh® Aniso.\n\n\nThese two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and\nthe internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh.\n\nBased on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality\nelements with smooth grading size according to the length of the boundary elements, to the user-specified\nsizes or to the metric map supported by a background mesh.\n\nThey can generate very big meshes – several millions of elements – with a limited amount of memory. The\nspeed is near independent of the number of the elements to be generated.\n\nOption switches can be used to adapt the meshers to the various needs of the user concerning mesh\nrefinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already\nexisting tetrahedral meshes.\n\nMany data concerning the mesh are available upon exit: histograms of the shape qualities and the size\nqualities, matrix of the neighbors, number of sub-domains, meshed volume...\n\nLike many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the\nsettings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).\n\nData are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers.\n\nFor a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TetraMesh Iso/Aniso - reference manual.\n\nThe source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and\nIDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.\n\nThe source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 2 |\n| --- | --- | --- |\n\n\n# Table of contents\n\nForewords .................................................................................................................................................. 2\n1. Getting started ...................................................................................................................................... 5\nSome declarations .................................................................................................................................................................... 6\nAuthorization of the library .................................................................................................................................................... 6\nBoundary mesh ......................................................................................................................................................................... 7\nTetrahedral mesh ..................................................................................................................................................................... 7\n2. Simple cube ......................................................................................................................................... 10\nSome declarations .................................................................................................................................................................. 11\nBoundary mesh ....................................................................................................................................................................... 11\nTetrahedral mesh ................................................................................................................................................................... 13\n3. Cube with an internal hard line ........................................................................................................ 15\n4. Cube with an internal hard node ..................................................................................................... 18\n5. Internal cavity ..................................................................................................................................... 20\n6. Quadratic elements & high-order nodes ........................................................................................ 23\n7. Multiple meshes ................................................................................................................................. 25\n8. Repairing the boundary mesh .......................................................................................................... 26\n9. Background mesh .............................................................................................................................. 28\n10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31\nMesh gallery ............................................................................................................................................ 39\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 3 |\n| --- | --- | --- |\n\n\nThis manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options\nof the meshers CM2 TetraMesh® Iso/Aniso.\n\nEach example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).\n\nThe general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:\n:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.\n\nFile stdafx.h:\n\n// CM2 MESHTOOLS\n\n| #include \"meshtools.h\" // | General purpose mesh routines. |\n| --- | --- |\n| #include \"meshtools2d.h\" // | To generate 1D meshes. |\n| #include \"meshtools2d.h\" // | To generate 2D meshes. |\n| #include \"tetramesh_iso.h\" // | CM2 TetraMesh Iso. |\n| #include \"tetramesh_aniso.h\" // | CM2 TetraMesh Aniso (Section 10 only). |\n\n\nusing namespace cm2;\n\n// Main cm2 namespace can now be omitted.\n\nRequired libraries1:\n\n- • cm2math1\n- • cm2misc\n- • cm2meshtools\n- • cm2meshtools2d\n- • cm2meshtools2d\n- • cm2meshtools3d\n- • cm2tetramesh_iso\n- • cm2tetramesh_aniso (Section 10 only)\n\n\n1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.\nOn Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static\narchive), .so or .dylib (dynamic lib).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n\n\n# 1. Getting started\n\nThe simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We\nassume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is\nquite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a\n3xNT matrix2. For each matrix the format is:\n\nn X m [\nd0,0 d0,1 d0,2 ... d0,m-1\nd1,0 d1,1 d1,2 ... d1,m-1\n...\ndn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]\n\nFor instance, a mesh with 4 nodes and 2 triangles could write3:\n\n3 X 4 [\n0. 1. 1. 0.\n0. 0. 1. 1.\n0. 0. 0.5 0. ]\n\n3 X 2 [\n0 1\n1 2\n3 3 ]\n\nThe source code to generate the tetrahedral mesh writes:\n\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n\n// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }\n\nint main()\n\n{\n\nstd::ifstream istrm(\"part.dat\");\ncm2::tetramesh_iso::mesher the_mesher;\ncm2::tetramesh_iso::mesher::data_type data;\n\n// UNLOCK THE DLL.\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// READ THE BOUNDARY TRIANGLE MESH.\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);\n\n// GENERATE THE 3D MESH.\nthe_mesher.run(data);\n\n// SOME OUTPUT INFO (OPTIONAL).\ndata.print_info(&display_hdl);\n\n// VISUALISATION (OPTIONAL).\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n- 2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.\n- 3 The format for each value is free.\n\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 5 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\nFigure 1 – A simple mechanical part.\n\nLet us explain this program line by line.\n\n# Some declarations\n\nA standard input stream istrm is built with the data file name part.dat. We create then an instance of the\ntet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the\nnodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB\nand final tet mesh in data.connectM).\n\nMatrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and\ndata.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This\ninteger refers to the column number in matrix data.pos where the coordinates of this node can be found5.\n\n# Authorization of the library\n\nThe tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two\nstrings must be provided for each library: the name of your company or organization that has acquired the\nlicense and a secret code6. Note that both strings are case sensitive and the registration call must be made\neach time the library is loaded into memory and before any run of the mesher.\n\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n- 4 See manual CM2 Math1 - overview.\n- 5 Recall that array indices are zero based (from 0 to N-1).\n- 6 Contact license@computing-objects.com for any licensing inquiry.\n\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 6 |\n| --- | --- | --- |\n\n\n# Boundary mesh\n\nThe cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.\nWe use it to load the nodes’ coordinates and the triangle connectivity from the same file.\n\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);\n\n# Tetrahedral mesh\n\nthe_mesher.run(data);\n\nUpon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the\ntetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary\nmesh are left untouched in the first columns.\n\nThe connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of\nthe nodes for an element. connectM(i, j) is the ith local node of the jth element.\n\n# Output information\n\nPrinted information about the generated mesh and a MEDIT8 output file are obtained with:\n\ndata.print_info(&display_hdl);\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\n\nFigure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of\n2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces\nand hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9.\n\nThe first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the\nsecond step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the\nlast step concerns geometrical and topological optimizations to improve the quality of the elements.\n\nThe formula used to compute the shape quality of a tetrahedron is given by:\n\n| V | V Volume of the tetrahedron. |\n| --- | --- |\n| Qs 6� 6 Lmax S | with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron. |\n\n\n7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:\n:transpose_read function exists to read a matrix and transpose it on the fly.\n8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),\nVTK and Wavefront OBJ.\n9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-\nthreading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®\nAniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased\nfurther by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 7 |\n| --- | --- | --- |\n\n\nThis quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet).\n\nOn the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2).\n\nNote that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There\nis an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator\ncannot produce a mesh with a minimum quality better than 0.56 in this case.\n\nThe size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the\nedge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always\npositive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it\nshould be.\n\nThe formula used to compute the length quality of an edge AB writes:\n\n$$Q_{h}^{A B}=L_{A B}\\,\\frac{\\left|\\mathrm{h}_{A}\\right|}{h_{B}}$$\n\nwith:\n\n- LAB Actual length of edge AB.\n- hA Target size at node A (expected edge length at A).\n- hB Target size at node B (expected edge length at B).\n\n\nLet’s introduce also at this point the h-shock measure of an edge:\n\n$$h s^{4B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{b}^{4B}}}-1$$\n\nThese two measure are dimensionless and positive.\n\nLAB\nWhen hA = hB the h-shock is null and the length writes hQ AB � .\nhA\nWhen ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB.\n\nTo optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.\n\nThe mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.\nsettings.compute_Qh_flag10 is set to true11.\n\nOn this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance\n(Figure 3).\n\n10 See reference manual for details on the settings of the meshers.\n\n11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74\n\nFigure 2 – Output info for the “mechanical part” example.\n\n![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0\n\nFigure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 9 |\n| --- | --- | --- |\n\n\n# 2. Simple cube\n\nThis second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.\nThis will also help introduce some options of CM2 TetraMesh Iso in following examples.\n\nThe following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):\n\n#include \"stdafx.h\"\n#include <iostream>\n\n// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }\n\nint main()\n\n{\n\n| const unsigned | N(6); | // The discretization along each edge. |\n| --- | --- | --- |\n| const double | L(4.); | // The sides length. |\n| DoubleMat | pos; |  |\n| UIntMat | connectE, | connectB, connectB1, connectB2; |\n| UIntVec | indices; |  |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\n\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n\n// VISUALISATION (OPTIONAL).\ndata.print_info(&display_hdl);\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\n\nreturn 0;\n} // main\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 10 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\nFigure 4 – Simple cube.\n\nLet us again explain this program line by line.\n\nMost of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only\nthree lines in the program.\n\n# Some declarations\n\nMatrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the\nfinal mesh (many of them are in both).\n\nMatrix connectB stores the connectivity matrix of the boundary triangle mesh.\n\nMatrices connectB1, connectB2 and connectE are temporaries as well as vector indices.\n\n# Boundary mesh\n\nIn this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to\ngenerate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher\nneeds this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix\nconnectB of connectivity of the boundary triangles.\n\nWe choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of\nthe cube.\n\nThe first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):\n\nmeshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 11 |\n| --- | --- | --- |\n\n\nThis generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos\nmatrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This\nvector contains upon exit of this function (N = 6):\n\n[0 1 2 3 4 5 6]\n\nAnd the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).\nThe vector of indices is used to create the connectivity matrix of the first edge mesh:\n\nmeshtools2d::indices_to_connectE2(indices, connectE);\n\nconnectE is now a 2x6 matrix:\n\n2x6 [0 1 2 3 4 5\n1 2 3 4 5 6]\n\nThis line mesh is then extruded into a mesh of triangles along vector (0, L, 0):\n\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);\n\nThe 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”\npattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to\nmatrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix\nconnectB as new columns of indices of nodes.\n\nWe now have to copy and rotate this mesh:\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\n\nAfter the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix\npos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),\nY}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB.\n\n12 Several variants of this function are available in the meshtools2d library and are described in the API.\n\n13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and\ncopies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 12 |\n| --- | --- | --- |\n\n\nThe two faces together are then copied and rotated twice in order to generate the other four missing faces of\nthe cube:\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\n\nAt this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.\nHowever, some points are coincident and need to be merged together:\n\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n\nThis function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the\nindex of the first node encountered replaces all the others subsequent coincident nodes14.\n\n# Tetrahedral mesh\n\nNow we have generated the boundary mesh, we can call the 3-D mesher on it:\n\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n\nThe difference with the previous example is that matrices pos and connect are built first and then passed to\nthe data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.\nThere is no significant difference between the two approaches. We can either modify directly data.pos and\ndata.connectB or build some separated matrices pos and connect and then pass them to the data\nconstructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -\noverview.\n\nUpon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the\ntetrahedral mesher on top of the initial surface points.\n\n14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify.\n\n15 But the pos matrix still has 294 columns.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 13 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58\n\nFigure 5 – Output info for the cube example.\n\n![image](/image/placeholder)\n************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\n\nFigure 6 – Histogram of the size-qualities of all the edges in the cube example.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 14 |\n| --- | --- | --- |\n\n\n# 3. Cube with an internal hard line\n\nStarting from the previous example, we add a hard line inside the cube:\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const unsigned | N(6); // The discretization along each edge. |\n| --- | --- |\n| const double | L(4.); // The sides length. |\n| DoubleMat | pos; |\n| UIntMat | connectE, connectB, connectB1, connectB2, connectM2; |\n| UIntVec | indices; |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\n\nindices.clear(); connectE.clear();\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);\n\n// 3D MESH.\n\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.connectE = connectE;\nthe_mesher.run(data);\n\n// MESH VISUALIZATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 15 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 7 – Half cube with internal line (mesh cut).\n\nThe mesh of the internal line is generated like the mesh of the first edge of the cube:\n\nmeshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\n\nThis mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh\nis four times finer along this line than on the cube edges, in order to make the line more visible and also to get\na graded mesh size.\n\nTo avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two\nmatching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary\nmesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is\ndone concurrently with the merging of the nodes of the edges of the cube already discussed in the previous\nsection:\n\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);\n\nThe new internal prescribed edges are given to the mesher with:\n\n![image](/image/placeholder)\ndata.connectE = connectE;\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 16 |\n| --- | --- | --- |\n\n\nTo visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets\nwith at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.\npos, or on the connectivity matrix of the full mesh data.connectM:\n\nmeshtools::clip\n(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\n\nTo constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface\nmesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard\nfaces into the matrix data.connectB for instance with a push-back (see next example).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 17 |\n| --- | --- | --- |\n\n\n# 4. Cube with an internal hard node\n\nThere are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with\ndifferent or varying size on the boundary and interior surface or line, like in the previous example. The mesher\ncomputes a size value on each hard node16, interpolates these values inside the domain and generates\nelements accordingly.\n\nA second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all\nthe hard nodes. This is explained in this section.\n\nSo far, we have seen only four fields of the data structure used by the mesher:\n\n- • The pos matrix for the coordinates of the points.\n- • The connectB matrix for the connectivity of the hard faces.\n- • The connectE matrix for the connectivity of the hard edges (seen in Example 2).\n- • The connectM matrix for the connectivity of the output 3-D mesh.\n\n\nIn this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target\nsize for the elements near this node. This is done using two new fields: isolated_nodes and metrics:\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const unsigned | N(6); |\n| --- | --- |\n| const double | L(4.); |\n| DoubleMat | pos(3, 1, L/2.); |\n| UIntMat | connectB, connectB1, connectB2, connectE, connectM2; |\n| UIntVec | indices; |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// BOUNDARY 2D MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,\n\nindices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,\nconnectB);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);\nconnectB.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n\n// 3D MESH.\n\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.isolated_nodes.push_back(0);\ndata.metrics.resize(1, 0.05*L/N);\nthe_mesher.run(data);\n\n// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\n\nreturn 0;\n} // main\n\nInitializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into\naccount by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 18 |\n| --- | --- | --- |\n\n\n# data.isolated_nodes.push_back(0);\n\nThe vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or\nnegative or not present), the automatically computed value will be used instead18. In this example the vector is\nresized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:\n\ndata.metrics.resize(1, 0.05*L/N);\n\nFor all the other nodes, we let the mesher compute suitable values.\n\n![image](/image/placeholder)\n\n\nFigure 8 – Half cube with internal hard node (mesh cut).\n\n- 16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.\n- 17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));\n- 18 For an isolated node, the computed size is based on the values of the nearest nodes.\n\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n\n\n# 5. Internal cavity\n\nA cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This\nimplies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we\nhave the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1.\n\n#include \"stdafx.h\"\n#include <fstream>\n\nint main()\n\n{\n\n| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// READ THE BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\n\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n\n// MESH VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n![image](/image/placeholder)\nFigure 9 – Full sphere.\n\nThe surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing\nthe orientation of the triangles:\n\n19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 20 |\n| --- | --- | --- |\n\n\n#include \"stdafx.h\"\n#include <fstream>\n\nint main()\n\n{\n\n| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB, connectB2, connectM2; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// OUTER BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\n\n// INNER BOUNDARY.\nmeshtools::copy_mesh(pos, connectB2, connectB);\nmeshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);\nmeshtools2d::flip_T3(connectB2); // Reverse the orientation.\nconnectB.push_back(connectB2);\n\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n\n// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n![image](/image/placeholder)\n\n\nFigure 10 – Hollow sphere (mesh cut).\n\nNote that the matrix connectB contains both the external and the internal faces.\nNested shells can be generated simply by changing the orientation of the spheres:\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 21 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 11 – Nested shells (mesh cut).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 22 |\n| --- | --- | --- |\n\n\n# 6. Quadratic elements & high-order nodes\n\nLet us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here\nagain that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6\nelements can be curved or not.\n\n![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm(\"sphere_t6.dat\");\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main\n\nThe mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,\nwe have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the\nabove example (view to the first 3 rows from index 0, 0)20.\n\nAfter the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:\n\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM);\n\nBut in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an\noverload function with additional matrix parameters:\n\nmeshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());\n\nThis forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match\n(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of\nthe tetrahedrons in data.connectM).\n\n20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension).\n\n21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_\norder. Refer to the HTML reference manual for detailed information.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 23 |\n| --- | --- | --- |\n\n\nThe connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the\nlinear faces)22.\n\nLinear nodes\n\n| 0 | 1 | 2 | 5 | 5 | 1 | 3 | 4 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 3 | 3 | 2 | 0 | 6 | 6 | 3 |\n| 2 | 2 | 4 | 4 | 2 | 3 | 7 | 7 |\n| 8 | 11 | 13 | 14 | 9 | 18 | 20 | 21 |\n| 9 | 8 | 14 | 15 | 16 | 12 | 21 | 22 |\n| 10 | 12 | 11 | 16 | 17 | 19 | 18 | 13 |\n\n\nFigure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3).\n\nThe connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_\nquadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons).\n\n22 The empty matrix parameter stands for specific high-order edges. Here none of them.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 24 |\n| --- | --- | --- |\n\n\n# 7. Multiple meshes\n\nAs seen before, matrix connectB can contain several internal surfaces. It can also contain several external\nboundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the\nprevious example, some care must be taken in the orientation of these surfaces. They must be oriented the\nsame way (for instance all normal outside) and these boundaries must not cross each other.\n\n![image](/image/placeholder)\n\n\nFigure 13 – Multiple disconnected sub-domains.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 25 |\n| --- | --- | --- |\n\n\n# 8. Repairing the boundary mesh\n\nIt is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not\nwatertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes.\n\nCM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23.\n\nTo illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple\nextrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some\nnodes are also coincident.\n\n![image](/image/placeholder)\nFigure 14 – Intersecting meshes.\n\nIn strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,\nthey remove the intersecting and overlapping triangles and fill all the gaps.\n\n23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 26 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 15 – Repaired mesh.\n\nNote that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry\nof the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by\nadding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 27 |\n| --- | --- | --- |\n\n\n# 9. Background mesh\n\nSometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.\n\nThe background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher.\n\nAs always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices\nor vectors (such as connectM or connectB).\n\nThe nodes of the background mesh can be all different from the nodes of connectB or some can be common.\nThey must all have a valid associated size value in the metrics array. The size map (also called metrics map) is\ninterpolated inside the background mesh.\n\nIn the following example, a simple regular background mesh is used to support a sinusoidal metrics map\nvarying in the three directions. The domain to be meshed is a simple cube regularly discretized on its\nboundaries.\n\nTo simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a\ncube centered at the origin.\n\n#include \"stdafx.h\"\n\n// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),\n// with edge length equal to \"L\" and with \"N\" elements along each edge.\nvoid\ncube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)\n\n{\n\nUIntVec indices;\nUIntMat connectE, connectB1, connectB2;\n\nmeshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),\nDoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);\n\nmeshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB2.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB2.push_back(connectB1);\n\nmeshtools::copy_mesh(pos, connectB1, connectB1);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);\nconnectB2.push_back(connectB1);\n\nmeshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\nconnectB.push_back(connectB2);\n\n}\n\nint main()\n\n{\n\n| const double | L(4.), h0(0.5), h1(0.1); |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB1, connectB2, BGM, connectM2; |\n| DoubleVec | sizes; |\n| unsigned | N, N_BGM, n; |\n| double | w, h; |\n| tetramesh_iso::mesher | the_mesher; |\n| tetramesh_iso::mesher::data_type | dataTH; |\n\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n\n// THE BOUNDARY OF THE BACKGROUND MESH\nN_BGM = unsigned(std::max(L/h0, L/h1));\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 28 |\n| --- | --- | --- |\n\n\n# cube_boundary(L, N_BGM, pos, connectB1);\n\n// THE 3D BACKGROUND MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB1;\nthe_mesher.run(dataTH);\ndataTH.extract(pos, BGM);\n\n// THE METRICS ON THE 3D BACKGROUND MESH.\nmeshtools::unique_indices(indices, BGM);\nsizes.resize (pos.cols(), 0.);\nfor (size_t i = 0; i < indices.size(); ++i)\n\n{\n\nn = indices[i];\nw = vecscal::max_norm(pos.col(n));\nh = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;\nsizes[n] = h;\n\n}\n\n// THE BOUNDARY OF THE FINAL MESH.\ncube_boundary(L, N, pos, connectB2);\n\n// THE 3D MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB2;\ndataTH.background_mesh = BGM;\ndataTH.metrics = sizes;\nthe_mesher.run(dataTH);\n\n// MESH VISUALISATION.\n\nmeshtools::clip(dataTH.pos, dataTH.connectM,\nDoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n![image](/image/placeholder)\n\n\nFigure 16 – Use of a background mesh to support a metric map on the domain (mesh cut).\n\nThe background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be\npartially outside of the domain. In the zones not covered by the background mesh, the default interpolation of\nthe sizes from the hard nodes is used instead.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 29 |\n| --- | --- | --- |\n\n\nHere is an example where the domain and the background mesh are both spheres but the latter is half the\nradius of the former. We have set a uniform value for the metric map on the background mesh to get a finer\nmesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still\nconformal.\n\n![image](/image/placeholder)\n\n\nFigure 17 – Background mesh covering only a fraction of the domain (mesh cut).\n\nThe background mesh is a very useful feature to control precisely the size of the elements all over the domain.\nIt can however be time consuming. The finer the background mesh, the longer the meshing process. The\nbackground mesh should be coarse wherever the metric is slowly varying and fine only in the regions where\nthe metric is sharply varying and should be approximated with accuracy.\n\nWe can also consider the case where the boundary surface mesh of the domain must also be governed by\nbackground mesh. Two steps with two different background meshes are required24. First, the surface mesh is\ngenerated with the help of a surface background mesh. An anisotropic mesher supporting the background\nmesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -\nCM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to\ngenerate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final\nadapted 3-D mesh.\n\n☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a\nchanged metrics map (saving a new meshing from scratch).\n\n24 A third kind of background mesh can be needed to generate the line meshes.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 30 |\n| --- | --- | --- |\n\n\n# 10. Anisotropic meshes (CM2 TetraMesh Aniso)\n\nCM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.\nIt’s sometimes useful however to have elements stretched in some special directions. To deal with complex\ndomains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator\nCM2 TetraMesh Aniso.\nCM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This\narray is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define\nthe size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in\nthe metrics array.\n\n![image](/image/placeholder)\nh\nP\n\n![image](/image/placeholder)\n\n\nIsotropic tet\n(size 1 in the isotropic metric h)\n\n![image](/image/placeholder)\nh2\nh0\nP\nh1\n\nAnisotropic tet\n(size 1 in the anisotropic metric M)\n\nFigure 18 – A single scalar defines an isotropic metric (left).\nA 3-D anisotropic metric needs three vectors (right).\n\n3-D anisotropic metrics are defined as below:\n\n![image](/image/placeholder)\n- Chart Type: line\n|  | a | b | c | d |\n| --- | --- | --- | --- | --- |\n| item_01 | 0 | 0 | 0 | 0 |\n\n\nFigure 19 – Definition and storage of the 3-D anisotropic metrics.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 31 |\n| --- | --- | --- |\n\n\nLet (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:\n\n$$\\begin{array}{l}{{\\mathbf{v}_{0}\\lVert=\\lVert\\mathbf{v}_{1}\\rVert=\\lVert\\mathbf{v}_{2}\\rVert=1}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{2}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0}\\times\\mathbf{v}_{1},\\mathbf{v}_{2}\\rfloor=1}}\\end{array}$$\n\nThen, the metric Mj writes:\n\n$$\\begin{array}{c c c}{{}}&{{}}&{{\\left[\\frac{1}{h_{0}^{~2}}~}&{{}}&{{}}&{{0}}\\\\ {{}}&{{}}&{{}}\\\\ {{0~~~~~{\\frac{1}{h_{1}^{~2}}}}}&{{}}\\\\ {{}}&{{}}&{{}}&{{}}\\\\ {{}}&{{}}&{{}}&{{\\displaystyle{\\frac{1}{h_{2}^{~2}}}\\right]}}\\end{array}$$\n\nT B\n\n# B � �v 0 v1 v 2 �\n\nwith:\n\n# stored column � wise\n\nThe h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are\nthe inverse of the square root of the eigen values of metric Mj.\n\nThe 3-D metric equivalent of an isotropic size of h writes:\n\n$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$\n\nA null matrix would lead to infinite sizes in the three directions (infinite sphere).\n\nWhen the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic\ncase we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.\nThis leads to the same default behavior as their related isotropic counterparts. Take the previous examples and\nreplace:\n\ntetramesh_iso::mesher the_mesher;\n\nwith\n\ntetramesh_aniso::mesher the_mesher;\n\nand you get the same output meshes25.\n\n25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 32 |\n| --- | --- | --- |\n\n\nThe following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements\nalong each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic\nmetric. Here, the metric is uniform on all the beam and equals simply:\n\n$$M_{j}=\\left[\\begin{array}{c c c}{{{\\displaystyle{\\left[\\frac{1}{h_{0}^{2}}}}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\displaystyle{{\\frac{1}{h_{0}^{2}}}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\displaystyle{{\\bar{h}_{1}^{2}}}}}\\end{array}\\right]$$\n\nwith:\n\n# h0� �\n\nL0\n\nN 0\n\n# h1� �\n\nL1\n\nN 1\n\nHere, the directions of anisotropy are identical to the global axes X, Y, Z.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 33 |\n| --- | --- | --- |\n\n\n# #include \"stdafx.h\"\n\nint main()\n\n# {{\n\n| const double | L0(10.), L1(100.); |\n| --- | --- |\n| const unsigned | N0(10), N1(10); |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE, connectB1, connectB2, connectB; |\n| UIntMat | connectM, connectM2; |\n| DoubleMat | metrics; |\n| double | D0, D1; |\n\n\n// UNLOCK THE DLL.\ntetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");\n\n// BOUNDARY 2D MESH.\n\nmeshtools2d::extrude_translate(pos, DoubleVec3(0.),\nDoubleVec3(0., L0, 0.), N0, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),\nN0, 2, connectB);\n\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools2d::flip_T3(connectB1);\nmeshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);\nconnectB.push_back(connectB1);\n\nconnectB1.clear();\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),\n\nN1, 2, connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0,0,M_PI/2), connectB2);\nconnectB1.push_back(connectB2);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0., 0., M_PI), connectB2);\nconnectB1.push_back(connectB2);\nconnectB.push_back(connectB1);\n\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n\n// METRICS.\nmetrics.resize(6, pos.cols(), 0.);\n\nD0 = 1. / ((L0 / N0) * (L0 / N0));\nD1 = 1. / ((L1 / N1) * (L1 / N1));\n\nfor (size_t n = 0; n < pos.cols(); ++n)\n\n{\n\n| metrics(0,n) = D0; | // | Mxx |\n| --- | --- | --- |\n| metrics(1,n) = 0.0; | // | Mxy |\n| metrics(2,n) = D0; | // | Myy = Mxx |\n| metrics(3,n) = 0.0; | // | Mxz |\n| metrics(4,n) = 0.0; | // | Myz |\n| metrics(5,n) = D1; | // | Mzz |\n\n\n}\n\n// 3D MESH.\ntetramesh_aniso::mesher the_mesher;\ntetramesh_aniso::mesher::data_type data(pos, connectB);\nthe_mesher.settings.compute_Qh_flag = true;\ndata.metrics = metrics;\nthe_mesher.run(data);\ndata.extract(pos, connectM);\ndata.print_info(&display_hdl);\n\n// MESH VISUALISATION.\nmeshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),\nDoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0\nmeshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);\n\nreturn 0;\n// main\n\n}\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 34 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom).\n\nHere is the output given by data.print_info. Note that the qualities (shape and edge) are computed using\nthe local anisotropic metrics.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23\n\nFigure 21 – Output info. Shape qualities are computed in the anisotropic metrics.\n\n![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\n\nFigure 22 – Edge quality histogram in the anisotropic metrics.\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 36 |\n| --- | --- | --- |\n\n\nIn the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We\nused the following metric map:\n\n![image](/image/placeholder)\n� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�\n\n$$\\mathrm{\\bf{B}}{\\bf{\\tilde{(}}}(r)\\!\\!\\mathrm{\\bf{\\tilde{|}}_{r}}{\\bf{\\tilde{|}}_{l e}}{\\bf{\\tilde{u}}_{\\mathrm{spheric}}\\mathrm{\\basi}_{\\mathrm{\\tilde{l}}}}.$$\n\nwith:\n\n$$h{\\binom{\\alpha}{\\alpha}}=h_{1}{\\frac{\\displaystyle r}{R}}+h_{0}\\Biggl(1-{\\frac{\\displaystyle r}{R}}\\Biggr)$$\n\nRadially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the\nboundary of the sphere.\n\nThe mesher input metric map is only given at the boundary nodes of the external sphere and at the center\nnode. The mesher will do the interpolation in-between.\n\n![image](/image/placeholder)\n\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 37 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 23 – An anisotropic sphere (mesh cut).\n\nBackground meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic\ncounter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid\n(three strictly positive eigen-values).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 38 |\n| --- | --- | --- |\n\n\n# CM2 TetraMesh® Iso\n\n# Version 5.6\n\n# mesh gallery\n\nRevision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\n\n![image](/image/placeholder)\nFigure 1 – Block-stop.\n\n![image](/image/placeholder)\nNodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)\n\nThe output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)\non Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled).\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 40 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 2 – Hammer.\n\n![image](/image/placeholder)\nodes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 41 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\nFigure 3 – Driving Rod.\n\n![image](/image/placeholder)\nNodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 42 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 4 – Blade.\n\n![image](/image/placeholder)\nNodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 5 – Rim.\n\n![image](/image/placeholder)\nNodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 44 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 6 – Crank.\n\n![image](/image/placeholder)\nNodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 45 |\n| --- | --- | --- |\n\n\nhttps://www.computing-objects.com\n\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\n\nLimited Liability Company with a capital of 100 000 €.\nRegistered at Versailles RCS under SIRET number 422 791 038 00033.\nEU VAT registration FR59422791038.", "text": "CM2 TetraMesh® Iso/Aniso\nVersion 5.6\ntutorials\nRevision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\nForewords\nThis manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:\n• The isotropic mesher CM2 TetraMesh® Iso,\n• The anisotropic mesher CM2 TetraMesh® Aniso.\nThese two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and\nthe internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh.\nBased on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality\nelements with smooth grading size according to the length of the boundary elements, to the user-specified\nsizes or to the metric map supported by a background mesh.\nThey can generate very big meshes – several millions of elements – with a limited amount of memory. The\nspeed is near independent of the number of the elements to be generated.\nOption switches can be used to adapt the meshers to the various needs of the user concerning mesh\nrefinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already\nexisting tetrahedral meshes.\nMany data concerning the mesh are available upon exit: histograms of the shape qualities and the size\nqualities, matrix of the neighbors, number of sub-domains, meshed volume...\nLike many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the\nsettings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).\nData are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers.\nFor a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TetraMesh Iso/Aniso - reference manual.\nThe source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and\nIDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.\nThe source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 2 |\n| --- | --- | --- |\n\nTable of contents\nForewords .................................................................................................................................................. 2\n1. Getting started ...................................................................................................................................... 5\nSome declarations .................................................................................................................................................................... 6\nAuthorization of the library .................................................................................................................................................... 6\nBoundary mesh ......................................................................................................................................................................... 7\nTetrahedral mesh ..................................................................................................................................................................... 7\n2. Simple cube ......................................................................................................................................... 10\nSome declarations .................................................................................................................................................................. 11\nBoundary mesh ....................................................................................................................................................................... 11\nTetrahedral mesh ................................................................................................................................................................... 13\n3. Cube with an internal hard line ........................................................................................................ 15\n4. Cube with an internal hard node ..................................................................................................... 18\n5. Internal cavity ..................................................................................................................................... 20\n6. Quadratic elements & high-order nodes ........................................................................................ 23\n7. Multiple meshes ................................................................................................................................. 25\n8. Repairing the boundary mesh .......................................................................................................... 26\n9. Background mesh .............................................................................................................................. 28\n10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31\nMesh gallery ............................................................................................................................................ 39\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 3 |\n| --- | --- | --- |\n\nThis manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options\nof the meshers CM2 TetraMesh® Iso/Aniso.\nEach example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).\nThe general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:\n:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.\nFile stdafx.h:\n// CM2 MESHTOOLS\n| #include \"meshtools.h\" // | General purpose mesh routines. |\n| --- | --- |\n| #include \"meshtools2d.h\" // | To generate 1D meshes. |\n| #include \"meshtools2d.h\" // | To generate 2D meshes. |\n| #include \"tetramesh_iso.h\" // | CM2 TetraMesh Iso. |\n| #include \"tetramesh_aniso.h\" // | CM2 TetraMesh Aniso (Section 10 only). |\n\nusing namespace cm2;\n// Main cm2 namespace can now be omitted.\nRequired libraries1:\n• cm2math1\n• cm2misc\n• cm2meshtools\n• cm2meshtools2d\n• cm2meshtools2d\n• cm2meshtools3d\n• cm2tetramesh_iso\n• cm2tetramesh_aniso (Section 10 only)\n1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.\nOn Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static\narchive), .so or .dylib (dynamic lib).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n\n1. Getting started\nThe simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We\nassume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is\nquite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a\n3xNT matrix2. For each matrix the format is:\nn X m [\nd0,0 d0,1 d0,2 ... d0,m-1\nd1,0 d1,1 d1,2 ... d1,m-1\n...\ndn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]\nFor instance, a mesh with 4 nodes and 2 triangles could write3:\n3 X 4 [\n0. 1. 1. 0.\n0. 0. 1. 1.\n0. 0. 0.5 0. ]\n3 X 2 [\n0 1\n1 2\n3 3 ]\nThe source code to generate the tetrahedral mesh writes:\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }\nint main()\n{\nstd::ifstream istrm(\"part.dat\");\ncm2::tetramesh_iso::mesher the_mesher;\ncm2::tetramesh_iso::mesher::data_type data;\n// UNLOCK THE DLL.\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH.\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);\n// GENERATE THE 3D MESH.\nthe_mesher.run(data);\n// SOME OUTPUT INFO (OPTIONAL).\ndata.print_info(&display_hdl);\n// VISUALISATION (OPTIONAL).\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\nreturn 0;\n// main\n}\n2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.\n3 The format for each value is free.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 5 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\nFigure 1 – A simple mechanical part.\nLet us explain this program line by line.\nSome declarations\nA standard input stream istrm is built with the data file name part.dat. We create then an instance of the\ntet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the\nnodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB\nand final tet mesh in data.connectM).\nMatrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and\ndata.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This\ninteger refers to the column number in matrix data.pos where the coordinates of this node can be found5.\nAuthorization of the library\nThe tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two\nstrings must be provided for each library: the name of your company or organization that has acquired the\nlicense and a secret code6. Note that both strings are case sensitive and the registration call must be made\neach time the library is loaded into memory and before any run of the mesher.\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n4 See manual CM2 Math1 - overview.\n5 Recall that array indices are zero based (from 0 to N-1).\n6 Contact license@computing-objects.com for any licensing inquiry.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 6 |\n| --- | --- | --- |\n\nBoundary mesh\nThe cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.\nWe use it to load the nodes’ coordinates and the triangle connectivity from the same file.\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);\nTetrahedral mesh\nthe_mesher.run(data);\nUpon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the\ntetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary\nmesh are left untouched in the first columns.\nThe connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of\nthe nodes for an element. connectM(i, j) is the ith local node of the jth element.\nOutput information\nPrinted information about the generated mesh and a MEDIT8 output file are obtained with:\ndata.print_info(&display_hdl);\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\nFigure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of\n2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces\nand hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9.\nThe first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the\nsecond step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the\nlast step concerns geometrical and topological optimizations to improve the quality of the elements.\nThe formula used to compute the shape quality of a tetrahedron is given by:\n| V | V Volume of the tetrahedron. |\n| --- | --- |\n| Qs 6� 6 Lmax S | with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron. |\n\n7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:\n:transpose_read function exists to read a matrix and transpose it on the fly.\n8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),\nVTK and Wavefront OBJ.\n9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-\nthreading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®\nAniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased\nfurther by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 7 |\n| --- | --- | --- |\n\nThis quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet).\nOn the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2).\nNote that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There\nis an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator\ncannot produce a mesh with a minimum quality better than 0.56 in this case.\nThe size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the\nedge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always\npositive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it\nshould be.\nThe formula used to compute the length quality of an edge AB writes:\nhA ���\n ln ��� � �\n hB\n ABQh � LAB\n hA � hB\nwith:\nLAB Actual length of edge AB.\nhA Target size at node A (expected edge length at A).\nhB Target size at node B (expected edge length at B).\nLet’s introduce also at this point the h-shock measure of an edge:\n1\n hA hB Q h\n AB\n , ���\n hs AB � min ��� hB hA\n � 1\n �\n �\nThese two measure are dimensionless and positive.\nLAB\nWhen hA = hB the h-shock is null and the length writes hQ AB � .\nhA\nWhen ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB.\nTo optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.\nThe mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.\nsettings.compute_Qh_flag10 is set to true11.\nOn this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance\n(Figure 3).\n10 See reference manual for details on the settings of the meshers.\n11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74\nFigure 2 – Output info for the “mechanical part” example.\n![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0\nFigure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 9 |\n| --- | --- | --- |\n\n2. Simple cube\nThis second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.\nThis will also help introduce some options of CM2 TetraMesh Iso in following examples.\nThe following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):\n#include \"stdafx.h\"\n#include <iostream>\n// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }\nint main()\n{\n| const unsigned | N(6); | // The discretization along each edge. |\n| --- | --- | --- |\n| const double | L(4.); | // The sides length. |\n| DoubleMat | pos; |  |\n| UIntMat | connectE, | connectB, connectB1, connectB2; |\n| UIntVec | indices; |  |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n// VISUALISATION (OPTIONAL).\ndata.print_info(&display_hdl);\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\nreturn 0;\n} // main\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 10 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\nFigure 4 – Simple cube.\nLet us again explain this program line by line.\nMost of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only\nthree lines in the program.\nSome declarations\nMatrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the\nfinal mesh (many of them are in both).\nMatrix connectB stores the connectivity matrix of the boundary triangle mesh.\nMatrices connectB1, connectB2 and connectE are temporaries as well as vector indices.\nBoundary mesh\nIn this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to\ngenerate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher\nneeds this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix\nconnectB of connectivity of the boundary triangles.\nWe choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of\nthe cube.\nThe first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):\nmeshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 11 |\n| --- | --- | --- |\n\nThis generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos\nmatrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This\nvector contains upon exit of this function (N = 6):\n[0 1 2 3 4 5 6]\nAnd the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).\nThe vector of indices is used to create the connectivity matrix of the first edge mesh:\nmeshtools2d::indices_to_connectE2(indices, connectE);\nconnectE is now a 2x6 matrix:\n2x6 [0 1 2 3 4 5\n1 2 3 4 5 6]\nThis line mesh is then extruded into a mesh of triangles along vector (0, L, 0):\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);\nThe 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”\npattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to\nmatrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix\nconnectB as new columns of indices of nodes.\nWe now have to copy and rotate this mesh:\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\nAfter the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix\npos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),\nY}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB.\n12 Several variants of this function are available in the meshtools2d library and are described in the API.\n13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and\ncopies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 12 |\n| --- | --- | --- |\n\nThe two faces together are then copied and rotated twice in order to generate the other four missing faces of\nthe cube:\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nAt this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.\nHowever, some points are coincident and need to be merged together:\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\nThis function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the\nindex of the first node encountered replaces all the others subsequent coincident nodes14.\nTetrahedral mesh\nNow we have generated the boundary mesh, we can call the 3-D mesher on it:\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\nThe difference with the previous example is that matrices pos and connect are built first and then passed to\nthe data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.\nThere is no significant difference between the two approaches. We can either modify directly data.pos and\ndata.connectB or build some separated matrices pos and connect and then pass them to the data\nconstructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -\noverview.\nUpon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the\ntetrahedral mesher on top of the initial surface points.\n14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify.\n15 But the pos matrix still has 294 columns.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 13 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58\nFigure 5 – Output info for the cube example.\n![image](/image/placeholder)\n************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\nFigure 6 – Histogram of the size-qualities of all the edges in the cube example.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 14 |\n| --- | --- | --- |\n\n3. Cube with an internal hard line\nStarting from the previous example, we add a hard line inside the cube:\n#include \"stdafx.h\"\nint main()\n{\n| const unsigned | N(6); // The discretization along each edge. |\n| --- | --- |\n| const double | L(4.); // The sides length. |\n| DoubleMat | pos; |\n| UIntMat | connectE, connectB, connectB1, connectB2, connectM2; |\n| UIntVec | indices; |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nindices.clear(); connectE.clear();\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.connectE = connectE;\nthe_mesher.run(data);\n// MESH VISUALIZATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\nreturn 0;\n// main\n}\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 15 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 7 – Half cube with internal line (mesh cut).\nThe mesh of the internal line is generated like the mesh of the first edge of the cube:\nmeshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nThis mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh\nis four times finer along this line than on the cube edges, in order to make the line more visible and also to get\na graded mesh size.\nTo avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two\nmatching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary\nmesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is\ndone concurrently with the merging of the nodes of the edges of the cube already discussed in the previous\nsection:\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);\nThe new internal prescribed edges are given to the mesher with:\n![image](/image/placeholder)\ndata.connectE = connectE;\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 16 |\n| --- | --- | --- |\n\nTo visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets\nwith at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.\npos, or on the connectivity matrix of the full mesh data.connectM:\nmeshtools::clip\n(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\nTo constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface\nmesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard\nfaces into the matrix data.connectB for instance with a push-back (see next example).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 17 |\n| --- | --- | --- |\n\n4. Cube with an internal hard node\nThere are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with\ndifferent or varying size on the boundary and interior surface or line, like in the previous example. The mesher\ncomputes a size value on each hard node16, interpolates these values inside the domain and generates\nelements accordingly.\nA second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all\nthe hard nodes. This is explained in this section.\nSo far, we have seen only four fields of the data structure used by the mesher:\n• The pos matrix for the coordinates of the points.\n• The connectB matrix for the connectivity of the hard faces.\n• The connectE matrix for the connectivity of the hard edges (seen in Example 2).\n• The connectM matrix for the connectivity of the output 3-D mesh.\nIn this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target\nsize for the elements near this node. This is done using two new fields: isolated_nodes and metrics:\n#include \"stdafx.h\"\nint main()\n{\n| const unsigned | N(6); |\n| --- | --- |\n| const double | L(4.); |\n| DoubleMat | pos(3, 1, L/2.); |\n| UIntMat | connectB, connectB1, connectB2, connectE, connectM2; |\n| UIntVec | indices; |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// BOUNDARY 2D MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,\nindices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,\nconnectB);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.isolated_nodes.push_back(0);\ndata.metrics.resize(1, 0.05*L/N);\nthe_mesher.run(data);\n// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\nreturn 0;\n} // main\nInitializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into\naccount by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 18 |\n| --- | --- | --- |\n\ndata.isolated_nodes.push_back(0);\nThe vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or\nnegative or not present), the automatically computed value will be used instead18. In this example the vector is\nresized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:\ndata.metrics.resize(1, 0.05*L/N);\nFor all the other nodes, we let the mesher compute suitable values.\n![image](/image/placeholder)\n\nFigure 8 – Half cube with internal hard node (mesh cut).\n16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.\n17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));\n18 For an isolated node, the computed size is based on the values of the nearest nodes.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n\n5. Internal cavity\nA cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This\nimplies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we\nhave the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1.\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\n| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n// MESH VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);\nreturn 0;\n// main\n}\n![image](/image/placeholder)\nFigure 9 – Full sphere.\nThe surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing\nthe orientation of the triangles:\n19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 20 |\n| --- | --- | --- |\n\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\n| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB, connectB2, connectM2; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// OUTER BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\n// INNER BOUNDARY.\nmeshtools::copy_mesh(pos, connectB2, connectB);\nmeshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);\nmeshtools2d::flip_T3(connectB2); // Reverse the orientation.\nconnectB.push_back(connectB2);\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);\n// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\nreturn 0;\n// main\n}\n![image](/image/placeholder)\n\nFigure 10 – Hollow sphere (mesh cut).\nNote that the matrix connectB contains both the external and the internal faces.\nNested shells can be generated simply by changing the orientation of the spheres:\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 21 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 11 – Nested shells (mesh cut).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 22 |\n| --- | --- | --- |\n\n6. Quadratic elements & high-order nodes\nLet us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here\nagain that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6\nelements can be curved or not.\n![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm(\"sphere_t6.dat\");\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main\nThe mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,\nwe have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the\nabove example (view to the first 3 rows from index 0, 0)20.\nAfter the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM);\nBut in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an\noverload function with additional matrix parameters:\nmeshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());\nThis forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match\n(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of\nthe tetrahedrons in data.connectM).\n20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension).\n21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_\norder. Refer to the HTML reference manual for detailed information.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 23 |\n| --- | --- | --- |\n\nThe connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the\nlinear faces)22.\nLinear nodes\n| 0 | 1 | 2 | 5 | 5 | 1 | 3 | 4 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 3 | 3 | 2 | 0 | 6 | 6 | 3 |\n| 2 | 2 | 4 | 4 | 2 | 3 | 7 | 7 |\n| 8 | 11 | 13 | 14 | 9 | 18 | 20 | 21 |\n| 9 | 8 | 14 | 15 | 16 | 12 | 21 | 22 |\n| 10 | 12 | 11 | 16 | 17 | 19 | 18 | 13 |\n\nFigure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3).\nThe connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_\nquadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons).\n22 The empty matrix parameter stands for specific high-order edges. Here none of them.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 24 |\n| --- | --- | --- |\n\n7. Multiple meshes\nAs seen before, matrix connectB can contain several internal surfaces. It can also contain several external\nboundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the\nprevious example, some care must be taken in the orientation of these surfaces. They must be oriented the\nsame way (for instance all normal outside) and these boundaries must not cross each other.\n![image](/image/placeholder)\n\nFigure 13 – Multiple disconnected sub-domains.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 25 |\n| --- | --- | --- |\n\n8. Repairing the boundary mesh\nIt is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not\nwatertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes.\nCM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23.\nTo illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple\nextrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some\nnodes are also coincident.\n![image](/image/placeholder)\nFigure 14 – Intersecting meshes.\nIn strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,\nthey remove the intersecting and overlapping triangles and fill all the gaps.\n23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 26 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 15 – Repaired mesh.\nNote that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry\nof the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by\nadding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 27 |\n| --- | --- | --- |\n\n9. Background mesh\nSometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.\nThe background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher.\nAs always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices\nor vectors (such as connectM or connectB).\nThe nodes of the background mesh can be all different from the nodes of connectB or some can be common.\nThey must all have a valid associated size value in the metrics array. The size map (also called metrics map) is\ninterpolated inside the background mesh.\nIn the following example, a simple regular background mesh is used to support a sinusoidal metrics map\nvarying in the three directions. The domain to be meshed is a simple cube regularly discretized on its\nboundaries.\nTo simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a\ncube centered at the origin.\n#include \"stdafx.h\"\n// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),\n// with edge length equal to \"L\" and with \"N\" elements along each edge.\nvoid\ncube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)\n{\nUIntVec indices;\nUIntMat connectE, connectB1, connectB2;\nmeshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),\nDoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);\nmeshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB2.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB2.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB1, connectB1);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);\nconnectB2.push_back(connectB1);\nmeshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\nconnectB.push_back(connectB2);\n}\nint main()\n{\n| const double | L(4.), h0(0.5), h1(0.1); |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB1, connectB2, BGM, connectM2; |\n| DoubleVec | sizes; |\n| unsigned | N, N_BGM, n; |\n| double | w, h; |\n| tetramesh_iso::mesher | the_mesher; |\n| tetramesh_iso::mesher::data_type | dataTH; |\n\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// THE BOUNDARY OF THE BACKGROUND MESH\nN_BGM = unsigned(std::max(L/h0, L/h1));\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 28 |\n| --- | --- | --- |\n\ncube_boundary(L, N_BGM, pos, connectB1);\n// THE 3D BACKGROUND MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB1;\nthe_mesher.run(dataTH);\ndataTH.extract(pos, BGM);\n// THE METRICS ON THE 3D BACKGROUND MESH.\nmeshtools::unique_indices(indices, BGM);\nsizes.resize (pos.cols(), 0.);\nfor (size_t i = 0; i < indices.size(); ++i)\n{\nn = indices[i];\nw = vecscal::max_norm(pos.col(n));\nh = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;\nsizes[n] = h;\n}\n// THE BOUNDARY OF THE FINAL MESH.\ncube_boundary(L, N, pos, connectB2);\n// THE 3D MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB2;\ndataTH.background_mesh = BGM;\ndataTH.metrics = sizes;\nthe_mesher.run(dataTH);\n// MESH VISUALISATION.\nmeshtools::clip(dataTH.pos, dataTH.connectM,\nDoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);\nreturn 0;\n// main\n}\n![image](/image/placeholder)\n\nFigure 16 – Use of a background mesh to support a metric map on the domain (mesh cut).\nThe background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be\npartially outside of the domain. In the zones not covered by the background mesh, the default interpolation of\nthe sizes from the hard nodes is used instead.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 29 |\n| --- | --- | --- |\n\nHere is an example where the domain and the background mesh are both spheres but the latter is half the\nradius of the former. We have set a uniform value for the metric map on the background mesh to get a finer\nmesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still\nconformal.\n![image](/image/placeholder)\n\nFigure 17 – Background mesh covering only a fraction of the domain (mesh cut).\nThe background mesh is a very useful feature to control precisely the size of the elements all over the domain.\nIt can however be time consuming. The finer the background mesh, the longer the meshing process. The\nbackground mesh should be coarse wherever the metric is slowly varying and fine only in the regions where\nthe metric is sharply varying and should be approximated with accuracy.\nWe can also consider the case where the boundary surface mesh of the domain must also be governed by\nbackground mesh. Two steps with two different background meshes are required24. First, the surface mesh is\ngenerated with the help of a surface background mesh. An anisotropic mesher supporting the background\nmesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -\nCM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to\ngenerate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final\nadapted 3-D mesh.\n☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a\nchanged metrics map (saving a new meshing from scratch).\n24 A third kind of background mesh can be needed to generate the line meshes.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 30 |\n| --- | --- | --- |\n\n10. Anisotropic meshes (CM2 TetraMesh Aniso)\nCM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.\nIt’s sometimes useful however to have elements stretched in some special directions. To deal with complex\ndomains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator\nCM2 TetraMesh Aniso.\nCM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This\narray is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define\nthe size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in\nthe metrics array.\n![image](/image/placeholder)\nh\nP\n![image](/image/placeholder)\n\nIsotropic tet\n(size 1 in the isotropic metric h)\n![image](/image/placeholder)\nh2\nh0\nP\nh1\nAnisotropic tet\n(size 1 in the anisotropic metric M)\nFigure 18 – A single scalar defines an isotropic metric (left).\nA 3-D anisotropic metric needs three vectors (right).\n3-D anisotropic metrics are defined as below:\n![image](/image/placeholder)\n- Chart Type: line\n|  | a | b | c | d |\n| --- | --- | --- | --- | --- |\n| item_01 | 0 | 0 | 0 | 0 |\n\nFigure 19 – Definition and storage of the 3-D anisotropic metrics.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 31 |\n| --- | --- | --- |\n\nLet (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:\nv 0 � v1 � v 2 � 1\n v 0 , v1 0\n v 0 , v 2 ��� 0\n v1 , v 2 0\n v 0 � v1 , v 2 � 1\nThen, the metric Mj writes:\n� 1 �\n 0 0 �������\n 2\n h 0\n 1\n M j� ��B ������� 0 0\n 2\n h 1\n 1\n 0 0\n 2\n � h 2 �\nT B\nB � �v 0 v1 v 2 �\nwith:\nstored column � wise\nThe h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are\nthe inverse of the square root of the eigen values of metric Mj.\nThe 3-D metric equivalent of an isotropic size of h writes:\n� 1 �\n 0 0\n h 2 ������\n 1\n M j � ������ 0 0\n h 2\n 1\n 0 0\n �\n � h 2\nA null matrix would lead to infinite sizes in the three directions (infinite sphere).\nWhen the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic\ncase we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.\nThis leads to the same default behavior as their related isotropic counterparts. Take the previous examples and\nreplace:\ntetramesh_iso::mesher the_mesher;\nwith\ntetramesh_aniso::mesher the_mesher;\nand you get the same output meshes25.\n25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 32 |\n| --- | --- | --- |\n\nThe following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements\nalong each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic\nmetric. Here, the metric is uniform on all the beam and equals simply:\n1 ��������\n 0 0\n 2\n h 0\n 1\n M j � �������� 0 0\n 2\n h 0\n 1\n 0 0\n 2h1 �\n �\nwith:\nh0� �\nL0\nN 0\nh1� �\nL1\nN 1\nHere, the directions of anisotropy are identical to the global axes X, Y, Z.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 33 |\n| --- | --- | --- |\n\n#include \"stdafx.h\"\nint main()\n{{\n| const double | L0(10.), L1(100.); |\n| --- | --- |\n| const unsigned | N0(10), N1(10); |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE, connectB1, connectB2, connectB; |\n| UIntMat | connectM, connectM2; |\n| DoubleMat | metrics; |\n| double | D0, D1; |\n\n// UNLOCK THE DLL.\ntetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");\n// BOUNDARY 2D MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0.),\nDoubleVec3(0., L0, 0.), N0, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),\nN0, 2, connectB);\nmeshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools2d::flip_T3(connectB1);\nmeshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);\nconnectB.push_back(connectB1);\nconnectB1.clear();\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),\nN1, 2, connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0,0,M_PI/2), connectB2);\nconnectB1.push_back(connectB2);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0., 0., M_PI), connectB2);\nconnectB1.push_back(connectB2);\nconnectB.push_back(connectB1);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\n// METRICS.\nmetrics.resize(6, pos.cols(), 0.);\nD0 = 1. / ((L0 / N0) * (L0 / N0));\nD1 = 1. / ((L1 / N1) * (L1 / N1));\nfor (size_t n = 0; n < pos.cols(); ++n)\n{\n| metrics(0,n) = D0; | // | Mxx |\n| --- | --- | --- |\n| metrics(1,n) = 0.0; | // | Mxy |\n| metrics(2,n) = D0; | // | Myy = Mxx |\n| metrics(3,n) = 0.0; | // | Mxz |\n| metrics(4,n) = 0.0; | // | Myz |\n| metrics(5,n) = D1; | // | Mzz |\n\n}\n// 3D MESH.\ntetramesh_aniso::mesher the_mesher;\ntetramesh_aniso::mesher::data_type data(pos, connectB);\nthe_mesher.settings.compute_Qh_flag = true;\ndata.metrics = metrics;\nthe_mesher.run(data);\ndata.extract(pos, connectM);\ndata.print_info(&display_hdl);\n// MESH VISUALISATION.\nmeshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),\nDoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0\nmeshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);\nreturn 0;\n// main\n}\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 34 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom).\nHere is the output given by data.print_info. Note that the qualities (shape and edge) are computed using\nthe local anisotropic metrics.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23\nFigure 21 – Output info. Shape qualities are computed in the anisotropic metrics.\n![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\nFigure 22 – Edge quality histogram in the anisotropic metrics.\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 36 |\n| --- | --- | --- |\n\nIn the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We\nused the following metric map:\n![image](/image/placeholder)\n� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�\nB�r������� ur �r�� v θ �r�� w � �r���\n the local spheric basis.\nwith:\nr �\n h�r�� � h1 Rr � h0 ��� 1 � ��\n R\nRadially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the\nboundary of the sphere.\nThe mesher input metric map is only given at the boundary nodes of the external sphere and at the center\nnode. The mesher will do the interpolation in-between.\n![image](/image/placeholder)\n\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 37 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 23 – An anisotropic sphere (mesh cut).\nBackground meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic\ncounter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid\n(three strictly positive eigen-values).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 38 |\n| --- | --- | --- |\n\nCM2 TetraMesh® Iso\nVersion 5.6\nmesh gallery\nRevision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\n![image](/image/placeholder)\nFigure 1 – Block-stop.\n![image](/image/placeholder)\nNodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)\nThe output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)\non Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled).\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 40 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 2 – Hammer.\n![image](/image/placeholder)\nodes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 41 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\nFigure 3 – Driving Rod.\n![image](/image/placeholder)\nNodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 42 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 4 – Blade.\n![image](/image/placeholder)\nNodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 5 – Rim.\n![image](/image/placeholder)\nNodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 44 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\nFigure 6 – Crank.\n![image](/image/placeholder)\nNodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)\n| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 45 |\n| --- | --- | --- |\n\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.\nLimited Liability Company with a capital of 100 000 €.\nRegistered at Versailles RCS under SIRET number 422 791 038 00033.\nEU VAT registration FR59422791038."}, "elements": [{"category": "heading1", "content": {"html": "<h1 id='0' style='font-size:20px'>CM2 TetraMesh® Iso/Aniso</h1>", "markdown": "# CM2 TetraMesh® Iso/Aniso", "text": "CM2 TetraMesh® Iso/Aniso"}, "coordinates": [{"x": 0.0987, "y": 0.6985}, {"x": 0.7666, "y": 0.6985}, {"x": 0.7666, "y": 0.7382}, {"x": 0.0987, "y": 0.7382}], "id": 0, "page": 1}, {"category": "heading1", "content": {"html": "<br><h1 id='1' style='font-size:16px'>Version 5.6</h1>", "markdown": "# Version 5.6", "text": "Version 5.6"}, "coordinates": [{"x": 0.0996, "y": 0.7412}, {"x": 0.2294, "y": 0.7412}, {"x": 0.2294, "y": 0.7615}, {"x": 0.0996, "y": 0.7615}], "id": 1, "page": 1}, {"category": "paragraph", "content": {"html": "<p id='2' data-category='paragraph' style='font-size:18px'>tutorials</p>", "markdown": "tutorials", "text": "tutorials"}, "coordinates": [{"x": 0.1, "y": 0.7942}, {"x": 0.2596, "y": 0.7942}, {"x": 0.2596, "y": 0.8211}, {"x": 0.1, "y": 0.8211}], "id": 2, "page": 1}, {"category": "paragraph", "content": {"html": "<p id='3' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>", "markdown": "Revision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.", "text": "Revision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France."}, "coordinates": [{"x": 0.1002, "y": 0.9231}, {"x": 0.5964, "y": 0.9231}, {"x": 0.5964, "y": 0.9769}, {"x": 0.1002, "y": 0.9769}], "id": 3, "page": 1}, {"category": "heading1", "content": {"html": "<h1 id='4' style='font-size:20px'>Forewords</h1>", "markdown": "# Forewords", "text": "Forewords"}, "coordinates": [{"x": 0.0785, "y": 0.0645}, {"x": 0.2317, "y": 0.0645}, {"x": 0.2317, "y": 0.0866}, {"x": 0.0785, "y": 0.0866}], "id": 4, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='5' data-category='paragraph' style='font-size:16px'>This manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:</p>", "markdown": "This manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:", "text": "This manual is a tutorial for the solid tetrahedron mesh generators of the CM2 MeshTools® SDK:"}, "coordinates": [{"x": 0.0743, "y": 0.1245}, {"x": 0.8056, "y": 0.1245}, {"x": 0.8056, "y": 0.1414}, {"x": 0.0743, "y": 0.1414}], "id": 5, "page": 2}, {"category": "list", "content": {"html": "<br><p id='6' data-category='list' style='font-size:16px'>• The isotropic mesher CM2 TetraMesh® Iso,<br>• The anisotropic mesher CM2 TetraMesh® Aniso.</p>", "markdown": "- • The isotropic mesher CM2 TetraMesh® Iso,\n- • The anisotropic mesher CM2 TetraMesh® Aniso.\n", "text": "• The isotropic mesher CM2 TetraMesh® Iso,\n• The anisotropic mesher CM2 TetraMesh® Aniso."}, "coordinates": [{"x": 0.0846, "y": 0.1517}, {"x": 0.4663, "y": 0.1517}, {"x": 0.4663, "y": 0.1837}, {"x": 0.0846, "y": 0.1837}], "id": 6, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='7' data-category='paragraph' style='font-size:16px'>These two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and<br>the internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh.</p>", "markdown": "These two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and\nthe internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh.", "text": "These two tools are constrained unstructured meshers: the boundary mesh (i.e. the triangle surface mesh), and\nthe internal hard faces, hard edges and hard points if any, are kept (if possible) unmodified in the final mesh."}, "coordinates": [{"x": 0.0761, "y": 0.1944}, {"x": 0.9196, "y": 0.1944}, {"x": 0.9196, "y": 0.2245}, {"x": 0.0761, "y": 0.2245}], "id": 7, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='8' data-category='paragraph' style='font-size:16px'>Based on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality<br>elements with smooth grading size according to the length of the boundary elements, to the user-specified<br>sizes or to the metric map supported by a background mesh.</p>", "markdown": "Based on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality\nelements with smooth grading size according to the length of the boundary elements, to the user-specified\nsizes or to the metric map supported by a background mesh.", "text": "Based on a fast and robust hybrid \"advancing-front\" and Delaunay algorithm, they generate high quality\nelements with smooth grading size according to the length of the boundary elements, to the user-specified\nsizes or to the metric map supported by a background mesh."}, "coordinates": [{"x": 0.0773, "y": 0.2346}, {"x": 0.8882, "y": 0.2346}, {"x": 0.8882, "y": 0.2791}, {"x": 0.0773, "y": 0.2791}], "id": 8, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='9' data-category='paragraph' style='font-size:16px'>They can generate very big meshes – several millions of elements – with a limited amount of memory. The<br>speed is near independent of the number of the elements to be generated.</p>", "markdown": "They can generate very big meshes – several millions of elements – with a limited amount of memory. The\nspeed is near independent of the number of the elements to be generated.", "text": "They can generate very big meshes – several millions of elements – with a limited amount of memory. The\nspeed is near independent of the number of the elements to be generated."}, "coordinates": [{"x": 0.0763, "y": 0.2892}, {"x": 0.8775, "y": 0.2892}, {"x": 0.8775, "y": 0.3194}, {"x": 0.0763, "y": 0.3194}], "id": 9, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='10' data-category='paragraph' style='font-size:16px'>Option switches can be used to adapt the meshers to the various needs of the user concerning mesh<br>refinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already<br>existing tetrahedral meshes.</p>", "markdown": "Option switches can be used to adapt the meshers to the various needs of the user concerning mesh\nrefinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already\nexisting tetrahedral meshes.", "text": "Option switches can be used to adapt the meshers to the various needs of the user concerning mesh\nrefinement and optimization. In this regard, the meshers can also be used as mere optimizers of some already\nexisting tetrahedral meshes."}, "coordinates": [{"x": 0.0775, "y": 0.3299}, {"x": 0.9144, "y": 0.3299}, {"x": 0.9144, "y": 0.3736}, {"x": 0.0775, "y": 0.3736}], "id": 10, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='11' data-category='paragraph' style='font-size:16px'>Many data concerning the mesh are available upon exit: histograms of the shape qualities and the size<br>qualities, matrix of the neighbors, number of sub-domains, meshed volume...</p>", "markdown": "Many data concerning the mesh are available upon exit: histograms of the shape qualities and the size\nqualities, matrix of the neighbors, number of sub-domains, meshed volume...", "text": "Many data concerning the mesh are available upon exit: histograms of the shape qualities and the size\nqualities, matrix of the neighbors, number of sub-domains, meshed volume..."}, "coordinates": [{"x": 0.0768, "y": 0.3844}, {"x": 0.8541, "y": 0.3844}, {"x": 0.8541, "y": 0.4143}, {"x": 0.0768, "y": 0.4143}], "id": 11, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='12' data-category='paragraph' style='font-size:16px'>Like many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the<br>settings the maximum number of threads the generator can use).<br>The generated meshes are reproducible (same mesh with same input data and same mesh with any number of<br>threads).</p>", "markdown": "Like many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the\nsettings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).", "text": "Like many other meshers of the library, CM2 TetraMesh Iso/Aniso are multi-threaded (you can select in the\nsettings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads)."}, "coordinates": [{"x": 0.0772, "y": 0.4247}, {"x": 0.9217, "y": 0.4247}, {"x": 0.9217, "y": 0.4818}, {"x": 0.0772, "y": 0.4818}], "id": 12, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='13' data-category='paragraph' style='font-size:16px'>Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners<br>should start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers.</p>", "markdown": "Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers.", "text": "Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the manual CM2 Math1 - overview to get first views on these mathematical containers."}, "coordinates": [{"x": 0.0777, "y": 0.4937}, {"x": 0.9144, "y": 0.4937}, {"x": 0.9144, "y": 0.524}, {"x": 0.0777, "y": 0.524}], "id": 13, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='14' data-category='paragraph' style='font-size:16px'>For a complete description of the data and settings structures used with these meshers please refer to the<br>CM2 TetraMesh Iso/Aniso - reference manual.</p>", "markdown": "For a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TetraMesh Iso/Aniso - reference manual.", "text": "For a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TetraMesh Iso/Aniso - reference manual."}, "coordinates": [{"x": 0.0778, "y": 0.5342}, {"x": 0.8875, "y": 0.5342}, {"x": 0.8875, "y": 0.5644}, {"x": 0.0778, "y": 0.5644}], "id": 14, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='15' data-category='paragraph' style='font-size:16px'>The source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit<br>number IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and<br>IDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.</p>", "markdown": "The source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and\nIDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.", "text": "The source code of the CM2 MeshTools® (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001.260002.00.R.P.1998.000.20700 (22/06/1998) and\nIDDN.FR.001.480030.006.S.P.2001.000.20700 (23/05/2019) is regularly deposited since then."}, "coordinates": [{"x": 0.0753, "y": 0.8035}, {"x": 0.8853, "y": 0.8035}, {"x": 0.8853, "y": 0.8487}, {"x": 0.0753, "y": 0.8487}], "id": 15, "page": 2}, {"category": "paragraph", "content": {"html": "<br><p id='16' data-category='paragraph' style='font-size:16px'>The source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly<br>deposited since then.</p>", "markdown": "The source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.", "text": "The source code specific to CM2 TetraMesh® Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440019.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then."}, "coordinates": [{"x": 0.0771, "y": 0.8586}, {"x": 0.9239, "y": 0.8586}, {"x": 0.9239, "y": 0.9035}, {"x": 0.0771, "y": 0.9035}], "id": 16, "page": 2}, {"category": "table", "content": {"html": "<table id='17' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>2</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 2 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 2 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0105, "y": 0.9481}, {"x": 0.9994, "y": 0.9481}, {"x": 0.9994, "y": 1}, {"x": 0.0105, "y": 1}], "id": 17, "page": 2}, {"category": "heading1", "content": {"html": "<h1 id='18' style='font-size:20px'>Table of contents</h1>", "markdown": "# Table of contents", "text": "Table of contents"}, "coordinates": [{"x": 0.076, "y": 0.0619}, {"x": 0.3227, "y": 0.0619}, {"x": 0.3227, "y": 0.0887}, {"x": 0.076, "y": 0.0887}], "id": 18, "page": 3}, {"category": "index", "content": {"html": "<p id='19' data-category='index' style='font-size:16px'>Forewords .................................................................................................................................................. 2<br>1. Getting started ...................................................................................................................................... 5<br>Some declarations .................................................................................................................................................................... 6<br>Authorization of the library .................................................................................................................................................... 6<br>Boundary mesh ......................................................................................................................................................................... 7<br>Tetrahedral mesh ..................................................................................................................................................................... 7<br>2. Simple cube ......................................................................................................................................... 10<br>Some declarations .................................................................................................................................................................. 11<br>Boundary mesh ....................................................................................................................................................................... 11<br>Tetrahedral mesh ................................................................................................................................................................... 13<br>3. Cube with an internal hard line ........................................................................................................ 15<br>4. Cube with an internal hard node ..................................................................................................... 18<br>5. Internal cavity ..................................................................................................................................... 20<br>6. Quadratic elements & high-order nodes ........................................................................................ 23<br>7. Multiple meshes ................................................................................................................................. 25<br>8. Repairing the boundary mesh .......................................................................................................... 26<br>9. Background mesh .............................................................................................................................. 28<br>10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31<br>Mesh gallery ............................................................................................................................................ 39</p>", "markdown": "Forewords .................................................................................................................................................. 2\n1. Getting started ...................................................................................................................................... 5\nSome declarations .................................................................................................................................................................... 6\nAuthorization of the library .................................................................................................................................................... 6\nBoundary mesh ......................................................................................................................................................................... 7\nTetrahedral mesh ..................................................................................................................................................................... 7\n2. Simple cube ......................................................................................................................................... 10\nSome declarations .................................................................................................................................................................. 11\nBoundary mesh ....................................................................................................................................................................... 11\nTetrahedral mesh ................................................................................................................................................................... 13\n3. Cube with an internal hard line ........................................................................................................ 15\n4. Cube with an internal hard node ..................................................................................................... 18\n5. Internal cavity ..................................................................................................................................... 20\n6. Quadratic elements & high-order nodes ........................................................................................ 23\n7. Multiple meshes ................................................................................................................................. 25\n8. Repairing the boundary mesh .......................................................................................................... 26\n9. Background mesh .............................................................................................................................. 28\n10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31\nMesh gallery ............................................................................................................................................ 39", "text": "Forewords .................................................................................................................................................. 2\n1. Getting started ...................................................................................................................................... 5\nSome declarations .................................................................................................................................................................... 6\nAuthorization of the library .................................................................................................................................................... 6\nBoundary mesh ......................................................................................................................................................................... 7\nTetrahedral mesh ..................................................................................................................................................................... 7\n2. Simple cube ......................................................................................................................................... 10\nSome declarations .................................................................................................................................................................. 11\nBoundary mesh ....................................................................................................................................................................... 11\nTetrahedral mesh ................................................................................................................................................................... 13\n3. Cube with an internal hard line ........................................................................................................ 15\n4. Cube with an internal hard node ..................................................................................................... 18\n5. Internal cavity ..................................................................................................................................... 20\n6. Quadratic elements & high-order nodes ........................................................................................ 23\n7. Multiple meshes ................................................................................................................................. 25\n8. Repairing the boundary mesh .......................................................................................................... 26\n9. Background mesh .............................................................................................................................. 28\n10. Anisotropic meshes (CM2 TetraMesh Aniso) ................................................................................ 31\nMesh gallery ............................................................................................................................................ 39"}, "coordinates": [{"x": 0.0638, "y": 0.1935}, {"x": 0.9305, "y": 0.1935}, {"x": 0.9305, "y": 0.6709}, {"x": 0.0638, "y": 0.6709}], "id": 19, "page": 3}, {"category": "table", "content": {"html": "<table id='20' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>3</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 3 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 3 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0027, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0027, "y": 1}], "id": 20, "page": 3}, {"category": "paragraph", "content": {"html": "<p id='21' data-category='paragraph' style='font-size:20px'>This manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options<br>of the meshers CM2 TetraMesh® Iso/Aniso.</p>", "markdown": "This manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options\nof the meshers CM2 TetraMesh® Iso/Aniso.", "text": "This manual shows examples of 3-D tetrahedral meshings illustrating along the way some of the major options\nof the meshers CM2 TetraMesh® Iso/Aniso."}, "coordinates": [{"x": 0.0756, "y": 0.0641}, {"x": 0.914, "y": 0.0641}, {"x": 0.914, "y": 0.0947}, {"x": 0.0756, "y": 0.0947}], "id": 21, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='22' data-category='paragraph' style='font-size:20px'>Each example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the<br>classes and the functions of the library (API).</p>", "markdown": "Each example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).", "text": "Each example starts with including the file stdafx.h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API)."}, "coordinates": [{"x": 0.0771, "y": 0.1053}, {"x": 0.8738, "y": 0.1053}, {"x": 0.8738, "y": 0.1349}, {"x": 0.0771, "y": 0.1349}], "id": 22, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='23' data-category='paragraph' style='font-size:20px'>The general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:<br>:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.<br>h file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to<br>avoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.</p>", "markdown": "The general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:\n:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.", "text": "The general namespace cm2 has nested namespaces such as cm2::vecscal, cm2::vecvec, cm2:\n:meshtools or cm2::triamesh_iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user’s source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive."}, "coordinates": [{"x": 0.0778, "y": 0.1479}, {"x": 0.9196, "y": 0.1479}, {"x": 0.9196, "y": 0.2042}, {"x": 0.0778, "y": 0.2042}], "id": 23, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='24' data-category='paragraph' style='font-size:20px'>File stdafx.h:</p>", "markdown": "File stdafx.h:", "text": "File stdafx.h:"}, "coordinates": [{"x": 0.0792, "y": 0.2154}, {"x": 0.1968, "y": 0.2154}, {"x": 0.1968, "y": 0.2287}, {"x": 0.0792, "y": 0.2287}], "id": 24, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='25' data-category='paragraph' style='font-size:14px'>// CM2 MESHTOOLS</p>", "markdown": "// CM2 MESHTOOLS", "text": "// CM2 MESHTOOLS"}, "coordinates": [{"x": 0.1081, "y": 0.2689}, {"x": 0.2399, "y": 0.2689}, {"x": 0.2399, "y": 0.2804}, {"x": 0.1081, "y": 0.2804}], "id": 25, "page": 4}, {"category": "table", "content": {"html": "<br><table id='26' style='font-size:14px'><thead></thead><tbody><tr><td>#include \"meshtools.h\" //</td><td>General purpose mesh routines.</td></tr><tr><td>#include \"meshtools2d.h\" //</td><td>To generate 1D meshes.</td></tr><tr><td>#include \"meshtools2d.h\" //</td><td>To generate 2D meshes.</td></tr><tr><td>#include \"tetramesh_iso.h\" //</td><td>CM2 TetraMesh Iso.</td></tr><tr><td>#include \"tetramesh_aniso.h\" //</td><td>CM2 TetraMesh Aniso (Section 10 only).</td></tr></tbody></table>", "markdown": "| #include \"meshtools.h\" // | General purpose mesh routines. |\n| --- | --- |\n| #include \"meshtools2d.h\" // | To generate 1D meshes. |\n| #include \"meshtools2d.h\" // | To generate 2D meshes. |\n| #include \"tetramesh_iso.h\" // | CM2 TetraMesh Iso. |\n| #include \"tetramesh_aniso.h\" // | CM2 TetraMesh Aniso (Section 10 only). |\n", "text": "| #include \"meshtools.h\" // | General purpose mesh routines. |\n| --- | --- |\n| #include \"meshtools2d.h\" // | To generate 1D meshes. |\n| #include \"meshtools2d.h\" // | To generate 2D meshes. |\n| #include \"tetramesh_iso.h\" // | CM2 TetraMesh Iso. |\n| #include \"tetramesh_aniso.h\" // | CM2 TetraMesh Aniso (Section 10 only). |\n"}, "coordinates": [{"x": 0.0965, "y": 0.2755}, {"x": 0.6856, "y": 0.2755}, {"x": 0.6856, "y": 0.3281}, {"x": 0.0965, "y": 0.3281}], "id": 26, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='27' data-category='paragraph' style='font-size:14px'>using namespace cm2;</p>", "markdown": "using namespace cm2;", "text": "using namespace cm2;"}, "coordinates": [{"x": 0.1064, "y": 0.3344}, {"x": 0.2716, "y": 0.3344}, {"x": 0.2716, "y": 0.3475}, {"x": 0.1064, "y": 0.3475}], "id": 27, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='28' data-category='paragraph' style='font-size:14px'>// Main cm2 namespace can now be omitted.</p>", "markdown": "// Main cm2 namespace can now be omitted.", "text": "// Main cm2 namespace can now be omitted."}, "coordinates": [{"x": 0.3485, "y": 0.3347}, {"x": 0.6819, "y": 0.3347}, {"x": 0.6819, "y": 0.3464}, {"x": 0.3485, "y": 0.3464}], "id": 28, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='29' data-category='paragraph' style='font-size:20px'>Required libraries1:</p>", "markdown": "Required libraries1:", "text": "Required libraries1:"}, "coordinates": [{"x": 0.0777, "y": 0.3901}, {"x": 0.2253, "y": 0.3901}, {"x": 0.2253, "y": 0.4047}, {"x": 0.0777, "y": 0.4047}], "id": 29, "page": 4}, {"category": "list", "content": {"html": "<p id='30' data-category='list' style='font-size:20px'>• cm2math1<br>• cm2misc<br>• cm2meshtools<br>• cm2meshtools2d<br>• cm2meshtools2d<br>• cm2meshtools3d<br>• cm2tetramesh_iso<br>• cm2tetramesh_aniso (Section 10 only)</p>", "markdown": "- • cm2math1\n- • cm2misc\n- • cm2meshtools\n- • cm2meshtools2d\n- • cm2meshtools2d\n- • cm2meshtools3d\n- • cm2tetramesh_iso\n- • cm2tetramesh_aniso (Section 10 only)\n", "text": "• cm2math1\n• cm2misc\n• cm2meshtools\n• cm2meshtools2d\n• cm2meshtools2d\n• cm2meshtools3d\n• cm2tetramesh_iso\n• cm2tetramesh_aniso (Section 10 only)"}, "coordinates": [{"x": 0.089, "y": 0.4186}, {"x": 0.4216, "y": 0.4186}, {"x": 0.4216, "y": 0.5486}, {"x": 0.089, "y": 0.5486}], "id": 30, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='31' data-category='paragraph' style='font-size:14px'>1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.<br>On Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static<br>archive), .so or .dylib (dynamic lib).</p>", "markdown": "1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.\nOn Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static\narchive), .so or .dylib (dynamic lib).", "text": "1 The lib names end with _($platform)_($ver). For instance cm2tetramesh_iso_x64_56.dll.\nOn Windows, file extensions for the libraries are .lib and .dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static\narchive), .so or .dylib (dynamic lib)."}, "coordinates": [{"x": 0.0646, "y": 0.8752}, {"x": 0.8894, "y": 0.8752}, {"x": 0.8894, "y": 0.9135}, {"x": 0.0646, "y": 0.9135}], "id": 31, "page": 4}, {"category": "table", "content": {"html": "<table id='32' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>4</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0122, "y": 0.9482}, {"x": 0.9995, "y": 0.9482}, {"x": 0.9995, "y": 1}, {"x": 0.0122, "y": 1}], "id": 32, "page": 4}, {"category": "heading1", "content": {"html": "<h1 id='33' style='font-size:22px'>1. Getting started</h1>", "markdown": "# 1. Getting started", "text": "1. Getting started"}, "coordinates": [{"x": 0.0774, "y": 0.0636}, {"x": 0.3187, "y": 0.0636}, {"x": 0.3187, "y": 0.0881}, {"x": 0.0774, "y": 0.0881}], "id": 33, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='34' data-category='paragraph' style='font-size:18px'>The simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We<br>assume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is<br>quite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a<br>3xNT matrix2. For each matrix the format is:</p>", "markdown": "The simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We\nassume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is\nquite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a\n3xNT matrix2. For each matrix the format is:", "text": "The simple way to see CM2 TetraMesh Iso in action is to use a pre-existing boundary mesh (triangle mesh). We\nassume here we have such a boundary mesh of ready on the ASCII file part.dat. The expected format here is\nquite simple: first the coordinates of the nodes as a 3xNP matrix, then the connectivity of the triangle mesh as a\n3xNT matrix2. For each matrix the format is:"}, "coordinates": [{"x": 0.076, "y": 0.0986}, {"x": 0.9211, "y": 0.0986}, {"x": 0.9211, "y": 0.1574}, {"x": 0.076, "y": 0.1574}], "id": 34, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='35' data-category='paragraph' style='font-size:20px'>n X m [<br>d0,0 d0,1 d0,2 ... d0,m-1<br>d1,0 d1,1 d1,2 ... d1,m-1<br>...<br>dn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]</p>", "markdown": "n X m [\nd0,0 d0,1 d0,2 ... d0,m-1\nd1,0 d1,1 d1,2 ... d1,m-1\n...\ndn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]", "text": "n X m [\nd0,0 d0,1 d0,2 ... d0,m-1\nd1,0 d1,1 d1,2 ... d1,m-1\n...\ndn-1,0 dn-1,1 dn-1,2... dn-1,m-1 ]"}, "coordinates": [{"x": 0.1232, "y": 0.171}, {"x": 0.3975, "y": 0.171}, {"x": 0.3975, "y": 0.2373}, {"x": 0.1232, "y": 0.2373}], "id": 35, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='36' data-category='paragraph' style='font-size:18px'>For instance, a mesh with 4 nodes and 2 triangles could write3:</p>", "markdown": "For instance, a mesh with 4 nodes and 2 triangles could write3:", "text": "For instance, a mesh with 4 nodes and 2 triangles could write3:"}, "coordinates": [{"x": 0.077, "y": 0.2625}, {"x": 0.5532, "y": 0.2625}, {"x": 0.5532, "y": 0.279}, {"x": 0.077, "y": 0.279}], "id": 36, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='37' data-category='paragraph' style='font-size:18px'>3 X 4 [<br>0. 1. 1. 0.<br>0. 0. 1. 1.<br>0. 0. 0.5 0. ]</p>", "markdown": "3 X 4 [\n0. 1. 1. 0.\n0. 0. 1. 1.\n0. 0. 0.5 0. ]", "text": "3 X 4 [\n0. 1. 1. 0.\n0. 0. 1. 1.\n0. 0. 0.5 0. ]"}, "coordinates": [{"x": 0.1261, "y": 0.2906}, {"x": 0.2893, "y": 0.2906}, {"x": 0.2893, "y": 0.3417}, {"x": 0.1261, "y": 0.3417}], "id": 37, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='38' data-category='paragraph' style='font-size:18px'>3 X 2 [<br>0 1<br>1 2<br>3 3 ]</p>", "markdown": "3 X 2 [\n0 1\n1 2\n3 3 ]", "text": "3 X 2 [\n0 1\n1 2\n3 3 ]"}, "coordinates": [{"x": 0.1238, "y": 0.3494}, {"x": 0.2014, "y": 0.3494}, {"x": 0.2014, "y": 0.401}, {"x": 0.1238, "y": 0.401}], "id": 38, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='39' data-category='paragraph' style='font-size:18px'>The source code to generate the tetrahedral mesh writes:</p>", "markdown": "The source code to generate the tetrahedral mesh writes:", "text": "The source code to generate the tetrahedral mesh writes:"}, "coordinates": [{"x": 0.0763, "y": 0.4193}, {"x": 0.5168, "y": 0.4193}, {"x": 0.5168, "y": 0.4356}, {"x": 0.0763, "y": 0.4356}], "id": 39, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='40' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream><br>#include <fstream></p>", "markdown": "#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>", "text": "#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>"}, "coordinates": [{"x": 0.106, "y": 0.4725}, {"x": 0.2655, "y": 0.4725}, {"x": 0.2655, "y": 0.5038}, {"x": 0.106, "y": 0.5038}], "id": 40, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='41' data-category='paragraph' style='font-size:14px'>// Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }</p>", "markdown": "// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }", "text": "// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }"}, "coordinates": [{"x": 0.1056, "y": 0.5107}, {"x": 0.7558, "y": 0.5107}, {"x": 0.7558, "y": 0.5338}, {"x": 0.1056, "y": 0.5338}], "id": 41, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='42' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1093, "y": 0.54}, {"x": 0.1903, "y": 0.54}, {"x": 0.1903, "y": 0.5515}, {"x": 0.1093, "y": 0.5515}], "id": 42, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='43' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.5505}, {"x": 0.1184, "y": 0.5505}, {"x": 0.1184, "y": 0.5611}, {"x": 0.1087, "y": 0.5611}], "id": 43, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='44' data-category='paragraph' style='font-size:14px'>std::ifstream istrm(\"part.dat\");<br>cm2::tetramesh_iso::mesher the_mesher;<br>cm2::tetramesh_iso::mesher::data_type data;</p>", "markdown": "std::ifstream istrm(\"part.dat\");\ncm2::tetramesh_iso::mesher the_mesher;\ncm2::tetramesh_iso::mesher::data_type data;", "text": "std::ifstream istrm(\"part.dat\");\ncm2::tetramesh_iso::mesher the_mesher;\ncm2::tetramesh_iso::mesher::data_type data;"}, "coordinates": [{"x": 0.128, "y": 0.5574}, {"x": 0.5927, "y": 0.5574}, {"x": 0.5927, "y": 0.5899}, {"x": 0.128, "y": 0.5899}], "id": 44, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='45' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ncm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1317, "y": 0.5958}, {"x": 0.7381, "y": 0.5958}, {"x": 0.7381, "y": 0.6197}, {"x": 0.1317, "y": 0.6197}], "id": 45, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='46' data-category='paragraph' style='font-size:14px'>// READ THE BOUNDARY TRIANGLE MESH.<br>cm2::matio::read(istrm, data.pos);<br>cm2::matio::read(istrm, data.connectB);</p>", "markdown": "// READ THE BOUNDARY TRIANGLE MESH.\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);", "text": "// READ THE BOUNDARY TRIANGLE MESH.\ncm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);"}, "coordinates": [{"x": 0.1327, "y": 0.6249}, {"x": 0.4466, "y": 0.6249}, {"x": 0.4466, "y": 0.6562}, {"x": 0.1327, "y": 0.6562}], "id": 46, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='47' data-category='paragraph' style='font-size:14px'>// GENERATE THE 3D MESH.<br>the_mesher.run(data);</p>", "markdown": "// GENERATE THE 3D MESH.\nthe_mesher.run(data);", "text": "// GENERATE THE 3D MESH.\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.1325, "y": 0.6632}, {"x": 0.3257, "y": 0.6632}, {"x": 0.3257, "y": 0.6841}, {"x": 0.1325, "y": 0.6841}], "id": 47, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='48' data-category='paragraph' style='font-size:14px'>// SOME OUTPUT INFO (OPTIONAL).<br>data.print_info(&display_hdl);</p>", "markdown": "// SOME OUTPUT INFO (OPTIONAL).\ndata.print_info(&display_hdl);", "text": "// SOME OUTPUT INFO (OPTIONAL).\ndata.print_info(&display_hdl);"}, "coordinates": [{"x": 0.1322, "y": 0.6913}, {"x": 0.3814, "y": 0.6913}, {"x": 0.3814, "y": 0.7135}, {"x": 0.1322, "y": 0.7135}], "id": 48, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='49' data-category='paragraph' style='font-size:14px'>// VISUALISATION (OPTIONAL).<br>cm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>", "markdown": "// VISUALISATION (OPTIONAL).\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);", "text": "// VISUALISATION (OPTIONAL).\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);"}, "coordinates": [{"x": 0.1306, "y": 0.7197}, {"x": 0.7562, "y": 0.7197}, {"x": 0.7562, "y": 0.7424}, {"x": 0.1306, "y": 0.7424}], "id": 49, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='50' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.127, "y": 0.7499}, {"x": 0.2077, "y": 0.7499}, {"x": 0.2077, "y": 0.7696}, {"x": 0.127, "y": 0.7696}], "id": 50, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='51' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.7595}, {"x": 0.1184, "y": 0.7595}, {"x": 0.1184, "y": 0.7702}, {"x": 0.1087, "y": 0.7702}], "id": 51, "page": 5}, {"category": "list", "content": {"html": "<p id='52' data-category='list' style='font-size:14px'>2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.<br>3 The format for each value is free.</p>", "markdown": "- 2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.\n- 3 The format for each value is free.\n", "text": "2 Other supported input formats are: STL (ASCII and binary), FEMAP neutral, Nastran and Alias’ Wavefront OBJ.\n3 The format for each value is free."}, "coordinates": [{"x": 0.0647, "y": 0.8806}, {"x": 0.733, "y": 0.8806}, {"x": 0.733, "y": 0.913}, {"x": 0.0647, "y": 0.913}], "id": 52, "page": 5}, {"category": "table", "content": {"html": "<table id='53' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>5</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 5 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 5 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0147, "y": 0.9483}, {"x": 0.9986, "y": 0.9483}, {"x": 0.9986, "y": 1}, {"x": 0.0147, "y": 1}], "id": 53, "page": 5}, {"category": "figure", "content": {"html": "<figure id='54'><img style='font-size:16px' alt=\"Figure 1 – A simple mechanical part.\" data-coord=\"top-left:(302,105); bottom-right:(941,685)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 1 – A simple mechanical part.", "text": "![image](/image/placeholder)\nFigure 1 – A simple mechanical part."}, "coordinates": [{"x": 0.2439, "y": 0.0599}, {"x": 0.759, "y": 0.0599}, {"x": 0.759, "y": 0.3909}, {"x": 0.2439, "y": 0.3909}], "id": 54, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='55' data-category='paragraph' style='font-size:20px'>Let us explain this program line by line.</p>", "markdown": "Let us explain this program line by line.", "text": "Let us explain this program line by line."}, "coordinates": [{"x": 0.0792, "y": 0.4316}, {"x": 0.3767, "y": 0.4316}, {"x": 0.3767, "y": 0.4477}, {"x": 0.0792, "y": 0.4477}], "id": 55, "page": 6}, {"category": "heading1", "content": {"html": "<br><h1 id='56' style='font-size:22px'>Some declarations</h1>", "markdown": "# Some declarations", "text": "Some declarations"}, "coordinates": [{"x": 0.0773, "y": 0.464}, {"x": 0.2822, "y": 0.464}, {"x": 0.2822, "y": 0.4821}, {"x": 0.0773, "y": 0.4821}], "id": 56, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='57' data-category='paragraph' style='font-size:20px'>A standard input stream istrm is built with the data file name part.dat. We create then an instance of the<br>tet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the<br>nodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB<br>and final tet mesh in data.connectM).</p>", "markdown": "A standard input stream istrm is built with the data file name part.dat. We create then an instance of the\ntet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the\nnodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB\nand final tet mesh in data.connectM).", "text": "A standard input stream istrm is built with the data file name part.dat. We create then an instance of the\ntet mesher (the_mesher) and a data structure (data) that will contain among others the coordinates of the\nnodes (in field data.pos) and the connectivity matrices (initial triangle boundary mesh in data.connectB\nand final tet mesh in data.connectM)."}, "coordinates": [{"x": 0.0761, "y": 0.4953}, {"x": 0.8977, "y": 0.4953}, {"x": 0.8977, "y": 0.5532}, {"x": 0.0761, "y": 0.5532}], "id": 57, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='58' data-category='paragraph' style='font-size:20px'>Matrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and<br>data.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This<br>integer refers to the column number in matrix data.pos where the coordinates of this node can be found5.</p>", "markdown": "Matrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and\ndata.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This\ninteger refers to the column number in matrix data.pos where the coordinates of this node can be found5.", "text": "Matrix data.pos is a DoubleMat (variable-sized matrix of doubles)4 and matrices data.connectB and\ndata.connectM are UIntMat. For instance connectB(i, j) is the ith local node of the jth element. This\ninteger refers to the column number in matrix data.pos where the coordinates of this node can be found5."}, "coordinates": [{"x": 0.0766, "y": 0.5644}, {"x": 0.8955, "y": 0.5644}, {"x": 0.8955, "y": 0.6092}, {"x": 0.0766, "y": 0.6092}], "id": 58, "page": 6}, {"category": "heading1", "content": {"html": "<h1 id='59' style='font-size:22px'>Authorization of the library</h1>", "markdown": "# Authorization of the library", "text": "Authorization of the library"}, "coordinates": [{"x": 0.0774, "y": 0.6257}, {"x": 0.3731, "y": 0.6257}, {"x": 0.3731, "y": 0.6455}, {"x": 0.0774, "y": 0.6455}], "id": 59, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='60' data-category='paragraph' style='font-size:20px'>The tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two<br>strings must be provided for each library: the name of your company or organization that has acquired the<br>license and a secret code6. Note that both strings are case sensitive and the registration call must be made<br>each time the library is loaded into memory and before any run of the mesher.</p>", "markdown": "The tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two\nstrings must be provided for each library: the name of your company or organization that has acquired the\nlicense and a secret code6. Note that both strings are case sensitive and the registration call must be made\neach time the library is loaded into memory and before any run of the mesher.", "text": "The tetramesh_iso library is unlocked through a call to cm2::tetramesh_iso::registration. Two\nstrings must be provided for each library: the name of your company or organization that has acquired the\nlicense and a secret code6. Note that both strings are case sensitive and the registration call must be made\neach time the library is loaded into memory and before any run of the mesher."}, "coordinates": [{"x": 0.0762, "y": 0.658}, {"x": 0.8858, "y": 0.658}, {"x": 0.8858, "y": 0.7151}, {"x": 0.0762, "y": 0.7151}], "id": 60, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='61' data-category='paragraph' style='font-size:16px'>cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "cm2::tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1049, "y": 0.7408}, {"x": 0.7147, "y": 0.7408}, {"x": 0.7147, "y": 0.7546}, {"x": 0.1049, "y": 0.7546}], "id": 61, "page": 6}, {"category": "list", "content": {"html": "<p id='62' data-category='list' style='font-size:14px'>4 See manual CM2 Math1 - overview.<br>5 Recall that array indices are zero based (from 0 to N-1).<br>6 Contact license@computing-objects.com for any licensing inquiry.</p>", "markdown": "- 4 See manual CM2 Math1 - overview.\n- 5 Recall that array indices are zero based (from 0 to N-1).\n- 6 Contact license@computing-objects.com for any licensing inquiry.\n", "text": "4 See manual CM2 Math1 - overview.\n5 Recall that array indices are zero based (from 0 to N-1).\n6 Contact license@computing-objects.com for any licensing inquiry."}, "coordinates": [{"x": 0.0662, "y": 0.8611}, {"x": 0.5168, "y": 0.8611}, {"x": 0.5168, "y": 0.915}, {"x": 0.0662, "y": 0.915}], "id": 62, "page": 6}, {"category": "table", "content": {"html": "<table id='63' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>6</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 6 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 6 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0165, "y": 0.9483}, {"x": 0.9981, "y": 0.9483}, {"x": 0.9981, "y": 1}, {"x": 0.0165, "y": 1}], "id": 63, "page": 6}, {"category": "heading1", "content": {"html": "<h1 id='64' style='font-size:22px'>Boundary mesh</h1>", "markdown": "# Boundary mesh", "text": "Boundary mesh"}, "coordinates": [{"x": 0.0781, "y": 0.0647}, {"x": 0.251, "y": 0.0647}, {"x": 0.251, "y": 0.0839}, {"x": 0.0781, "y": 0.0839}], "id": 64, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='65' data-category='paragraph' style='font-size:20px'>The cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.<br>We use it to load the nodes’ coordinates and the triangle connectivity from the same file.</p>", "markdown": "The cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.\nWe use it to load the nodes’ coordinates and the triangle connectivity from the same file.", "text": "The cm2::matio::read can load matrices following the above specified ASCII format from an input stream7.\nWe use it to load the nodes’ coordinates and the triangle connectivity from the same file."}, "coordinates": [{"x": 0.0756, "y": 0.0959}, {"x": 0.9095, "y": 0.0959}, {"x": 0.9095, "y": 0.1266}, {"x": 0.0756, "y": 0.1266}], "id": 65, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='66' data-category='paragraph' style='font-size:16px'>cm2::matio::read(istrm, data.pos);<br>cm2::matio::read(istrm, data.connectB);</p>", "markdown": "cm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);", "text": "cm2::matio::read(istrm, data.pos);\ncm2::matio::read(istrm, data.connectB);"}, "coordinates": [{"x": 0.1052, "y": 0.1636}, {"x": 0.4252, "y": 0.1636}, {"x": 0.4252, "y": 0.1863}, {"x": 0.1052, "y": 0.1863}], "id": 66, "page": 7}, {"category": "heading1", "content": {"html": "<h1 id='67' style='font-size:22px'>Tetrahedral mesh</h1>", "markdown": "# Tetrahedral mesh", "text": "Tetrahedral mesh"}, "coordinates": [{"x": 0.0778, "y": 0.2279}, {"x": 0.2716, "y": 0.2279}, {"x": 0.2716, "y": 0.2469}, {"x": 0.0778, "y": 0.2469}], "id": 67, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='68' data-category='paragraph' style='font-size:16px'>the_mesher.run(data);</p>", "markdown": "the_mesher.run(data);", "text": "the_mesher.run(data);"}, "coordinates": [{"x": 0.1054, "y": 0.2839}, {"x": 0.2799, "y": 0.2839}, {"x": 0.2799, "y": 0.2988}, {"x": 0.1054, "y": 0.2988}], "id": 68, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='69' data-category='paragraph' style='font-size:20px'>Upon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the<br>tetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary<br>mesh are left untouched in the first columns.</p>", "markdown": "Upon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the\ntetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary\nmesh are left untouched in the first columns.", "text": "Upon exit, the matrix data.pos is bigger and contains all the new nodes generated inside the domain by the\ntetrahedral mesher. These new points are appended to the original matrix. The initial points of the boundary\nmesh are left untouched in the first columns."}, "coordinates": [{"x": 0.0763, "y": 0.3402}, {"x": 0.9053, "y": 0.3402}, {"x": 0.9053, "y": 0.3842}, {"x": 0.0763, "y": 0.3842}], "id": 69, "page": 7}, {"category": "paragraph", "content": {"html": "<br><p id='70' data-category='paragraph' style='font-size:20px'>The connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of<br>the nodes for an element. connectM(i, j) is the ith local node of the jth element.</p>", "markdown": "The connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of\nthe nodes for an element. connectM(i, j) is the ith local node of the jth element.", "text": "The connectivity of the final mesh is stored in the matrix data.connectM, each column storing the indices of\nthe nodes for an element. connectM(i, j) is the ith local node of the jth element."}, "coordinates": [{"x": 0.0749, "y": 0.3946}, {"x": 0.9089, "y": 0.3946}, {"x": 0.9089, "y": 0.4253}, {"x": 0.0749, "y": 0.4253}], "id": 70, "page": 7}, {"category": "heading1", "content": {"html": "<br><h1 id='71' style='font-size:22px'>Output information</h1>", "markdown": "# Output information", "text": "Output information"}, "coordinates": [{"x": 0.0776, "y": 0.4372}, {"x": 0.2886, "y": 0.4372}, {"x": 0.2886, "y": 0.4567}, {"x": 0.0776, "y": 0.4567}], "id": 71, "page": 7}, {"category": "paragraph", "content": {"html": "<br><p id='72' data-category='paragraph' style='font-size:20px'>Printed information about the generated mesh and a MEDIT8 output file are obtained with:</p>", "markdown": "Printed information about the generated mesh and a MEDIT8 output file are obtained with:", "text": "Printed information about the generated mesh and a MEDIT8 output file are obtained with:"}, "coordinates": [{"x": 0.0777, "y": 0.4668}, {"x": 0.7646, "y": 0.4668}, {"x": 0.7646, "y": 0.4839}, {"x": 0.0777, "y": 0.4839}], "id": 72, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='73' data-category='paragraph' style='font-size:16px'>data.print_info(&display_hdl);<br>cm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>", "markdown": "data.print_info(&display_hdl);\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);", "text": "data.print_info(&display_hdl);\ncm2::meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);"}, "coordinates": [{"x": 0.1045, "y": 0.5199}, {"x": 0.7322, "y": 0.5199}, {"x": 0.7322, "y": 0.5438}, {"x": 0.1045, "y": 0.5438}], "id": 73, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='74' data-category='paragraph' style='font-size:20px'>Figure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of<br>2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces<br>and hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9.</p>", "markdown": "Figure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of\n2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces\nand hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9.", "text": "Figure 2 shows the output given by data.print_info(&display_hdl): the generated mesh is made of\n2428 nodes and 8008 tetrahedrons for an initial boundary mesh of 4174 triangles and 2085 nodes (hard faces\nand hard nodes). The time spent in each of the three steps of the meshing process is given in seconds9."}, "coordinates": [{"x": 0.0763, "y": 0.585}, {"x": 0.9157, "y": 0.585}, {"x": 0.9157, "y": 0.6302}, {"x": 0.0763, "y": 0.6302}], "id": 74, "page": 7}, {"category": "paragraph", "content": {"html": "<br><p id='75' data-category='paragraph' style='font-size:20px'>The first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the<br>second step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the<br>last step concerns geometrical and topological optimizations to improve the quality of the elements.</p>", "markdown": "The first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the\nsecond step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the\nlast step concerns geometrical and topological optimizations to improve the quality of the elements.", "text": "The first step is the generation of the front mesh (3D triangularization of the hard nodes and faces). In the\nsecond step, new nodes are generated inside the domain to get elements with good shape and size. Finally, the\nlast step concerns geometrical and topological optimizations to improve the quality of the elements."}, "coordinates": [{"x": 0.0765, "y": 0.6397}, {"x": 0.9186, "y": 0.6397}, {"x": 0.9186, "y": 0.6847}, {"x": 0.0765, "y": 0.6847}], "id": 75, "page": 7}, {"category": "paragraph", "content": {"html": "<br><p id='76' data-category='paragraph' style='font-size:20px'>The formula used to compute the shape quality of a tetrahedron is given by:</p>", "markdown": "The formula used to compute the shape quality of a tetrahedron is given by:", "text": "The formula used to compute the shape quality of a tetrahedron is given by:"}, "coordinates": [{"x": 0.0756, "y": 0.694}, {"x": 0.6549, "y": 0.694}, {"x": 0.6549, "y": 0.7115}, {"x": 0.0756, "y": 0.7115}], "id": 76, "page": 7}, {"category": "table", "content": {"html": "<br><table id='77' style='font-size:20px'><thead></thead><tbody><tr><td>V</td><td>V Volume of the tetrahedron.</td></tr><tr><td>Qs 6� 6 Lmax S</td><td>with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron.</td></tr></tbody></table>", "markdown": "| V | V Volume of the tetrahedron. |\n| --- | --- |\n| Qs 6� 6 Lmax S | with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron. |\n", "text": "| V | V Volume of the tetrahedron. |\n| --- | --- |\n| Qs 6� 6 Lmax S | with: Lmax Length of the longest edge of the tetrahedron. S Total area of the four faces of the tetrahedron. |\n"}, "coordinates": [{"x": 0.1057, "y": 0.721}, {"x": 0.8414, "y": 0.721}, {"x": 0.8414, "y": 0.7807}, {"x": 0.1057, "y": 0.7807}], "id": 77, "page": 7}, {"category": "footnote", "content": {"html": "<p id='78' data-category='footnote' style='font-size:14px'>7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:<br>:transpose_read function exists to read a matrix and transpose it on the fly.<br>8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),<br>VTK and Wavefront OBJ.<br>9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-<br>threading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®<br>Aniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased<br>further by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster.</p>", "markdown": "7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:\n:transpose_read function exists to read a matrix and transpose it on the fly.\n8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),\nVTK and Wavefront OBJ.\n9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-\nthreading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®\nAniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased\nfurther by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster.", "text": "7 This function is a template function and can be used with a wide range of streams and matrix classes. A similar cm2::matio:\n:transpose_read function exists to read a matrix and transpose it on the fly.\n8 MEDIT is a free visualization program (link). Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary),\nVTK and Wavefront OBJ.\n9 All runs were done with x64 CM2 libs (VS 2017 MD build) on Windows® 8.1 x64 with Intel® Xeon® E3-1270 V2 3.5 GHz (4 cores with hyper-\nthreading, turbo boost disabled). The typical speed with default settings on such a platform ranges from 8 000 tets / s. (CM2 TetraMesh®\nAniso with background mesh) to more than 80 000 tets / s. (CM2 TetraMesh Iso without background mesh). Speed can be increased\nfurther by reducing the optimization level (see reference manual). Pure 3-D tetrahedrisation in CONVEX_HULL_MODE is even faster."}, "coordinates": [{"x": 0.0669, "y": 0.8055}, {"x": 0.9218, "y": 0.8055}, {"x": 0.9218, "y": 0.9133}, {"x": 0.0669, "y": 0.9133}], "id": 78, "page": 7}, {"category": "table", "content": {"html": "<table id='79' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>7</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 7 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 7 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0111, "y": 0.9486}, {"x": 0.9986, "y": 0.9486}, {"x": 0.9986, "y": 1}, {"x": 0.0111, "y": 1}], "id": 79, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='80' data-category='paragraph' style='font-size:18px'>This quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet).</p>", "markdown": "This quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet).", "text": "This quality measure ranges from zero (for a degenerated tet) to one (for an equilateral tet)."}, "coordinates": [{"x": 0.0754, "y": 0.0648}, {"x": 0.7703, "y": 0.0648}, {"x": 0.7703, "y": 0.081}, {"x": 0.0754, "y": 0.081}], "id": 80, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='81' data-category='paragraph' style='font-size:18px'>On the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2).</p>", "markdown": "On the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2).", "text": "On the above example, the worst shape quality is 0.23 and the average is 0.68 (Figure 2)."}, "coordinates": [{"x": 0.0757, "y": 0.0908}, {"x": 0.7462, "y": 0.0908}, {"x": 0.7462, "y": 0.1075}, {"x": 0.0757, "y": 0.1075}], "id": 81, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='82' data-category='paragraph' style='font-size:18px'>Note that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There<br>is an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator<br>cannot produce a mesh with a minimum quality better than 0.56 in this case.</p>", "markdown": "Note that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There\nis an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator\ncannot produce a mesh with a minimum quality better than 0.56 in this case.", "text": "Note that the boundary triangles being not equilateral, the tets built upon them cannot be perfect either. There\nis an upper bound for the quality of these boundary tets. Here the limit is 0.56. That means that the generator\ncannot produce a mesh with a minimum quality better than 0.56 in this case."}, "coordinates": [{"x": 0.0764, "y": 0.1169}, {"x": 0.9214, "y": 0.1169}, {"x": 0.9214, "y": 0.1612}, {"x": 0.0764, "y": 0.1612}], "id": 82, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='83' data-category='paragraph' style='font-size:18px'>The size quality is also an important parameter to take into account. The size quality of an edge is a measure<br>based upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the<br>edge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always<br>positive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it<br>should be.</p>", "markdown": "The size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the\nedge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always\npositive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it\nshould be.", "text": "The size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values set on its vertices. A size quality of 1 indicates that the\nedge has the right length, i.e. optimal length. A too short edge has a size quality less than 1 (but always\npositive), and a too long edge has a size quality greater than 1. An edge with a quality of 2 is twice as long as it\nshould be."}, "coordinates": [{"x": 0.0764, "y": 0.1712}, {"x": 0.907, "y": 0.1712}, {"x": 0.907, "y": 0.2424}, {"x": 0.0764, "y": 0.2424}], "id": 83, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='84' data-category='paragraph' style='font-size:18px'>The formula used to compute the length quality of an edge AB writes:</p>", "markdown": "The formula used to compute the length quality of an edge AB writes:", "text": "The formula used to compute the length quality of an edge AB writes:"}, "coordinates": [{"x": 0.0768, "y": 0.2539}, {"x": 0.606, "y": 0.2539}, {"x": 0.606, "y": 0.2714}, {"x": 0.0768, "y": 0.2714}], "id": 84, "page": 8}, {"category": "equation", "content": {"html": "<br><p id='85' data-category='equation'>$$Q_{h}^{A B}=L_{A B}\\,\\frac{\\left|\\mathrm{h}_{A}\\right|}{h_{B}}$$</p>", "markdown": "$$Q_{h}^{A B}=L_{A B}\\,\\frac{\\left|\\mathrm{h}_{A}\\right|}{h_{B}}$$", "text": "hA ���\n ln ��� � �\n hB\n ABQh � LAB\n hA � hB"}, "coordinates": [{"x": 0.1206, "y": 0.2788}, {"x": 0.2882, "y": 0.2788}, {"x": 0.2882, "y": 0.3529}, {"x": 0.1206, "y": 0.3529}], "id": 85, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='86' data-category='paragraph' style='font-size:18px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.4011, "y": 0.3185}, {"x": 0.4425, "y": 0.3185}, {"x": 0.4425, "y": 0.3345}, {"x": 0.4011, "y": 0.3345}], "id": 86, "page": 8}, {"category": "list", "content": {"html": "<br><p id='87' data-category='list' style='font-size:16px'>LAB Actual length of edge AB.<br>hA Target size at node A (expected edge length at A).<br>hB Target size at node B (expected edge length at B).</p>", "markdown": "- LAB Actual length of edge AB.\n- hA Target size at node A (expected edge length at A).\n- hB Target size at node B (expected edge length at B).\n", "text": "LAB Actual length of edge AB.\nhA Target size at node A (expected edge length at A).\nhB Target size at node B (expected edge length at B)."}, "coordinates": [{"x": 0.4697, "y": 0.2983}, {"x": 0.8625, "y": 0.2983}, {"x": 0.8625, "y": 0.3559}, {"x": 0.4697, "y": 0.3559}], "id": 87, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='88' data-category='paragraph' style='font-size:18px'>Let’s introduce also at this point the h-shock measure of an edge:</p>", "markdown": "Let’s introduce also at this point the h-shock measure of an edge:", "text": "Let’s introduce also at this point the h-shock measure of an edge:"}, "coordinates": [{"x": 0.078, "y": 0.3712}, {"x": 0.5742, "y": 0.3712}, {"x": 0.5742, "y": 0.3889}, {"x": 0.078, "y": 0.3889}], "id": 88, "page": 8}, {"category": "equation", "content": {"html": "<p id='89' data-category='equation'>$$h s^{4B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{b}^{4B}}}-1$$</p>", "markdown": "$$h s^{4B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{b}^{4B}}}-1$$", "text": "1\n hA hB Q h\n AB\n , ���\n hs AB � min ��� hB hA\n � 1\n �\n �"}, "coordinates": [{"x": 0.1203, "y": 0.4025}, {"x": 0.3622, "y": 0.4025}, {"x": 0.3622, "y": 0.4525}, {"x": 0.1203, "y": 0.4525}], "id": 89, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='90' data-category='paragraph' style='font-size:18px'>These two measure are dimensionless and positive.</p>", "markdown": "These two measure are dimensionless and positive.", "text": "These two measure are dimensionless and positive."}, "coordinates": [{"x": 0.0762, "y": 0.474}, {"x": 0.4719, "y": 0.474}, {"x": 0.4719, "y": 0.4899}, {"x": 0.0762, "y": 0.4899}], "id": 90, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='91' data-category='paragraph' style='font-size:18px'>LAB<br>When hA = hB the h-shock is null and the length writes hQ AB � .<br>hA<br>When ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB.</p>", "markdown": "LAB\nWhen hA = hB the h-shock is null and the length writes hQ AB � .\nhA\nWhen ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB.", "text": "LAB\nWhen hA = hB the h-shock is null and the length writes hQ AB � .\nhA\nWhen ABQh 1� edge AB is considered having optimal length with respect to its target mesh sizes hA and hB."}, "coordinates": [{"x": 0.0729, "y": 0.4994}, {"x": 0.8962, "y": 0.4994}, {"x": 0.8962, "y": 0.5506}, {"x": 0.0729, "y": 0.5506}], "id": 91, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='92' data-category='paragraph' style='font-size:18px'>To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size<br>quality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure<br>smooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this<br>makes the job of the optimizer difficult and heuristics must be used.</p>", "markdown": "To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.", "text": "To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard faces, edges and nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used."}, "coordinates": [{"x": 0.0768, "y": 0.5586}, {"x": 0.9024, "y": 0.5586}, {"x": 0.9024, "y": 0.6168}, {"x": 0.0768, "y": 0.6168}], "id": 92, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='93' data-category='paragraph' style='font-size:18px'>The mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.<br>settings.compute_Qh_flag10 is set to true11.</p>", "markdown": "The mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.\nsettings.compute_Qh_flag10 is set to true11.", "text": "The mesher computes the histogram of the size qualities (normalized edge lengths) when the flag my_mesher.\nsettings.compute_Qh_flag10 is set to true11."}, "coordinates": [{"x": 0.0778, "y": 0.6266}, {"x": 0.917, "y": 0.6266}, {"x": 0.917, "y": 0.6583}, {"x": 0.0778, "y": 0.6583}], "id": 93, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='94' data-category='paragraph' style='font-size:18px'>On this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance<br>(Figure 3).</p>", "markdown": "On this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance\n(Figure 3).", "text": "On this example, the size qualities are well centered near the value 1 (mean value 1.01) with a small variance\n(Figure 3)."}, "coordinates": [{"x": 0.0764, "y": 0.6667}, {"x": 0.8977, "y": 0.6667}, {"x": 0.8977, "y": 0.6989}, {"x": 0.0764, "y": 0.6989}], "id": 94, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='95' data-category='paragraph' style='font-size:14px'>10 See reference manual for details on the settings of the meshers.</p>", "markdown": "10 See reference manual for details on the settings of the meshers.", "text": "10 See reference manual for details on the settings of the meshers."}, "coordinates": [{"x": 0.0659, "y": 0.8825}, {"x": 0.4686, "y": 0.8825}, {"x": 0.4686, "y": 0.8943}, {"x": 0.0659, "y": 0.8943}], "id": 95, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='96' data-category='paragraph' style='font-size:14px'>11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities.</p>", "markdown": "11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities.", "text": "11 It can also be computed after the meshing with a call to cm2::meshtools::edge_qualities."}, "coordinates": [{"x": 0.0627, "y": 0.8992}, {"x": 0.6639, "y": 0.8992}, {"x": 0.6639, "y": 0.9133}, {"x": 0.0627, "y": 0.9133}], "id": 96, "page": 8}, {"category": "table", "content": {"html": "<table id='97' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>8</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0143, "y": 0.9483}, {"x": 0.9985, "y": 0.9483}, {"x": 0.9985, "y": 1}, {"x": 0.0143, "y": 1}], "id": 97, "page": 8}, {"category": "figure", "content": {"html": "<figure id='98'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74\" data-coord=\"top-left:(112,122); bottom-right:(1142,843)\" /></figure>", "markdown": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74", "text": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 2085/2085\nHard edges : 6261/6261\nHard faces : 4174/4174\nNodes : 2428\nTets : 8008\nMissing faces : 0\nSubdomains : 1\nVolume : 1.802054E+04\nQmin : 1.120209E-01 (max-min: 5.561858E-01)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.12 s. (65105.74 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8008\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.981352E-01\nV mean : 6.785422E-01\nV min : 1.120209E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 342\n9 0.80 0.90 881\n8 0.70 0.80 1972\n7 0.60 0.70 2536\n6 0.50 0.60 1947\n5 0.40 0.50 289\n4 0.30 0.40 39\n3 0.20 0.30 1\n2 0.10 0.20 1\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 2428\nNEFS : 8008\nTIME : 0.12 s.\nNEFS / s : 65105.74"}, "coordinates": [{"x": 0.0909, "y": 0.0697}, {"x": 0.9205, "y": 0.0697}, {"x": 0.9205, "y": 0.481}, {"x": 0.0909, "y": 0.481}], "id": 98, "page": 9}, {"category": "caption", "content": {"html": "<caption id='99' style='font-size:16px'>Figure 2 – Output info for the “mechanical part” example.</caption>", "markdown": "Figure 2 – Output info for the “mechanical part” example.", "text": "Figure 2 – Output info for the “mechanical part” example."}, "coordinates": [{"x": 0.3237, "y": 0.4904}, {"x": 0.6741, "y": 0.4904}, {"x": 0.6741, "y": 0.5043}, {"x": 0.3237, "y": 0.5043}], "id": 99, "page": 9}, {"category": "figure", "content": {"html": "<figure id='100'><img style='font-size:14px' alt=\"************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(107,948); bottom-right:(1141,1463)\" /></figure>", "markdown": "![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0", "text": "![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 12524\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.762665E+00\nV mean : 1.008241E+00\nV min : 2.886290E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 5\n13 1.43 1.67 405\n12 1.25 1.43 1430\n11 1.11 1.25 1331\n10 1.00 1.11 2589\n9 0.90 1.00 3237\n8 0.80 0.90 1629\n7 0.70 0.80 1313\n6 0.60 0.70 453\n5 0.50 0.60 75\n4 0.40 0.50 44\n3 0.30 0.40 11\n2 0.20 0.30 2\n1 0.10 0.20 0\n0 0.00 0.10 0"}, "coordinates": [{"x": 0.0863, "y": 0.5405}, {"x": 0.9201, "y": 0.5405}, {"x": 0.9201, "y": 0.8346}, {"x": 0.0863, "y": 0.8346}], "id": 100, "page": 9}, {"category": "caption", "content": {"html": "<caption id='101' style='font-size:16px'>Figure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example.</caption>", "markdown": "Figure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example.", "text": "Figure 3 – Histogram of the size-qualities of all the edges in the “mechanical part” example."}, "coordinates": [{"x": 0.2259, "y": 0.8442}, {"x": 0.7738, "y": 0.8442}, {"x": 0.7738, "y": 0.8584}, {"x": 0.2259, "y": 0.8584}], "id": 101, "page": 9}, {"category": "table", "content": {"html": "<table id='102' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>9</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 9 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 9 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0078, "y": 0.9481}, {"x": 0.9989, "y": 0.9481}, {"x": 0.9989, "y": 1}, {"x": 0.0078, "y": 1}], "id": 102, "page": 9}, {"category": "heading1", "content": {"html": "<h1 id='103' style='font-size:20px'>2. Simple cube</h1>", "markdown": "# 2. Simple cube", "text": "2. Simple cube"}, "coordinates": [{"x": 0.076, "y": 0.0635}, {"x": 0.2808, "y": 0.0635}, {"x": 0.2808, "y": 0.0878}, {"x": 0.076, "y": 0.0878}], "id": 103, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='104' data-category='paragraph' style='font-size:18px'>This second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.<br>This will also help introduce some options of CM2 TetraMesh Iso in following examples.</p>", "markdown": "This second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.\nThis will also help introduce some options of CM2 TetraMesh Iso in following examples.", "text": "This second example illustrates some of the meshtools auxiliary functions to generate 1-D and 2-D meshes.\nThis will also help introduce some options of CM2 TetraMesh Iso in following examples."}, "coordinates": [{"x": 0.0746, "y": 0.0986}, {"x": 0.8925, "y": 0.0986}, {"x": 0.8925, "y": 0.1296}, {"x": 0.0746, "y": 0.1296}], "id": 104, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='105' data-category='paragraph' style='font-size:18px'>The following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):</p>", "markdown": "The following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):", "text": "The following code meshes a cube from scratch (no boundary mesh read from file, cm2 namespace omitted):"}, "coordinates": [{"x": 0.0759, "y": 0.1389}, {"x": 0.9042, "y": 0.1389}, {"x": 0.9042, "y": 0.1567}, {"x": 0.0759, "y": 0.1567}], "id": 105, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='106' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream></p>", "markdown": "#include \"stdafx.h\"\n#include <iostream>", "text": "#include \"stdafx.h\"\n#include <iostream>"}, "coordinates": [{"x": 0.1053, "y": 0.193}, {"x": 0.2645, "y": 0.193}, {"x": 0.2645, "y": 0.2137}, {"x": 0.1053, "y": 0.2137}], "id": 106, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='107' data-category='paragraph' style='font-size:14px'>// Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }</p>", "markdown": "// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }", "text": "// Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std::cout << msg; }"}, "coordinates": [{"x": 0.1056, "y": 0.221}, {"x": 0.7566, "y": 0.221}, {"x": 0.7566, "y": 0.2448}, {"x": 0.1056, "y": 0.2448}], "id": 107, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='108' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1094, "y": 0.2501}, {"x": 0.1911, "y": 0.2501}, {"x": 0.1911, "y": 0.2624}, {"x": 0.1094, "y": 0.2624}], "id": 108, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='109' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.261}, {"x": 0.1184, "y": 0.261}, {"x": 0.1184, "y": 0.2717}, {"x": 0.1087, "y": 0.2717}], "id": 109, "page": 10}, {"category": "table", "content": {"html": "<br><table id='110' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6);</td><td>// The discretization along each edge.</td></tr><tr><td>const double</td><td>L(4.);</td><td>// The sides length.</td></tr><tr><td>DoubleMat</td><td>pos;</td><td></td></tr><tr><td>UIntMat</td><td>connectE,</td><td>connectB, connectB1, connectB2;</td></tr><tr><td>UIntVec</td><td>indices;</td><td></td></tr></tbody></table>", "markdown": "| const unsigned | N(6); | // The discretization along each edge. |\n| --- | --- | --- |\n| const double | L(4.); | // The sides length. |\n| DoubleMat | pos; |  |\n| UIntMat | connectE, | connectB, connectB1, connectB2; |\n| UIntVec | indices; |  |\n", "text": "| const unsigned | N(6); | // The discretization along each edge. |\n| --- | --- | --- |\n| const double | L(4.); | // The sides length. |\n| DoubleMat | pos; |  |\n| UIntMat | connectE, | connectB, connectB1, connectB2; |\n| UIntVec | indices; |  |\n"}, "coordinates": [{"x": 0.1277, "y": 0.2691}, {"x": 0.6896, "y": 0.2691}, {"x": 0.6896, "y": 0.318}, {"x": 0.1277, "y": 0.318}], "id": 110, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='111' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1309, "y": 0.3258}, {"x": 0.6972, "y": 0.3258}, {"x": 0.6972, "y": 0.3485}, {"x": 0.1309, "y": 0.3485}], "id": 111, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='112' data-category='paragraph' style='font-size:14px'>// BOUNDARY TRIANGLE MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);</p>", "markdown": "// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);", "text": "// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0, 0, L), DoubleVec3(L, 0, 0), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0, L, 0), N, 2, connectB);"}, "coordinates": [{"x": 0.1322, "y": 0.3546}, {"x": 0.8602, "y": 0.3546}, {"x": 0.8602, "y": 0.3964}, {"x": 0.1322, "y": 0.3964}], "id": 112, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='113' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1313, "y": 0.4022}, {"x": 0.8368, "y": 0.4022}, {"x": 0.8368, "y": 0.4331}, {"x": 0.1313, "y": 0.4331}], "id": 113, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='114' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.131, "y": 0.4404}, {"x": 0.853, "y": 0.4404}, {"x": 0.853, "y": 0.4719}, {"x": 0.131, "y": 0.4719}], "id": 114, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='115' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>", "markdown": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);", "text": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);"}, "coordinates": [{"x": 0.1319, "y": 0.4787}, {"x": 0.8518, "y": 0.4787}, {"x": 0.8518, "y": 0.5097}, {"x": 0.1319, "y": 0.5097}], "id": 115, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='116' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>", "markdown": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);", "text": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);"}, "coordinates": [{"x": 0.1317, "y": 0.516}, {"x": 0.6815, "y": 0.516}, {"x": 0.6815, "y": 0.5295}, {"x": 0.1317, "y": 0.5295}], "id": 116, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='117' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>", "markdown": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);", "text": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.1326, "y": 0.5383}, {"x": 0.5791, "y": 0.5383}, {"x": 0.5791, "y": 0.575}, {"x": 0.1326, "y": 0.575}], "id": 117, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='118' data-category='paragraph' style='font-size:14px'>// VISUALISATION (OPTIONAL).<br>data.print_info(&display_hdl);<br>meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>", "markdown": "// VISUALISATION (OPTIONAL).\ndata.print_info(&display_hdl);\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);", "text": "// VISUALISATION (OPTIONAL).\ndata.print_info(&display_hdl);\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);"}, "coordinates": [{"x": 0.1307, "y": 0.5827}, {"x": 0.7156, "y": 0.5827}, {"x": 0.7156, "y": 0.6153}, {"x": 0.1307, "y": 0.6153}], "id": 118, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='119' data-category='paragraph' style='font-size:14px'>return 0;<br>} // main</p>", "markdown": "return 0;\n} // main", "text": "return 0;\n} // main"}, "coordinates": [{"x": 0.1052, "y": 0.6221}, {"x": 0.2075, "y": 0.6221}, {"x": 0.2075, "y": 0.6423}, {"x": 0.1052, "y": 0.6423}], "id": 119, "page": 10}, {"category": "table", "content": {"html": "<table id='120' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>10</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 10 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 10 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0039, "y": 0.9481}, {"x": 0.9987, "y": 0.9481}, {"x": 0.9987, "y": 1}, {"x": 0.0039, "y": 1}], "id": 120, "page": 10}, {"category": "figure", "content": {"html": "<figure id='121'><img style='font-size:14px' alt=\"Figure 4 – Simple cube.\" data-coord=\"top-left:(335,112); bottom-right:(904,750)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 4 – Simple cube.", "text": "![image](/image/placeholder)\nFigure 4 – Simple cube."}, "coordinates": [{"x": 0.2705, "y": 0.0644}, {"x": 0.7288, "y": 0.0644}, {"x": 0.7288, "y": 0.428}, {"x": 0.2705, "y": 0.428}], "id": 121, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='122' data-category='paragraph' style='font-size:18px'>Let us again explain this program line by line.</p>", "markdown": "Let us again explain this program line by line.", "text": "Let us again explain this program line by line."}, "coordinates": [{"x": 0.0773, "y": 0.4517}, {"x": 0.4201, "y": 0.4517}, {"x": 0.4201, "y": 0.4674}, {"x": 0.0773, "y": 0.4674}], "id": 122, "page": 11}, {"category": "paragraph", "content": {"html": "<br><p id='123' data-category='paragraph' style='font-size:18px'>Most of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only<br>three lines in the program.</p>", "markdown": "Most of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only\nthree lines in the program.", "text": "Most of the lines are related to the generation of the boundary mesh. The tetrahedral mesh itself uses only\nthree lines in the program."}, "coordinates": [{"x": 0.0764, "y": 0.4766}, {"x": 0.8892, "y": 0.4766}, {"x": 0.8892, "y": 0.5073}, {"x": 0.0764, "y": 0.5073}], "id": 123, "page": 11}, {"category": "heading1", "content": {"html": "<h1 id='124' style='font-size:20px'>Some declarations</h1>", "markdown": "# Some declarations", "text": "Some declarations"}, "coordinates": [{"x": 0.0771, "y": 0.5247}, {"x": 0.2826, "y": 0.5247}, {"x": 0.2826, "y": 0.5427}, {"x": 0.0771, "y": 0.5427}], "id": 124, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='125' data-category='paragraph' style='font-size:18px'>Matrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the<br>final mesh (many of them are in both).</p>", "markdown": "Matrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the\nfinal mesh (many of them are in both).", "text": "Matrix pos stores all the points’ coordinates: the nodes of the initial (boundary) mesh and the nodes of the\nfinal mesh (many of them are in both)."}, "coordinates": [{"x": 0.0776, "y": 0.5558}, {"x": 0.8865, "y": 0.5558}, {"x": 0.8865, "y": 0.5855}, {"x": 0.0776, "y": 0.5855}], "id": 125, "page": 11}, {"category": "paragraph", "content": {"html": "<br><p id='126' data-category='paragraph' style='font-size:18px'>Matrix connectB stores the connectivity matrix of the boundary triangle mesh.</p>", "markdown": "Matrix connectB stores the connectivity matrix of the boundary triangle mesh.", "text": "Matrix connectB stores the connectivity matrix of the boundary triangle mesh."}, "coordinates": [{"x": 0.0783, "y": 0.5961}, {"x": 0.6778, "y": 0.5961}, {"x": 0.6778, "y": 0.6126}, {"x": 0.0783, "y": 0.6126}], "id": 126, "page": 11}, {"category": "paragraph", "content": {"html": "<br><p id='127' data-category='paragraph' style='font-size:18px'>Matrices connectB1, connectB2 and connectE are temporaries as well as vector indices.</p>", "markdown": "Matrices connectB1, connectB2 and connectE are temporaries as well as vector indices.", "text": "Matrices connectB1, connectB2 and connectE are temporaries as well as vector indices."}, "coordinates": [{"x": 0.0778, "y": 0.6225}, {"x": 0.7899, "y": 0.6225}, {"x": 0.7899, "y": 0.6387}, {"x": 0.0778, "y": 0.6387}], "id": 127, "page": 11}, {"category": "heading1", "content": {"html": "<h1 id='128' style='font-size:20px'>Boundary mesh</h1>", "markdown": "# Boundary mesh", "text": "Boundary mesh"}, "coordinates": [{"x": 0.0778, "y": 0.6551}, {"x": 0.2508, "y": 0.6551}, {"x": 0.2508, "y": 0.6738}, {"x": 0.0778, "y": 0.6738}], "id": 128, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='129' data-category='paragraph' style='font-size:18px'>In this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to<br>generate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher<br>needs this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix<br>connectB of connectivity of the boundary triangles.</p>", "markdown": "In this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to\ngenerate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher\nneeds this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix\nconnectB of connectivity of the boundary triangles.", "text": "In this example, we only use routines from the CM2 MeshTools® SDK but, as already seen, the user is free to\ngenerate this boundary mesh with other tools or even to read it from a file. In any case, the tetrahedral mesher\nneeds this boundary mesh as a couple of matrices: the matrix pos of coordinates of the nodes and the matrix\nconnectB of connectivity of the boundary triangles."}, "coordinates": [{"x": 0.0772, "y": 0.6863}, {"x": 0.9169, "y": 0.6863}, {"x": 0.9169, "y": 0.744}, {"x": 0.0772, "y": 0.744}], "id": 129, "page": 11}, {"category": "paragraph", "content": {"html": "<br><p id='130' data-category='paragraph' style='font-size:18px'>We choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of<br>the cube.</p>", "markdown": "We choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of\nthe cube.", "text": "We choose to generate the mesh on one of the faces and then copy and rotate to get the other five faces of\nthe cube."}, "coordinates": [{"x": 0.0764, "y": 0.7552}, {"x": 0.8961, "y": 0.7552}, {"x": 0.8961, "y": 0.7843}, {"x": 0.0764, "y": 0.7843}], "id": 130, "page": 11}, {"category": "paragraph", "content": {"html": "<br><p id='131' data-category='paragraph' style='font-size:18px'>The first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):</p>", "markdown": "The first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):", "text": "The first face is done in three steps. First, N+1 points are generated along the line (0, 0, L) - (L, 0, L):"}, "coordinates": [{"x": 0.0758, "y": 0.795}, {"x": 0.8211, "y": 0.795}, {"x": 0.8211, "y": 0.8121}, {"x": 0.0758, "y": 0.8121}], "id": 131, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='132' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);</p>", "markdown": "meshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);", "text": "meshtools2d::extrude_translate(pos, DoubleVec3(0., 0., L), DoubleVec3(L, 0., 0.), N, indices);"}, "coordinates": [{"x": 0.1043, "y": 0.8369}, {"x": 0.8688, "y": 0.8369}, {"x": 0.8688, "y": 0.8501}, {"x": 0.1043, "y": 0.8501}], "id": 132, "page": 11}, {"category": "table", "content": {"html": "<table id='133' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>11</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 11 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 11 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.011, "y": 0.9483}, {"x": 0.9973, "y": 0.9483}, {"x": 0.9973, "y": 1}, {"x": 0.011, "y": 1}], "id": 133, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='134' data-category='paragraph' style='font-size:20px'>This generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos<br>matrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This<br>vector contains upon exit of this function (N = 6):</p>", "markdown": "This generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos\nmatrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This\nvector contains upon exit of this function (N = 6):", "text": "This generates N+1 points equally spaced between (0, 0, L) and (L, 0, L) as new appended columns in the pos\nmatrix. The index of each point (i.e. the column in matrix pos) is also appended to the vector indices. This\nvector contains upon exit of this function (N = 6):"}, "coordinates": [{"x": 0.075, "y": 0.0639}, {"x": 0.9007, "y": 0.0639}, {"x": 0.9007, "y": 0.1096}, {"x": 0.075, "y": 0.1096}], "id": 134, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='135' data-category='paragraph' style='font-size:20px'>[0 1 2 3 4 5 6]</p>", "markdown": "[0 1 2 3 4 5 6]", "text": "[0 1 2 3 4 5 6]"}, "coordinates": [{"x": 0.1261, "y": 0.1252}, {"x": 0.2815, "y": 0.1252}, {"x": 0.2815, "y": 0.1404}, {"x": 0.1261, "y": 0.1404}], "id": 135, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='136' data-category='paragraph' style='font-size:20px'>And the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).<br>The vector of indices is used to create the connectivity matrix of the first edge mesh:</p>", "markdown": "And the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).\nThe vector of indices is used to create the connectivity matrix of the first edge mesh:", "text": "And the matrix pos is now a 3x7 matrix. The first column equals to (0, 0, L) and the last one to (L, 0, L).\nThe vector of indices is used to create the connectivity matrix of the first edge mesh:"}, "coordinates": [{"x": 0.073, "y": 0.1616}, {"x": 0.8498, "y": 0.1616}, {"x": 0.8498, "y": 0.2063}, {"x": 0.073, "y": 0.2063}], "id": 136, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='137' data-category='paragraph' style='font-size:16px'>meshtools2d::indices_to_connectE2(indices, connectE);</p>", "markdown": "meshtools2d::indices_to_connectE2(indices, connectE);", "text": "meshtools2d::indices_to_connectE2(indices, connectE);"}, "coordinates": [{"x": 0.1059, "y": 0.2418}, {"x": 0.5379, "y": 0.2418}, {"x": 0.5379, "y": 0.2565}, {"x": 0.1059, "y": 0.2565}], "id": 137, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='138' data-category='paragraph' style='font-size:20px'>connectE is now a 2x6 matrix:</p>", "markdown": "connectE is now a 2x6 matrix:", "text": "connectE is now a 2x6 matrix:"}, "coordinates": [{"x": 0.077, "y": 0.2987}, {"x": 0.3191, "y": 0.2987}, {"x": 0.3191, "y": 0.3136}, {"x": 0.077, "y": 0.3136}], "id": 138, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='139' data-category='paragraph' style='font-size:20px'>2x6 [0 1 2 3 4 5<br>1 2 3 4 5 6]</p>", "markdown": "2x6 [0 1 2 3 4 5\n1 2 3 4 5 6]", "text": "2x6 [0 1 2 3 4 5\n1 2 3 4 5 6]"}, "coordinates": [{"x": 0.1239, "y": 0.3258}, {"x": 0.3016, "y": 0.3258}, {"x": 0.3016, "y": 0.354}, {"x": 0.1239, "y": 0.354}], "id": 139, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='140' data-category='paragraph' style='font-size:20px'>This line mesh is then extruded into a mesh of triangles along vector (0, L, 0):</p>", "markdown": "This line mesh is then extruded into a mesh of triangles along vector (0, L, 0):", "text": "This line mesh is then extruded into a mesh of triangles along vector (0, L, 0):"}, "coordinates": [{"x": 0.0753, "y": 0.3757}, {"x": 0.6588, "y": 0.3757}, {"x": 0.6588, "y": 0.3938}, {"x": 0.0753, "y": 0.3938}], "id": 140, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='141' data-category='paragraph' style='font-size:16px'>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);</p>", "markdown": "meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);", "text": "meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);"}, "coordinates": [{"x": 0.1045, "y": 0.4293}, {"x": 0.8188, "y": 0.4293}, {"x": 0.8188, "y": 0.4434}, {"x": 0.1045, "y": 0.4434}], "id": 141, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='142' data-category='paragraph' style='font-size:20px'>The 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”<br>pattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to<br>matrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix<br>connectB as new columns of indices of nodes.</p>", "markdown": "The 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”\npattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to\nmatrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix\nconnectB as new columns of indices of nodes.", "text": "The 5th parameter (here 2) controls the type of triangle mesh to be generated: 2 is for an alternate “Union Jack”\npattern, 0 and 1 for a simply oriented mesh (left or right)12. The coordinates of the new points are appended to\nmatrix pos which now becomes a 3 x 49 matrix13 The 72 generated triangles are appended to matrix\nconnectB as new columns of indices of nodes."}, "coordinates": [{"x": 0.0769, "y": 0.4849}, {"x": 0.9148, "y": 0.4849}, {"x": 0.9148, "y": 0.5433}, {"x": 0.0769, "y": 0.5433}], "id": 142, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='143' data-category='paragraph' style='font-size:20px'>We now have to copy and rotate this mesh:</p>", "markdown": "We now have to copy and rotate this mesh:", "text": "We now have to copy and rotate this mesh:"}, "coordinates": [{"x": 0.077, "y": 0.5546}, {"x": 0.4093, "y": 0.5546}, {"x": 0.4093, "y": 0.5708}, {"x": 0.077, "y": 0.5708}], "id": 143, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='144' data-category='paragraph' style='font-size:16px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1033, "y": 0.6066}, {"x": 0.8151, "y": 0.6066}, {"x": 0.8151, "y": 0.6413}, {"x": 0.1033, "y": 0.6413}], "id": 144, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='145' data-category='paragraph' style='font-size:20px'>After the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix<br>pos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),<br>Y}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB.</p>", "markdown": "After the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix\npos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),\nY}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB.", "text": "After the copy, the two meshes connectB and connectB1 are coincident (geometrically equal) and matrix\npos is twice as bigger as before. The new copy is then subjected to a rotation of π around axis {(L/2, L/2, L/2),\nY}. It is then concatenated to the first mesh: the columns of connectB1 are appended to connectB."}, "coordinates": [{"x": 0.0757, "y": 0.682}, {"x": 0.898, "y": 0.682}, {"x": 0.898, "y": 0.7277}, {"x": 0.0757, "y": 0.7277}], "id": 145, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='146' data-category='paragraph' style='font-size:14px'>12 Several variants of this function are available in the meshtools2d library and are described in the API.</p>", "markdown": "12 Several variants of this function are available in the meshtools2d library and are described in the API.", "text": "12 Several variants of this function are available in the meshtools2d library and are described in the API."}, "coordinates": [{"x": 0.0641, "y": 0.8691}, {"x": 0.6967, "y": 0.8691}, {"x": 0.6967, "y": 0.8827}, {"x": 0.0641, "y": 0.8827}], "id": 146, "page": 12}, {"category": "footnote", "content": {"html": "<p id='147' data-category='footnote' style='font-size:14px'>13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and<br>copies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged.</p>", "markdown": "13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and\ncopies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged.", "text": "13 The memory is automatically reallocated as the matrix grows. If size is known early, reserving space can avoid memory reallocations and\ncopies: pos.reserve(3, 500); // reserve space for 500 points but dimensions are unchanged."}, "coordinates": [{"x": 0.0646, "y": 0.8883}, {"x": 0.902, "y": 0.8883}, {"x": 0.902, "y": 0.9136}, {"x": 0.0646, "y": 0.9136}], "id": 147, "page": 12}, {"category": "table", "content": {"html": "<table id='148' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>12</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 12 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 12 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0118, "y": 0.9482}, {"x": 0.9983, "y": 0.9482}, {"x": 0.9983, "y": 1}, {"x": 0.0118, "y": 1}], "id": 148, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='149' data-category='paragraph' style='font-size:20px'>The two faces together are then copied and rotated twice in order to generate the other four missing faces of<br>the cube:</p>", "markdown": "The two faces together are then copied and rotated twice in order to generate the other four missing faces of\nthe cube:", "text": "The two faces together are then copied and rotated twice in order to generate the other four missing faces of\nthe cube:"}, "coordinates": [{"x": 0.0761, "y": 0.0639}, {"x": 0.9089, "y": 0.0639}, {"x": 0.9089, "y": 0.0952}, {"x": 0.0761, "y": 0.0952}], "id": 149, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='150' data-category='paragraph' style='font-size:16px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);"}, "coordinates": [{"x": 0.1019, "y": 0.1249}, {"x": 0.8458, "y": 0.1249}, {"x": 0.8458, "y": 0.208}, {"x": 0.1019, "y": 0.208}], "id": 150, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='151' data-category='paragraph' style='font-size:20px'>At this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.<br>However, some points are coincident and need to be merged together:</p>", "markdown": "At this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.\nHowever, some points are coincident and need to be merged together:", "text": "At this stage, connectB has 432 columns, i.e. 432 triangles and matrix pos has 294 columns, i.e. 294 points.\nHowever, some points are coincident and need to be merged together:"}, "coordinates": [{"x": 0.076, "y": 0.2446}, {"x": 0.8981, "y": 0.2446}, {"x": 0.8981, "y": 0.2759}, {"x": 0.076, "y": 0.2759}], "id": 151, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='152' data-category='paragraph' style='font-size:16px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>", "markdown": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);", "text": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);"}, "coordinates": [{"x": 0.1048, "y": 0.3115}, {"x": 0.6588, "y": 0.3115}, {"x": 0.6588, "y": 0.3268}, {"x": 0.1048, "y": 0.3268}], "id": 152, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='153' data-category='paragraph' style='font-size:20px'>This function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the<br>index of the first node encountered replaces all the others subsequent coincident nodes14.</p>", "markdown": "This function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the\nindex of the first node encountered replaces all the others subsequent coincident nodes14.", "text": "This function has no effect on matrix pos only on connectB. When at least two nodes are coincident, the\nindex of the first node encountered replaces all the others subsequent coincident nodes14."}, "coordinates": [{"x": 0.0756, "y": 0.3676}, {"x": 0.8773, "y": 0.3676}, {"x": 0.8773, "y": 0.3986}, {"x": 0.0756, "y": 0.3986}], "id": 153, "page": 13}, {"category": "heading1", "content": {"html": "<h1 id='154' style='font-size:22px'>Tetrahedral mesh</h1>", "markdown": "# Tetrahedral mesh", "text": "Tetrahedral mesh"}, "coordinates": [{"x": 0.0774, "y": 0.4152}, {"x": 0.2715, "y": 0.4152}, {"x": 0.2715, "y": 0.4339}, {"x": 0.0774, "y": 0.4339}], "id": 154, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='155' data-category='paragraph' style='font-size:20px'>Now we have generated the boundary mesh, we can call the 3-D mesher on it:</p>", "markdown": "Now we have generated the boundary mesh, we can call the 3-D mesher on it:", "text": "Now we have generated the boundary mesh, we can call the 3-D mesher on it:"}, "coordinates": [{"x": 0.0778, "y": 0.4465}, {"x": 0.6734, "y": 0.4465}, {"x": 0.6734, "y": 0.4633}, {"x": 0.0778, "y": 0.4633}], "id": 155, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='156' data-category='paragraph' style='font-size:16px'>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>", "markdown": "tetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);", "text": "tetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.106, "y": 0.4989}, {"x": 0.5541, "y": 0.4989}, {"x": 0.5541, "y": 0.5227}, {"x": 0.106, "y": 0.5227}], "id": 156, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='157' data-category='paragraph' style='font-size:20px'>The difference with the previous example is that matrices pos and connect are built first and then passed to<br>the data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.<br>There is no significant difference between the two approaches. We can either modify directly data.pos and<br>data.connectB or build some separated matrices pos and connect and then pass them to the data<br>constructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -<br>overview.</p>", "markdown": "The difference with the previous example is that matrices pos and connect are built first and then passed to\nthe data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.\nThere is no significant difference between the two approaches. We can either modify directly data.pos and\ndata.connectB or build some separated matrices pos and connect and then pass them to the data\nconstructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -\noverview.", "text": "The difference with the previous example is that matrices pos and connect are built first and then passed to\nthe data structure whereas in Section 1 we loaded directly data.pos and data.connectB from the stream.\nThere is no significant difference between the two approaches. We can either modify directly data.pos and\ndata.connectB or build some separated matrices pos and connect and then pass them to the data\nconstructor. There is no hard copy done here, only shallow copies (data are shared). See manual CM2 Math1 -\noverview."}, "coordinates": [{"x": 0.077, "y": 0.5649}, {"x": 0.9118, "y": 0.5649}, {"x": 0.9118, "y": 0.6513}, {"x": 0.077, "y": 0.6513}], "id": 157, "page": 13}, {"category": "paragraph", "content": {"html": "<br><p id='158' data-category='paragraph' style='font-size:20px'>Upon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the<br>tetrahedral mesher on top of the initial surface points.</p>", "markdown": "Upon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the\ntetrahedral mesher on top of the initial surface points.", "text": "Upon exit, the matrix data.pos is bigger15 and contains all the new nodes generated inside the cube by the\ntetrahedral mesher on top of the initial surface points."}, "coordinates": [{"x": 0.0767, "y": 0.6621}, {"x": 0.8973, "y": 0.6621}, {"x": 0.8973, "y": 0.6933}, {"x": 0.0767, "y": 0.6933}], "id": 158, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='159' data-category='paragraph' style='font-size:14px'>14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify.</p>", "markdown": "14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify.", "text": "14 Note that this will leave some unused points in matrix pos. This space can be recovered using cm2::meshtools::simplify."}, "coordinates": [{"x": 0.0659, "y": 0.8825}, {"x": 0.8459, "y": 0.8825}, {"x": 0.8459, "y": 0.8943}, {"x": 0.0659, "y": 0.8943}], "id": 159, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='160' data-category='paragraph' style='font-size:14px'>15 But the pos matrix still has 294 columns.</p>", "markdown": "15 But the pos matrix still has 294 columns.", "text": "15 But the pos matrix still has 294 columns."}, "coordinates": [{"x": 0.0646, "y": 0.8991}, {"x": 0.3283, "y": 0.8991}, {"x": 0.3283, "y": 0.9125}, {"x": 0.0646, "y": 0.9125}], "id": 160, "page": 13}, {"category": "table", "content": {"html": "<table id='161' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>13</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 13 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 13 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0112, "y": 0.9481}, {"x": 0.999, "y": 0.9481}, {"x": 0.999, "y": 1}, {"x": 0.0112, "y": 1}], "id": 161, "page": 13}, {"category": "figure", "content": {"html": "<figure id='162'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58\" data-coord=\"top-left:(112,120); bottom-right:(1142,844)\" /></figure>", "markdown": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58", "text": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh(R) Iso (5.6.0.0) *\n*******************************************************\nHard nodes : 218/218\nHard edges : 648/648\nHard faces : 432/432\nNodes : 277\nTets : 900\nMissing faces : 0\nSubdomains : 1\nVolume : 6.400000E+01\nQmin : 4.930722E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.01 s.\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.02 s. (59999.58 th/s.)\n************ HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 900\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.000000E+00\nV mean : 6.972722E-01\nV min : 4.930722E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 11\n9 0.80 0.90 88\n8 0.70 0.80 373\n7 0.60 0.70 285\n6 0.50 0.60 142\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 277\nNEFS : 900\nTIME : 0.02 s.\nNEFS / s : 59999.58"}, "coordinates": [{"x": 0.0907, "y": 0.0689}, {"x": 0.9207, "y": 0.0689}, {"x": 0.9207, "y": 0.4815}, {"x": 0.0907, "y": 0.4815}], "id": 162, "page": 14}, {"category": "caption", "content": {"html": "<br><caption id='163' style='font-size:16px'>Figure 5 – Output info for the cube example.</caption>", "markdown": "Figure 5 – Output info for the cube example.", "text": "Figure 5 – Output info for the cube example."}, "coordinates": [{"x": 0.3623, "y": 0.4899}, {"x": 0.6367, "y": 0.4899}, {"x": 0.6367, "y": 0.5047}, {"x": 0.3623, "y": 0.5047}], "id": 163, "page": 14}, {"category": "figure", "content": {"html": "<figure id='164'><img style='font-size:14px' alt=\"************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(106,921); bottom-right:(1143,1439)\" /></figure>", "markdown": "![image](/image/placeholder)\n************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0", "text": "![image](/image/placeholder)\n************ HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 1392\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.480346E+00\nV mean : 9.585737E-01\nV min : 6.612180E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 2\n12 1.25 1.43 126\n11 1.11 1.25 162\n10 1.00 1.11 469\n9 0.90 1.00 109\n8 0.80 0.90 52\n7 0.70 0.80 467\n6 0.60 0.70 5\n5 0.50 0.60 0\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0"}, "coordinates": [{"x": 0.0857, "y": 0.5256}, {"x": 0.9215, "y": 0.5256}, {"x": 0.9215, "y": 0.8209}, {"x": 0.0857, "y": 0.8209}], "id": 164, "page": 14}, {"category": "caption", "content": {"html": "<caption id='165' style='font-size:16px'>Figure 6 – Histogram of the size-qualities of all the edges in the cube example.</caption>", "markdown": "Figure 6 – Histogram of the size-qualities of all the edges in the cube example.", "text": "Figure 6 – Histogram of the size-qualities of all the edges in the cube example."}, "coordinates": [{"x": 0.261, "y": 0.8306}, {"x": 0.7366, "y": 0.8306}, {"x": 0.7366, "y": 0.8446}, {"x": 0.261, "y": 0.8446}], "id": 165, "page": 14}, {"category": "table", "content": {"html": "<table id='166' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>14</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 14 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 14 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0086, "y": 0.9485}, {"x": 0.9979, "y": 0.9485}, {"x": 0.9979, "y": 1}, {"x": 0.0086, "y": 1}], "id": 166, "page": 14}, {"category": "heading1", "content": {"html": "<h1 id='167' style='font-size:20px'>3. Cube with an internal hard line</h1>", "markdown": "# 3. Cube with an internal hard line", "text": "3. Cube with an internal hard line"}, "coordinates": [{"x": 0.077, "y": 0.0633}, {"x": 0.5318, "y": 0.0633}, {"x": 0.5318, "y": 0.0875}, {"x": 0.077, "y": 0.0875}], "id": 167, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='168' data-category='paragraph' style='font-size:18px'>Starting from the previous example, we add a hard line inside the cube:</p>", "markdown": "Starting from the previous example, we add a hard line inside the cube:", "text": "Starting from the previous example, we add a hard line inside the cube:"}, "coordinates": [{"x": 0.0761, "y": 0.0986}, {"x": 0.6208, "y": 0.0986}, {"x": 0.6208, "y": 0.1156}, {"x": 0.0761, "y": 0.1156}], "id": 168, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='169' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1052, "y": 0.1521}, {"x": 0.2641, "y": 0.1521}, {"x": 0.2641, "y": 0.1645}, {"x": 0.1052, "y": 0.1645}], "id": 169, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='170' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1098, "y": 0.1723}, {"x": 0.1907, "y": 0.1723}, {"x": 0.1907, "y": 0.184}, {"x": 0.1098, "y": 0.184}], "id": 170, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='171' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.1826}, {"x": 0.1184, "y": 0.1826}, {"x": 0.1184, "y": 0.1933}, {"x": 0.1087, "y": 0.1933}], "id": 171, "page": 15}, {"category": "table", "content": {"html": "<br><table id='172' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6); // The discretization along each edge.</td></tr><tr><td>const double</td><td>L(4.); // The sides length.</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectE, connectB, connectB1, connectB2, connectM2;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr></tbody></table>", "markdown": "| const unsigned | N(6); // The discretization along each edge. |\n| --- | --- |\n| const double | L(4.); // The sides length. |\n| DoubleMat | pos; |\n| UIntMat | connectE, connectB, connectB1, connectB2, connectM2; |\n| UIntVec | indices; |\n", "text": "| const unsigned | N(6); // The discretization along each edge. |\n| --- | --- |\n| const double | L(4.); // The sides length. |\n| DoubleMat | pos; |\n| UIntMat | connectE, connectB, connectB1, connectB2, connectM2; |\n| UIntVec | indices; |\n"}, "coordinates": [{"x": 0.129, "y": 0.191}, {"x": 0.7238, "y": 0.191}, {"x": 0.7238, "y": 0.239}, {"x": 0.129, "y": 0.239}], "id": 172, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='173' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1317, "y": 0.2469}, {"x": 0.6978, "y": 0.2469}, {"x": 0.6978, "y": 0.2704}, {"x": 0.1317, "y": 0.2704}], "id": 173, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='174' data-category='paragraph' style='font-size:14px'>// BOUNDARY TRIANGLE MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);</p>", "markdown": "// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);", "text": "// BOUNDARY TRIANGLE MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB);"}, "coordinates": [{"x": 0.1335, "y": 0.2751}, {"x": 0.8611, "y": 0.2751}, {"x": 0.8611, "y": 0.318}, {"x": 0.1335, "y": 0.318}], "id": 174, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='175' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1324, "y": 0.3241}, {"x": 0.8376, "y": 0.3241}, {"x": 0.8376, "y": 0.3554}, {"x": 0.1324, "y": 0.3554}], "id": 175, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='176' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1322, "y": 0.3619}, {"x": 0.8512, "y": 0.3619}, {"x": 0.8512, "y": 0.3934}, {"x": 0.1322, "y": 0.3934}], "id": 176, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='177' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);<br>connectB.push_back(connectB2);</p>", "markdown": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);", "text": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2, L/2, L/2), DoubleVec3(0., 0., M_PI/2), connectB2);\nconnectB.push_back(connectB2);"}, "coordinates": [{"x": 0.1314, "y": 0.4001}, {"x": 0.8551, "y": 0.4001}, {"x": 0.8551, "y": 0.431}, {"x": 0.1314, "y": 0.431}], "id": 177, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='178' data-category='paragraph' style='font-size:14px'>indices.clear(); connectE.clear();<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);</p>", "markdown": "indices.clear(); connectE.clear();\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);", "text": "indices.clear(); connectE.clear();\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,L/2,L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);"}, "coordinates": [{"x": 0.131, "y": 0.4376}, {"x": 0.877, "y": 0.4376}, {"x": 0.877, "y": 0.4792}, {"x": 0.131, "y": 0.4792}], "id": 178, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='179' data-category='paragraph' style='font-size:14px'>// 3D MESH.</p>", "markdown": "// 3D MESH.", "text": "// 3D MESH."}, "coordinates": [{"x": 0.1346, "y": 0.4867}, {"x": 0.2178, "y": 0.4867}, {"x": 0.2178, "y": 0.4962}, {"x": 0.1346, "y": 0.4962}], "id": 179, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='180' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>data.connectE = connectE;<br>the_mesher.run(data);</p>", "markdown": "tetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.connectE = connectE;\nthe_mesher.run(data);", "text": "tetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.connectE = connectE;\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.132, "y": 0.4904}, {"x": 0.5773, "y": 0.4904}, {"x": 0.5773, "y": 0.5352}, {"x": 0.132, "y": 0.5352}], "id": 180, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='181' data-category='paragraph' style='font-size:14px'>// MESH VISUALIZATION.<br>meshtools::clip(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>", "markdown": "// MESH VISUALIZATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);", "text": "// MESH VISUALIZATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1297, "y": 0.5442}, {"x": 0.8118, "y": 0.5442}, {"x": 0.8118, "y": 0.5834}, {"x": 0.1297, "y": 0.5834}], "id": 181, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='182' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.1321, "y": 0.591}, {"x": 0.2067, "y": 0.591}, {"x": 0.2067, "y": 0.611}, {"x": 0.1321, "y": 0.611}], "id": 182, "page": 15}, {"category": "paragraph", "content": {"html": "<br><p id='183' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.6007}, {"x": 0.1184, "y": 0.6007}, {"x": 0.1184, "y": 0.6114}, {"x": 0.1087, "y": 0.6114}], "id": 183, "page": 15}, {"category": "table", "content": {"html": "<table id='184' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>15</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 15 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 15 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0036, "y": 0.948}, {"x": 0.9989, "y": 0.948}, {"x": 0.9989, "y": 1}, {"x": 0.0036, "y": 1}], "id": 184, "page": 15}, {"category": "figure", "content": {"html": "<figure id='185'><img alt=\"\" data-coord=\"top-left:(320,114); bottom-right:(916,601)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2583, "y": 0.0652}, {"x": 0.7388, "y": 0.0652}, {"x": 0.7388, "y": 0.3432}, {"x": 0.2583, "y": 0.3432}], "id": 185, "page": 16}, {"category": "caption", "content": {"html": "<br><caption id='186' style='font-size:14px'>Figure 7 – Half cube with internal line (mesh cut).</caption>", "markdown": "Figure 7 – Half cube with internal line (mesh cut).", "text": "Figure 7 – Half cube with internal line (mesh cut)."}, "coordinates": [{"x": 0.3492, "y": 0.3487}, {"x": 0.6485, "y": 0.3487}, {"x": 0.6485, "y": 0.3635}, {"x": 0.3492, "y": 0.3635}], "id": 186, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='187' data-category='paragraph' style='font-size:20px'>The mesh of the internal line is generated like the mesh of the first edge of the cube:</p>", "markdown": "The mesh of the internal line is generated like the mesh of the first edge of the cube:", "text": "The mesh of the internal line is generated like the mesh of the first edge of the cube:"}, "coordinates": [{"x": 0.0753, "y": 0.3979}, {"x": 0.7209, "y": 0.3979}, {"x": 0.7209, "y": 0.4157}, {"x": 0.0753, "y": 0.4157}], "id": 187, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='188' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);</p>", "markdown": "meshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);", "text": "meshtools2d::extrude_translate(pos, DoubleVec3(0., L/2, L/2), DoubleVec3(L,0,0), 4*N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);"}, "coordinates": [{"x": 0.1035, "y": 0.4507}, {"x": 0.8784, "y": 0.4507}, {"x": 0.8784, "y": 0.4759}, {"x": 0.1035, "y": 0.4759}], "id": 188, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='189' data-category='paragraph' style='font-size:20px'>This mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh<br>is four times finer along this line than on the cube edges, in order to make the line more visible and also to get<br>a graded mesh size.</p>", "markdown": "This mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh\nis four times finer along this line than on the cube edges, in order to make the line more visible and also to get\na graded mesh size.", "text": "This mesh line starts at the center of one of the faces of the cube and extends to the opposite face. The mesh\nis four times finer along this line than on the cube edges, in order to make the line more visible and also to get\na graded mesh size."}, "coordinates": [{"x": 0.0765, "y": 0.5167}, {"x": 0.9128, "y": 0.5167}, {"x": 0.9128, "y": 0.5613}, {"x": 0.0765, "y": 0.5613}], "id": 189, "page": 16}, {"category": "paragraph", "content": {"html": "<br><p id='190' data-category='paragraph' style='font-size:20px'>To avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two<br>matching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary<br>mesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is<br>done concurrently with the merging of the nodes of the edges of the cube already discussed in the previous<br>section:</p>", "markdown": "To avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two\nmatching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary\nmesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is\ndone concurrently with the merging of the nodes of the edges of the cube already discussed in the previous\nsection:", "text": "To avoid coincident nodes, a merging is needed between the two nodes at extremities of the line and the two\nmatching nodes of the boundary mesh. This is possible because there are actually two nodes of the boundary\nmesh with coordinates (0, L/2, L/2) and (L, L/2, L/2) due to the regular structured meshing of the faces. This is\ndone concurrently with the merging of the nodes of the edges of the cube already discussed in the previous\nsection:"}, "coordinates": [{"x": 0.0769, "y": 0.5714}, {"x": 0.9091, "y": 0.5714}, {"x": 0.9091, "y": 0.6438}, {"x": 0.0769, "y": 0.6438}], "id": 190, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='191' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);</p>", "markdown": "meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);", "text": "meshtools::merge(pos, connectB, connectE, /*tol=>*/ 1E-6);"}, "coordinates": [{"x": 0.1055, "y": 0.6812}, {"x": 0.579, "y": 0.6812}, {"x": 0.579, "y": 0.6971}, {"x": 0.1055, "y": 0.6971}], "id": 191, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='192' data-category='paragraph' style='font-size:20px'>The new internal prescribed edges are given to the mesher with:</p>", "markdown": "The new internal prescribed edges are given to the mesher with:", "text": "The new internal prescribed edges are given to the mesher with:"}, "coordinates": [{"x": 0.0764, "y": 0.7372}, {"x": 0.5663, "y": 0.7372}, {"x": 0.5663, "y": 0.7551}, {"x": 0.0764, "y": 0.7551}], "id": 192, "page": 16}, {"category": "figure", "content": {"html": "<figure id='193'><img style='font-size:14px' alt=\"data.connectE = connectE;\" data-coord=\"top-left:(106,1356); bottom-right:(1139,1437)\" /></figure>", "markdown": "![image](/image/placeholder)\ndata.connectE = connectE;", "text": "![image](/image/placeholder)\ndata.connectE = connectE;"}, "coordinates": [{"x": 0.0857, "y": 0.7731}, {"x": 0.9184, "y": 0.7731}, {"x": 0.9184, "y": 0.8196}, {"x": 0.0857, "y": 0.8196}], "id": 193, "page": 16}, {"category": "table", "content": {"html": "<table id='194' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>16</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 16 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 16 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0071, "y": 0.9483}, {"x": 0.9975, "y": 0.9483}, {"x": 0.9975, "y": 1}, {"x": 0.0071, "y": 1}], "id": 194, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='195' data-category='paragraph' style='font-size:20px'>To visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets<br>with at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.<br>pos, or on the connectivity matrix of the full mesh data.connectM:</p>", "markdown": "To visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets\nwith at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.\npos, or on the connectivity matrix of the full mesh data.connectM:", "text": "To visualize the internal line, we ask for a partial copy of the mesh in matrix connectM2 by removing all tets\nwith at least one node with Z coordinate greater than L/2. This has no effect on the coordinate matrix data.\npos, or on the connectivity matrix of the full mesh data.connectM:"}, "coordinates": [{"x": 0.0759, "y": 0.0639}, {"x": 0.8964, "y": 0.0639}, {"x": 0.8964, "y": 0.1096}, {"x": 0.0759, "y": 0.1096}], "id": 195, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='196' data-category='paragraph' style='font-size:14px'>meshtools::clip<br>(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>", "markdown": "meshtools::clip\n(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);", "text": "meshtools::clip\n(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2 + 1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1044, "y": 0.1486}, {"x": 0.6926, "y": 0.1486}, {"x": 0.6926, "y": 0.1989}, {"x": 0.1044, "y": 0.1989}], "id": 196, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='197' data-category='paragraph' style='font-size:20px'>To constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface<br>mesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard<br>faces into the matrix data.connectB for instance with a push-back (see next example).</p>", "markdown": "To constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface\nmesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard\nfaces into the matrix data.connectB for instance with a push-back (see next example).", "text": "To constrain an internal surface, almost the same scheme has to be followed: generation of the internal surface\nmesh, merging with the nodes of the boundary mesh if needed, and insertion of the connectivity of these hard\nfaces into the matrix data.connectB for instance with a push-back (see next example)."}, "coordinates": [{"x": 0.077, "y": 0.239}, {"x": 0.9236, "y": 0.239}, {"x": 0.9236, "y": 0.2855}, {"x": 0.077, "y": 0.2855}], "id": 197, "page": 17}, {"category": "table", "content": {"html": "<table id='198' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>17</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 17 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 17 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0033, "y": 0.9481}, {"x": 0.999, "y": 0.9481}, {"x": 0.999, "y": 1}, {"x": 0.0033, "y": 1}], "id": 198, "page": 17}, {"category": "heading1", "content": {"html": "<h1 id='199' style='font-size:20px'>4. Cube with an internal hard node</h1>", "markdown": "# 4. Cube with an internal hard node", "text": "4. Cube with an internal hard node"}, "coordinates": [{"x": 0.077, "y": 0.0636}, {"x": 0.5521, "y": 0.0636}, {"x": 0.5521, "y": 0.0875}, {"x": 0.077, "y": 0.0875}], "id": 199, "page": 18}, {"category": "paragraph", "content": {"html": "<p id='200' data-category='paragraph' style='font-size:18px'>There are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with<br>different or varying size on the boundary and interior surface or line, like in the previous example. The mesher<br>computes a size value on each hard node16, interpolates these values inside the domain and generates<br>elements accordingly.</p>", "markdown": "There are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with\ndifferent or varying size on the boundary and interior surface or line, like in the previous example. The mesher\ncomputes a size value on each hard node16, interpolates these values inside the domain and generates\nelements accordingly.", "text": "There are several ways to get graded sizes in a mesh. The simplest way is to generate faces or edges with\ndifferent or varying size on the boundary and interior surface or line, like in the previous example. The mesher\ncomputes a size value on each hard node16, interpolates these values inside the domain and generates\nelements accordingly."}, "coordinates": [{"x": 0.0766, "y": 0.0987}, {"x": 0.9104, "y": 0.0987}, {"x": 0.9104, "y": 0.1575}, {"x": 0.0766, "y": 0.1575}], "id": 200, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='201' data-category='paragraph' style='font-size:18px'>A second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all<br>the hard nodes. This is explained in this section.</p>", "markdown": "A second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all\nthe hard nodes. This is explained in this section.", "text": "A second way is to specify manually, in the data of the tetrahedral mesher, the target size values on some or all\nthe hard nodes. This is explained in this section."}, "coordinates": [{"x": 0.0756, "y": 0.1681}, {"x": 0.9166, "y": 0.1681}, {"x": 0.9166, "y": 0.1984}, {"x": 0.0756, "y": 0.1984}], "id": 201, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='202' data-category='paragraph' style='font-size:18px'>So far, we have seen only four fields of the data structure used by the mesher:</p>", "markdown": "So far, we have seen only four fields of the data structure used by the mesher:", "text": "So far, we have seen only four fields of the data structure used by the mesher:"}, "coordinates": [{"x": 0.0764, "y": 0.2083}, {"x": 0.678, "y": 0.2083}, {"x": 0.678, "y": 0.2251}, {"x": 0.0764, "y": 0.2251}], "id": 202, "page": 18}, {"category": "list", "content": {"html": "<br><p id='203' data-category='list' style='font-size:18px'>• The pos matrix for the coordinates of the points.<br>• The connectB matrix for the connectivity of the hard faces.<br>• The connectE matrix for the connectivity of the hard edges (seen in Example 2).<br>• The connectM matrix for the connectivity of the output 3-D mesh.</p>", "markdown": "- • The pos matrix for the coordinates of the points.\n- • The connectB matrix for the connectivity of the hard faces.\n- • The connectE matrix for the connectivity of the hard edges (seen in Example 2).\n- • The connectM matrix for the connectivity of the output 3-D mesh.\n", "text": "• The pos matrix for the coordinates of the points.\n• The connectB matrix for the connectivity of the hard faces.\n• The connectE matrix for the connectivity of the hard edges (seen in Example 2).\n• The connectM matrix for the connectivity of the output 3-D mesh."}, "coordinates": [{"x": 0.0842, "y": 0.2352}, {"x": 0.7121, "y": 0.2352}, {"x": 0.7121, "y": 0.2997}, {"x": 0.0842, "y": 0.2997}], "id": 203, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='204' data-category='paragraph' style='font-size:18px'>In this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target<br>size for the elements near this node. This is done using two new fields: isolated_nodes and metrics:</p>", "markdown": "In this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target\nsize for the elements near this node. This is done using two new fields: isolated_nodes and metrics:", "text": "In this example, we will add an isolated hard node (embedded) at the center of the cube and specify a target\nsize for the elements near this node. This is done using two new fields: isolated_nodes and metrics:"}, "coordinates": [{"x": 0.0759, "y": 0.3107}, {"x": 0.8976, "y": 0.3107}, {"x": 0.8976, "y": 0.3412}, {"x": 0.0759, "y": 0.3412}], "id": 204, "page": 18}, {"category": "paragraph", "content": {"html": "<p id='205' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.105, "y": 0.3777}, {"x": 0.2637, "y": 0.3777}, {"x": 0.2637, "y": 0.3898}, {"x": 0.105, "y": 0.3898}], "id": 205, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='206' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1098, "y": 0.3978}, {"x": 0.1908, "y": 0.3978}, {"x": 0.1908, "y": 0.4099}, {"x": 0.1098, "y": 0.4099}], "id": 206, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='207' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.4083}, {"x": 0.1184, "y": 0.4083}, {"x": 0.1184, "y": 0.419}, {"x": 0.1087, "y": 0.419}], "id": 207, "page": 18}, {"category": "table", "content": {"html": "<br><table id='208' style='font-size:14px'><thead></thead><tbody><tr><td>const unsigned</td><td>N(6);</td></tr><tr><td>const double</td><td>L(4.);</td></tr><tr><td>DoubleMat</td><td>pos(3, 1, L/2.);</td></tr><tr><td>UIntMat</td><td>connectB, connectB1, connectB2, connectE, connectM2;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr></tbody></table>", "markdown": "| const unsigned | N(6); |\n| --- | --- |\n| const double | L(4.); |\n| DoubleMat | pos(3, 1, L/2.); |\n| UIntMat | connectB, connectB1, connectB2, connectE, connectM2; |\n| UIntVec | indices; |\n", "text": "| const unsigned | N(6); |\n| --- | --- |\n| const double | L(4.); |\n| DoubleMat | pos(3, 1, L/2.); |\n| UIntMat | connectB, connectB1, connectB2, connectE, connectM2; |\n| UIntVec | indices; |\n"}, "coordinates": [{"x": 0.1328, "y": 0.4164}, {"x": 0.7177, "y": 0.4164}, {"x": 0.7177, "y": 0.466}, {"x": 0.1328, "y": 0.466}], "id": 208, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='209' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1319, "y": 0.4727}, {"x": 0.7, "y": 0.4727}, {"x": 0.7, "y": 0.4962}, {"x": 0.1319, "y": 0.4962}], "id": 209, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='210' data-category='paragraph' style='font-size:14px'>// BOUNDARY 2D MESH.<br>meshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,</p>", "markdown": "// BOUNDARY 2D MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,", "text": "// BOUNDARY 2D MESH.\nmeshtools2d::extrude_translate(pos, DoubleVec3(0,0,L), DoubleVec3(L,0,0), N,"}, "coordinates": [{"x": 0.1332, "y": 0.5017}, {"x": 0.7468, "y": 0.5017}, {"x": 0.7468, "y": 0.5245}, {"x": 0.1332, "y": 0.5245}], "id": 210, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='211' data-category='paragraph' style='font-size:14px'>indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,<br>connectB);</p>", "markdown": "indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,\nconnectB);", "text": "indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0,L,0), N, 2,\nconnectB);"}, "coordinates": [{"x": 0.1313, "y": 0.5252}, {"x": 0.7293, "y": 0.5252}, {"x": 0.7293, "y": 0.5591}, {"x": 0.1313, "y": 0.5591}], "id": 211, "page": 18}, {"category": "paragraph", "content": {"html": "<p id='212' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,M_PI,0), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1315, "y": 0.5685}, {"x": 0.7908, "y": 0.5685}, {"x": 0.7908, "y": 0.5997}, {"x": 0.1315, "y": 0.5997}], "id": 212, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='213' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(M_PI/2,0,0), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1322, "y": 0.6062}, {"x": 0.8048, "y": 0.6062}, {"x": 0.8048, "y": 0.6383}, {"x": 0.1322, "y": 0.6383}], "id": 213, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='214' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);<br>connectB.push_back(connectB2);<br>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>", "markdown": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);", "text": "meshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L/2,L/2,L/2), DoubleVec3(0,0,M_PI/2), connectB2);\nconnectB.push_back(connectB2);\nmeshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);"}, "coordinates": [{"x": 0.1319, "y": 0.6449}, {"x": 0.8047, "y": 0.6449}, {"x": 0.8047, "y": 0.6865}, {"x": 0.1319, "y": 0.6865}], "id": 214, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='215' data-category='paragraph' style='font-size:14px'>// 3D MESH.</p>", "markdown": "// 3D MESH.", "text": "// 3D MESH."}, "coordinates": [{"x": 0.1333, "y": 0.6918}, {"x": 0.2215, "y": 0.6918}, {"x": 0.2215, "y": 0.7027}, {"x": 0.1333, "y": 0.7027}], "id": 215, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='216' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>data.isolated_nodes.push_back(0);<br>data.metrics.resize(1, 0.05*L/N);<br>the_mesher.run(data);</p>", "markdown": "tetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.isolated_nodes.push_back(0);\ndata.metrics.resize(1, 0.05*L/N);\nthe_mesher.run(data);", "text": "tetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\ndata.isolated_nodes.push_back(0);\ndata.metrics.resize(1, 0.05*L/N);\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.1312, "y": 0.696}, {"x": 0.578, "y": 0.696}, {"x": 0.578, "y": 0.7507}, {"x": 0.1312, "y": 0.7507}], "id": 216, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='217' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(data.pos, data.connectM,<br>DoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>", "markdown": "// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);", "text": "// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM,\nDoubleVec3(0., 0., L/2+1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1307, "y": 0.759}, {"x": 0.7973, "y": 0.759}, {"x": 0.7973, "y": 0.8001}, {"x": 0.1307, "y": 0.8001}], "id": 217, "page": 18}, {"category": "paragraph", "content": {"html": "<br><p id='218' data-category='paragraph' style='font-size:14px'>return 0;<br>} // main</p>", "markdown": "return 0;\n} // main", "text": "return 0;\n} // main"}, "coordinates": [{"x": 0.1057, "y": 0.8068}, {"x": 0.207, "y": 0.8068}, {"x": 0.207, "y": 0.828}, {"x": 0.1057, "y": 0.828}], "id": 218, "page": 18}, {"category": "paragraph", "content": {"html": "<p id='219' data-category='paragraph' style='font-size:18px'>Initializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into<br>account by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:</p>", "markdown": "Initializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into\naccount by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:", "text": "Initializing pos as a 3 x 1 matrix with the value L/2 simply creates the central node17. This node is taken into\naccount by the mesher when its index (here zero) is inserted into the vector data.isolated nodes:"}, "coordinates": [{"x": 0.0761, "y": 0.8709}, {"x": 0.889, "y": 0.8709}, {"x": 0.889, "y": 0.9019}, {"x": 0.0761, "y": 0.9019}], "id": 219, "page": 18}, {"category": "table", "content": {"html": "<table id='220' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>18</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 18 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 18 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0176, "y": 0.9484}, {"x": 0.9982, "y": 0.9484}, {"x": 0.9982, "y": 1}, {"x": 0.0176, "y": 1}], "id": 220, "page": 18}, {"category": "heading1", "content": {"html": "<h1 id='221' style='font-size:16px'>data.isolated_nodes.push_back(0);</h1>", "markdown": "# data.isolated_nodes.push_back(0);", "text": "data.isolated_nodes.push_back(0);"}, "coordinates": [{"x": 0.1042, "y": 0.085}, {"x": 0.3757, "y": 0.085}, {"x": 0.3757, "y": 0.0993}, {"x": 0.1042, "y": 0.0993}], "id": 221, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='222' data-category='paragraph' style='font-size:20px'>The vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or<br>negative or not present), the automatically computed value will be used instead18. In this example the vector is<br>resized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:</p>", "markdown": "The vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or\nnegative or not present), the automatically computed value will be used instead18. In this example the vector is\nresized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:", "text": "The vector data.metrics stores the user-specified elements’ size. If the size value for a node is zero (or\nnegative or not present), the automatically computed value will be used instead18. In this example the vector is\nresized to 1 to set only a value for the node #0. We ask for a 20 times finer mesh around it:"}, "coordinates": [{"x": 0.0758, "y": 0.1409}, {"x": 0.9118, "y": 0.1409}, {"x": 0.9118, "y": 0.186}, {"x": 0.0758, "y": 0.186}], "id": 222, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='223' data-category='paragraph' style='font-size:16px'>data.metrics.resize(1, 0.05*L/N);</p>", "markdown": "data.metrics.resize(1, 0.05*L/N);", "text": "data.metrics.resize(1, 0.05*L/N);"}, "coordinates": [{"x": 0.1042, "y": 0.2221}, {"x": 0.3772, "y": 0.2221}, {"x": 0.3772, "y": 0.2373}, {"x": 0.1042, "y": 0.2373}], "id": 223, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='224' data-category='paragraph' style='font-size:20px'>For all the other nodes, we let the mesher compute suitable values.</p>", "markdown": "For all the other nodes, we let the mesher compute suitable values.", "text": "For all the other nodes, we let the mesher compute suitable values."}, "coordinates": [{"x": 0.0769, "y": 0.2777}, {"x": 0.5884, "y": 0.2777}, {"x": 0.5884, "y": 0.2951}, {"x": 0.0769, "y": 0.2951}], "id": 224, "page": 19}, {"category": "figure", "content": {"html": "<figure id='225'><img alt=\"\" data-coord=\"top-left:(317,543); bottom-right:(920,1095)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2561, "y": 0.3101}, {"x": 0.7419, "y": 0.3101}, {"x": 0.7419, "y": 0.6246}, {"x": 0.2561, "y": 0.6246}], "id": 225, "page": 19}, {"category": "caption", "content": {"html": "<br><caption id='226' style='font-size:16px'>Figure 8 – Half cube with internal hard node (mesh cut).</caption>", "markdown": "Figure 8 – Half cube with internal hard node (mesh cut).", "text": "Figure 8 – Half cube with internal hard node (mesh cut)."}, "coordinates": [{"x": 0.3264, "y": 0.6229}, {"x": 0.6703, "y": 0.6229}, {"x": 0.6703, "y": 0.6371}, {"x": 0.3264, "y": 0.6371}], "id": 226, "page": 19}, {"category": "list", "content": {"html": "<p id='227' data-category='list' style='font-size:14px'>16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.<br>17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));<br>18 For an isolated node, the computed size is based on the values of the nearest nodes.</p>", "markdown": "- 16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.\n- 17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));\n- 18 For an isolated node, the computed size is based on the values of the nearest nodes.\n", "text": "16 By averaging the lengths of the adjacent edges to each hard node and the inscribed radius of the triangles.\n17 Another way to do this is from an empty pos matrix is: pos.push_back(DoubleVec3(L/2, L/2, L/2));\n18 For an isolated node, the computed size is based on the values of the nearest nodes."}, "coordinates": [{"x": 0.0645, "y": 0.861}, {"x": 0.7424, "y": 0.861}, {"x": 0.7424, "y": 0.9134}, {"x": 0.0645, "y": 0.9134}], "id": 227, "page": 19}, {"category": "table", "content": {"html": "<table id='228' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>19</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0213, "y": 0.9482}, {"x": 0.9981, "y": 0.9482}, {"x": 0.9981, "y": 1}, {"x": 0.0213, "y": 1}], "id": 228, "page": 19}, {"category": "heading1", "content": {"html": "<h1 id='229' style='font-size:22px'>5. Internal cavity</h1>", "markdown": "# 5. Internal cavity", "text": "5. Internal cavity"}, "coordinates": [{"x": 0.0764, "y": 0.0636}, {"x": 0.3117, "y": 0.0636}, {"x": 0.3117, "y": 0.0882}, {"x": 0.0764, "y": 0.0882}], "id": 229, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='230' data-category='paragraph' style='font-size:20px'>A cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This<br>implies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we<br>have the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1.</p>", "markdown": "A cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This\nimplies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we\nhave the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1.", "text": "A cavity is an internal closed surface with triangles oriented the opposite way from the external boundary. This\nimplies that all triangles of the external boundary are similarly oriented19. To illustrate this point, we assume we\nhave the boundary mesh of a sphere ready on a file. The code for this example is similar to that of Example 1."}, "coordinates": [{"x": 0.0766, "y": 0.0985}, {"x": 0.9168, "y": 0.0985}, {"x": 0.9168, "y": 0.1441}, {"x": 0.0766, "y": 0.1441}], "id": 230, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='231' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"<br>#include <fstream></p>", "markdown": "#include \"stdafx.h\"\n#include <fstream>", "text": "#include \"stdafx.h\"\n#include <fstream>"}, "coordinates": [{"x": 0.1048, "y": 0.1806}, {"x": 0.2634, "y": 0.1806}, {"x": 0.2634, "y": 0.2021}, {"x": 0.1048, "y": 0.2021}], "id": 231, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='232' data-category='paragraph' style='font-size:16px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1093, "y": 0.2094}, {"x": 0.1905, "y": 0.2094}, {"x": 0.1905, "y": 0.2216}, {"x": 0.1093, "y": 0.2216}], "id": 232, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='233' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.2206}, {"x": 0.1184, "y": 0.2206}, {"x": 0.1184, "y": 0.2313}, {"x": 0.1087, "y": 0.2313}], "id": 233, "page": 20}, {"category": "table", "content": {"html": "<br><table id='234' style='font-size:16px'><thead></thead><tbody><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr><tr><td>std::ifstream</td><td>istrm(\"sphere.dat\");</td></tr></tbody></table>", "markdown": "| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n", "text": "| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n"}, "coordinates": [{"x": 0.1321, "y": 0.2292}, {"x": 0.4554, "y": 0.2292}, {"x": 0.4554, "y": 0.2591}, {"x": 0.1321, "y": 0.2591}], "id": 234, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='235' data-category='paragraph' style='font-size:16px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1311, "y": 0.2655}, {"x": 0.6981, "y": 0.2655}, {"x": 0.6981, "y": 0.2891}, {"x": 0.1311, "y": 0.2891}], "id": 235, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='236' data-category='paragraph' style='font-size:16px'>// READ THE BOUNDARY TRIANGLE MESH.<br>matio::read(istrm, pos);<br>matio::read(istrm, connectB);</p>", "markdown": "// READ THE BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);", "text": "// READ THE BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);"}, "coordinates": [{"x": 0.1309, "y": 0.2953}, {"x": 0.4156, "y": 0.2953}, {"x": 0.4156, "y": 0.3263}, {"x": 0.1309, "y": 0.3263}], "id": 236, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='237' data-category='paragraph' style='font-size:16px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>", "markdown": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);", "text": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.1321, "y": 0.3348}, {"x": 0.5764, "y": 0.3348}, {"x": 0.5764, "y": 0.3725}, {"x": 0.1321, "y": 0.3725}], "id": 237, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='238' data-category='paragraph' style='font-size:16px'>// MESH VISUALISATION.<br>meshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);</p>", "markdown": "// MESH VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);", "text": "// MESH VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA4);"}, "coordinates": [{"x": 0.1305, "y": 0.3801}, {"x": 0.7139, "y": 0.3801}, {"x": 0.7139, "y": 0.4032}, {"x": 0.1305, "y": 0.4032}], "id": 238, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='239' data-category='paragraph' style='font-size:16px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.128, "y": 0.4104}, {"x": 0.2075, "y": 0.4104}, {"x": 0.2075, "y": 0.4302}, {"x": 0.128, "y": 0.4302}], "id": 239, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='240' data-category='paragraph' style='font-size:16px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.4202}, {"x": 0.1184, "y": 0.4202}, {"x": 0.1184, "y": 0.4308}, {"x": 0.1087, "y": 0.4308}], "id": 240, "page": 20}, {"category": "figure", "content": {"html": "<figure id='241'><img style='font-size:16px' alt=\"Figure 9 – Full sphere.\" data-coord=\"top-left:(348,811); bottom-right:(897,1395)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 9 – Full sphere.", "text": "![image](/image/placeholder)\nFigure 9 – Full sphere."}, "coordinates": [{"x": 0.2807, "y": 0.4627}, {"x": 0.7235, "y": 0.4627}, {"x": 0.7235, "y": 0.7954}, {"x": 0.2807, "y": 0.7954}], "id": 241, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='242' data-category='paragraph' style='font-size:20px'>The surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing<br>the orientation of the triangles:</p>", "markdown": "The surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing\nthe orientation of the triangles:", "text": "The surface of the cavity is generated by shrinking a copy of the external boundary (with ratio ½) and reversing\nthe orientation of the triangles:"}, "coordinates": [{"x": 0.0743, "y": 0.8335}, {"x": 0.9139, "y": 0.8335}, {"x": 0.9139, "y": 0.8665}, {"x": 0.0743, "y": 0.8665}], "id": 242, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='243' data-category='paragraph' style='font-size:14px'>19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary.</p>", "markdown": "19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary.", "text": "19 Without any cavity, the orientation of the triangles of the external boundary can be arbitrary."}, "coordinates": [{"x": 0.0647, "y": 0.8983}, {"x": 0.6374, "y": 0.8983}, {"x": 0.6374, "y": 0.9135}, {"x": 0.0647, "y": 0.9135}], "id": 243, "page": 20}, {"category": "table", "content": {"html": "<table id='244' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>20</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 20 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 20 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0122, "y": 0.9477}, {"x": 0.9981, "y": 0.9477}, {"x": 0.9981, "y": 1}, {"x": 0.0122, "y": 1}], "id": 244, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='245' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <fstream></p>", "markdown": "#include \"stdafx.h\"\n#include <fstream>", "text": "#include \"stdafx.h\"\n#include <fstream>"}, "coordinates": [{"x": 0.1055, "y": 0.0859}, {"x": 0.2636, "y": 0.0859}, {"x": 0.2636, "y": 0.106}, {"x": 0.1055, "y": 0.106}], "id": 245, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='246' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.109, "y": 0.1142}, {"x": 0.1909, "y": 0.1142}, {"x": 0.1909, "y": 0.1263}, {"x": 0.109, "y": 0.1263}], "id": 246, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='247' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.1249}, {"x": 0.1184, "y": 0.1249}, {"x": 0.1184, "y": 0.1356}, {"x": 0.1087, "y": 0.1356}], "id": 247, "page": 21}, {"category": "table", "content": {"html": "<br><table id='248' style='font-size:14px'><thead></thead><tbody><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntMat</td><td>connectB, connectB2, connectM2;</td></tr><tr><td>std::ifstream</td><td>istrm(\"sphere.dat\");</td></tr></tbody></table>", "markdown": "| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB, connectB2, connectM2; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n", "text": "| DoubleMat | pos; |\n| --- | --- |\n| UIntMat | connectB, connectB2, connectM2; |\n| std::ifstream | istrm(\"sphere.dat\"); |\n"}, "coordinates": [{"x": 0.1307, "y": 0.1339}, {"x": 0.5452, "y": 0.1339}, {"x": 0.5452, "y": 0.1627}, {"x": 0.1307, "y": 0.1627}], "id": 248, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='249' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1313, "y": 0.1705}, {"x": 0.6984, "y": 0.1705}, {"x": 0.6984, "y": 0.1935}, {"x": 0.1313, "y": 0.1935}], "id": 249, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='250' data-category='paragraph' style='font-size:14px'>// OUTER BOUNDARY TRIANGLE MESH.<br>matio::read(istrm, pos);<br>matio::read(istrm, connectB);</p>", "markdown": "// OUTER BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);", "text": "// OUTER BOUNDARY TRIANGLE MESH.\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);"}, "coordinates": [{"x": 0.1313, "y": 0.2001}, {"x": 0.3891, "y": 0.2001}, {"x": 0.3891, "y": 0.2306}, {"x": 0.1313, "y": 0.2306}], "id": 250, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='251' data-category='paragraph' style='font-size:14px'>// INNER BOUNDARY.<br>meshtools::copy_mesh(pos, connectB2, connectB);<br>meshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);<br>meshtools2d::flip_T3(connectB2); // Reverse the orientation.<br>connectB.push_back(connectB2);</p>", "markdown": "// INNER BOUNDARY.\nmeshtools::copy_mesh(pos, connectB2, connectB);\nmeshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);\nmeshtools2d::flip_T3(connectB2); // Reverse the orientation.\nconnectB.push_back(connectB2);", "text": "// INNER BOUNDARY.\nmeshtools::copy_mesh(pos, connectB2, connectB);\nmeshtools::zoom(pos, DoubleVec3(0.), 0.5, connectB2);\nmeshtools2d::flip_T3(connectB2); // Reverse the orientation.\nconnectB.push_back(connectB2);"}, "coordinates": [{"x": 0.1304, "y": 0.2394}, {"x": 0.6586, "y": 0.2394}, {"x": 0.6586, "y": 0.2877}, {"x": 0.1304, "y": 0.2877}], "id": 251, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='252' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_iso::mesher the_mesher;<br>tetramesh_iso::mesher::data_type data(pos, connectB);<br>the_mesher.run(data);</p>", "markdown": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);", "text": "// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectB);\nthe_mesher.run(data);"}, "coordinates": [{"x": 0.1323, "y": 0.2962}, {"x": 0.5769, "y": 0.2962}, {"x": 0.5769, "y": 0.3344}, {"x": 0.1323, "y": 0.3344}], "id": 252, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='253' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>", "markdown": "// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);", "text": "// MESH VISUALISATION.\nmeshtools::clip(data.pos, data.connectM, DoubleVec3(0.), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1306, "y": 0.3414}, {"x": 0.8849, "y": 0.3414}, {"x": 0.8849, "y": 0.3733}, {"x": 0.1306, "y": 0.3733}], "id": 253, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='254' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.1299, "y": 0.3813}, {"x": 0.2073, "y": 0.3813}, {"x": 0.2073, "y": 0.4018}, {"x": 0.1299, "y": 0.4018}], "id": 254, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='255' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.391}, {"x": 0.1184, "y": 0.391}, {"x": 0.1184, "y": 0.4016}, {"x": 0.1087, "y": 0.4016}], "id": 255, "page": 21}, {"category": "figure", "content": {"html": "<figure id='256'><img alt=\"\" data-coord=\"top-left:(320,764); bottom-right:(925,1245)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2583, "y": 0.4359}, {"x": 0.7459, "y": 0.4359}, {"x": 0.7459, "y": 0.7103}, {"x": 0.2583, "y": 0.7103}], "id": 256, "page": 21}, {"category": "caption", "content": {"html": "<br><caption id='257' style='font-size:14px'>Figure 10 – Hollow sphere (mesh cut).</caption>", "markdown": "Figure 10 – Hollow sphere (mesh cut).", "text": "Figure 10 – Hollow sphere (mesh cut)."}, "coordinates": [{"x": 0.383, "y": 0.7076}, {"x": 0.6159, "y": 0.7076}, {"x": 0.6159, "y": 0.7219}, {"x": 0.383, "y": 0.7219}], "id": 257, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='258' data-category='paragraph' style='font-size:20px'>Note that the matrix connectB contains both the external and the internal faces.<br>Nested shells can be generated simply by changing the orientation of the spheres:</p>", "markdown": "Note that the matrix connectB contains both the external and the internal faces.\nNested shells can be generated simply by changing the orientation of the spheres:", "text": "Note that the matrix connectB contains both the external and the internal faces.\nNested shells can be generated simply by changing the orientation of the spheres:"}, "coordinates": [{"x": 0.0733, "y": 0.7554}, {"x": 0.7031, "y": 0.7554}, {"x": 0.7031, "y": 0.8019}, {"x": 0.0733, "y": 0.8019}], "id": 258, "page": 21}, {"category": "table", "content": {"html": "<table id='259' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>21</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 21 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 21 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0073, "y": 0.9477}, {"x": 0.9981, "y": 0.9477}, {"x": 0.9981, "y": 1}, {"x": 0.0073, "y": 1}], "id": 259, "page": 21}, {"category": "figure", "content": {"html": "<figure id='260'><img alt=\"\" data-coord=\"top-left:(320,112); bottom-right:(923,585)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2583, "y": 0.0641}, {"x": 0.7442, "y": 0.0641}, {"x": 0.7442, "y": 0.3338}, {"x": 0.2583, "y": 0.3338}], "id": 260, "page": 22}, {"category": "caption", "content": {"html": "<br><caption id='261' style='font-size:14px'>Figure 11 – Nested shells (mesh cut).</caption>", "markdown": "Figure 11 – Nested shells (mesh cut).", "text": "Figure 11 – Nested shells (mesh cut)."}, "coordinates": [{"x": 0.3851, "y": 0.3383}, {"x": 0.6122, "y": 0.3383}, {"x": 0.6122, "y": 0.3525}, {"x": 0.3851, "y": 0.3525}], "id": 261, "page": 22}, {"category": "table", "content": {"html": "<table id='262' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>22</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 22 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 22 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.003, "y": 0.9481}, {"x": 0.9998, "y": 0.9481}, {"x": 0.9998, "y": 1}, {"x": 0.003, "y": 1}], "id": 262, "page": 22}, {"category": "heading1", "content": {"html": "<h1 id='263' style='font-size:22px'>6. Quadratic elements & high-order nodes</h1>", "markdown": "# 6. Quadratic elements & high-order nodes", "text": "6. Quadratic elements & high-order nodes"}, "coordinates": [{"x": 0.077, "y": 0.0635}, {"x": 0.6591, "y": 0.0635}, {"x": 0.6591, "y": 0.0887}, {"x": 0.077, "y": 0.0887}], "id": 263, "page": 23}, {"category": "paragraph", "content": {"html": "<br><p id='264' data-category='paragraph' style='font-size:20px'>Let us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here<br>again that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6<br>elements can be curved or not.</p>", "markdown": "Let us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here\nagain that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6\nelements can be curved or not.", "text": "Let us derive the Example 5 to generate quadratic TH10 elements. To make things simple, we assume here\nagain that the surface mesh of the sphere (here T6 elements) are ready on a file to be read. These quadratic T6\nelements can be curved or not."}, "coordinates": [{"x": 0.0761, "y": 0.0985}, {"x": 0.918, "y": 0.0985}, {"x": 0.918, "y": 0.1433}, {"x": 0.0761, "y": 0.1433}], "id": 264, "page": 23}, {"category": "figure", "content": {"html": "<figure id='265'><img style='font-size:16px' alt=\"#include 'stdafx.h'\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm('sphere_t6.dat');\n// UNLOCK THE DLL.\ntetramesh_iso::registration('Licensed to SMART Inc.', 'F53EA108BCWX');\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output('TH.mesh', data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main\" data-coord=\"top-left:(102,280); bottom-right:(1143,822)\" /></figure>", "markdown": "![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm(\"sphere_t6.dat\");\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main", "text": "![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nDoubleMat pos;\nUIntMat connectB, connectT3;\nstd::ifstream istrm(\"sphere_t6.dat\");\n// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");\n// READ THE BOUNDARY TRIANGLE MESH (EXPECTED T6 FACES).\nmatio::read(istrm, pos);\nmatio::read(istrm, connectB);\nconnectT3 = connectB.sub_matrix(0, 0, 3, connectB.cols()); // Linear T3s.\n// 3D MESH.\ntetramesh_iso::mesher the_mesher;\ntetramesh_iso::mesher::data_type data(pos, connectT3);\nthe_mesher.run(data);\nmeshtools3d::convert_into_quadratic(data.pos, data.connectM, connectB, UIntMat());\n// VISUALISATION.\nmeshtools::medit_output(\"TH.mesh\", data.pos, data.connectM, CM2_TETRA10);\nreturn 0;\n} // main"}, "coordinates": [{"x": 0.0824, "y": 0.16}, {"x": 0.9213, "y": 0.16}, {"x": 0.9213, "y": 0.4688}, {"x": 0.0824, "y": 0.4688}], "id": 265, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='266' data-category='paragraph' style='font-size:20px'>The mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,<br>we have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the<br>above example (view to the first 3 rows from index 0, 0)20.</p>", "markdown": "The mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,\nwe have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the\nabove example (view to the first 3 rows from index 0, 0)20.", "text": "The mesh generator accepts only linear faces upon entry and give only linear solid elements upon exit. Hence,\nwe have to feed the mesher with the linear view of the connectB connectivity matrix, called connectT3 in the\nabove example (view to the first 3 rows from index 0, 0)20."}, "coordinates": [{"x": 0.0763, "y": 0.4929}, {"x": 0.9158, "y": 0.4929}, {"x": 0.9158, "y": 0.5376}, {"x": 0.0763, "y": 0.5376}], "id": 266, "page": 23}, {"category": "paragraph", "content": {"html": "<br><p id='267' data-category='paragraph' style='font-size:20px'>After the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:</p>", "markdown": "After the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:", "text": "After the solid meshing, to transform the TH4 mesh into a TH10 mesh we could simply call21:"}, "coordinates": [{"x": 0.0761, "y": 0.547}, {"x": 0.7756, "y": 0.547}, {"x": 0.7756, "y": 0.5648}, {"x": 0.0761, "y": 0.5648}], "id": 267, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='268' data-category='paragraph' style='font-size:16px'>meshtools3d::convert_into_quadratic(data.pos, data.connectM);</p>", "markdown": "meshtools3d::convert_into_quadratic(data.pos, data.connectM);", "text": "meshtools3d::convert_into_quadratic(data.pos, data.connectM);"}, "coordinates": [{"x": 0.1051, "y": 0.6006}, {"x": 0.6027, "y": 0.6006}, {"x": 0.6027, "y": 0.6145}, {"x": 0.1051, "y": 0.6145}], "id": 268, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='269' data-category='paragraph' style='font-size:20px'>But in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an<br>overload function with additional matrix parameters:</p>", "markdown": "But in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an\noverload function with additional matrix parameters:", "text": "But in order to reuse the quadratic nodes along the boundaries (and keeping curved faces if any), we use an\noverload function with additional matrix parameters:"}, "coordinates": [{"x": 0.0763, "y": 0.6568}, {"x": 0.8965, "y": 0.6568}, {"x": 0.8965, "y": 0.6875}, {"x": 0.0763, "y": 0.6875}], "id": 269, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='270' data-category='paragraph' style='font-size:16px'>meshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());</p>", "markdown": "meshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());", "text": "meshtools3d::convert_into_high_order(data.pos, data.connectM, connectB, UIntMat());"}, "coordinates": [{"x": 0.1052, "y": 0.7239}, {"x": 0.7809, "y": 0.7239}, {"x": 0.7809, "y": 0.7387}, {"x": 0.1052, "y": 0.7387}], "id": 270, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='271' data-category='paragraph' style='font-size:20px'>This forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match<br>(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of<br>the tetrahedrons in data.connectM).</p>", "markdown": "This forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match\n(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of\nthe tetrahedrons in data.connectM).", "text": "This forces convert_into_quadratic to use the high-order nodes of connectB wherever faces match\n(connectB is allowed to contain outer boundary faces but also inner embedded boundary faces or any face of\nthe tetrahedrons in data.connectM)."}, "coordinates": [{"x": 0.0774, "y": 0.7807}, {"x": 0.9178, "y": 0.7807}, {"x": 0.9178, "y": 0.8249}, {"x": 0.0774, "y": 0.8249}], "id": 271, "page": 23}, {"category": "footnote", "content": {"html": "<p id='272' data-category='footnote' style='font-size:14px'>20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension).</p>", "markdown": "20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension).", "text": "20 The two matrices share the same data. Only dimensions differ (number of rows and leading dimension)."}, "coordinates": [{"x": 0.0649, "y": 0.8687}, {"x": 0.7037, "y": 0.8687}, {"x": 0.7037, "y": 0.8831}, {"x": 0.0649, "y": 0.8831}], "id": 272, "page": 23}, {"category": "footnote", "content": {"html": "<p id='273' data-category='footnote' style='font-size:14px'>21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_<br>order. Refer to the HTML reference manual for detailed information.</p>", "markdown": "21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_\norder. Refer to the HTML reference manual for detailed information.", "text": "21 A more general function is available to convert into any type of high-order elements:. cm2::meshtools3d::convert_into_high_\norder. Refer to the HTML reference manual for detailed information."}, "coordinates": [{"x": 0.0646, "y": 0.8885}, {"x": 0.8856, "y": 0.8885}, {"x": 0.8856, "y": 0.912}, {"x": 0.0646, "y": 0.912}], "id": 273, "page": 23}, {"category": "table", "content": {"html": "<table id='274' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>23</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 23 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 23 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0117, "y": 0.9483}, {"x": 0.9985, "y": 0.9483}, {"x": 0.9985, "y": 1}, {"x": 0.0117, "y": 1}], "id": 274, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='275' data-category='paragraph' style='font-size:20px'>The connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the<br>linear faces)22.</p>", "markdown": "The connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the\nlinear faces)22.", "text": "The connectivity matrix connectB has 6 rows. The first three rows are the linear view (first three nodes of the\nlinear faces)22."}, "coordinates": [{"x": 0.0751, "y": 0.0637}, {"x": 0.9102, "y": 0.0637}, {"x": 0.9102, "y": 0.0954}, {"x": 0.0751, "y": 0.0954}], "id": 275, "page": 24}, {"category": "paragraph", "content": {"html": "<p id='276' data-category='paragraph' style='font-size:16px'>Linear nodes</p>", "markdown": "Linear nodes", "text": "Linear nodes"}, "coordinates": [{"x": 0.1001, "y": 0.1352}, {"x": 0.1882, "y": 0.1352}, {"x": 0.1882, "y": 0.1491}, {"x": 0.1001, "y": 0.1491}], "id": 276, "page": 24}, {"category": "table", "content": {"html": "<br><table id='277' style='font-size:18px'><thead></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>5</td><td>5</td><td>1</td><td>3</td><td>4</td></tr><tr><td>1</td><td>3</td><td>3</td><td>2</td><td>0</td><td>6</td><td>6</td><td>3</td></tr><tr><td>2</td><td>2</td><td>4</td><td>4</td><td>2</td><td>3</td><td>7</td><td>7</td></tr><tr><td>8</td><td>11</td><td>13</td><td>14</td><td>9</td><td>18</td><td>20</td><td>21</td></tr><tr><td>9</td><td>8</td><td>14</td><td>15</td><td>16</td><td>12</td><td>21</td><td>22</td></tr><tr><td>10</td><td>12</td><td>11</td><td>16</td><td>17</td><td>19</td><td>18</td><td>13</td></tr></tbody></table>", "markdown": "| 0 | 1 | 2 | 5 | 5 | 1 | 3 | 4 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 3 | 3 | 2 | 0 | 6 | 6 | 3 |\n| 2 | 2 | 4 | 4 | 2 | 3 | 7 | 7 |\n| 8 | 11 | 13 | 14 | 9 | 18 | 20 | 21 |\n| 9 | 8 | 14 | 15 | 16 | 12 | 21 | 22 |\n| 10 | 12 | 11 | 16 | 17 | 19 | 18 | 13 |\n", "text": "| 0 | 1 | 2 | 5 | 5 | 1 | 3 | 4 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 3 | 3 | 2 | 0 | 6 | 6 | 3 |\n| 2 | 2 | 4 | 4 | 2 | 3 | 7 | 7 |\n| 8 | 11 | 13 | 14 | 9 | 18 | 20 | 21 |\n| 9 | 8 | 14 | 15 | 16 | 12 | 21 | 22 |\n| 10 | 12 | 11 | 16 | 17 | 19 | 18 | 13 |\n"}, "coordinates": [{"x": 0.211, "y": 0.1121}, {"x": 0.7864, "y": 0.1121}, {"x": 0.7864, "y": 0.2238}, {"x": 0.211, "y": 0.2238}], "id": 277, "page": 24}, {"category": "paragraph", "content": {"html": "<p id='278' data-category='paragraph' style='font-size:16px'>Figure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3).</p>", "markdown": "Figure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3).", "text": "Figure 12 – Example of connectivity matrix for quadratic faces (connectB) and view to linear faces (connectT3)."}, "coordinates": [{"x": 0.1575, "y": 0.2346}, {"x": 0.8412, "y": 0.2346}, {"x": 0.8412, "y": 0.2491}, {"x": 0.1575, "y": 0.2491}], "id": 278, "page": 24}, {"category": "footer", "content": {"html": "<footer id='279' style='font-size:20px'>The connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_<br>quadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons).</footer>", "markdown": "The connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_\nquadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons).", "text": "The connectivity matrix data.connectM has 4 rows after the TetraMesh run, 10 rows after convert_into_\nquadratic. The first four rows are the linear view (first four nodes of the linear tetrahedrons)."}, "coordinates": [{"x": 0.0763, "y": 0.2847}, {"x": 0.907, "y": 0.2847}, {"x": 0.907, "y": 0.3155}, {"x": 0.0763, "y": 0.3155}], "id": 279, "page": 24}, {"category": "paragraph", "content": {"html": "<p id='280' data-category='paragraph' style='font-size:14px'>22 The empty matrix parameter stands for specific high-order edges. Here none of them.</p>", "markdown": "22 The empty matrix parameter stands for specific high-order edges. Here none of them.", "text": "22 The empty matrix parameter stands for specific high-order edges. Here none of them."}, "coordinates": [{"x": 0.0627, "y": 0.8987}, {"x": 0.5998, "y": 0.8987}, {"x": 0.5998, "y": 0.9131}, {"x": 0.0627, "y": 0.9131}], "id": 280, "page": 24}, {"category": "table", "content": {"html": "<table id='281' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>24</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 24 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 24 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0088, "y": 0.9479}, {"x": 0.9981, "y": 0.9479}, {"x": 0.9981, "y": 1}, {"x": 0.0088, "y": 1}], "id": 281, "page": 24}, {"category": "heading1", "content": {"html": "<h1 id='282' style='font-size:20px'>7. Multiple meshes</h1>", "markdown": "# 7. Multiple meshes", "text": "7. Multiple meshes"}, "coordinates": [{"x": 0.0779, "y": 0.0637}, {"x": 0.3405, "y": 0.0637}, {"x": 0.3405, "y": 0.0872}, {"x": 0.0779, "y": 0.0872}], "id": 282, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='283' data-category='paragraph' style='font-size:18px'>As seen before, matrix connectB can contain several internal surfaces. It can also contain several external<br>boundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the<br>previous example, some care must be taken in the orientation of these surfaces. They must be oriented the<br>same way (for instance all normal outside) and these boundaries must not cross each other.</p>", "markdown": "As seen before, matrix connectB can contain several internal surfaces. It can also contain several external\nboundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the\nprevious example, some care must be taken in the orientation of these surfaces. They must be oriented the\nsame way (for instance all normal outside) and these boundaries must not cross each other.", "text": "As seen before, matrix connectB can contain several internal surfaces. It can also contain several external\nboundary surfaces. This means that several disconnected domains can be meshed simultaneously. As in the\nprevious example, some care must be taken in the orientation of these surfaces. They must be oriented the\nsame way (for instance all normal outside) and these boundaries must not cross each other."}, "coordinates": [{"x": 0.0762, "y": 0.0989}, {"x": 0.8959, "y": 0.0989}, {"x": 0.8959, "y": 0.1576}, {"x": 0.0762, "y": 0.1576}], "id": 283, "page": 25}, {"category": "figure", "content": {"html": "<figure id='284'><img alt=\"\" data-coord=\"top-left:(127,326); bottom-right:(1110,710)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.1028, "y": 0.1864}, {"x": 0.8948, "y": 0.1864}, {"x": 0.8948, "y": 0.4051}, {"x": 0.1028, "y": 0.4051}], "id": 284, "page": 25}, {"category": "caption", "content": {"html": "<br><caption id='285' style='font-size:14px'>Figure 13 – Multiple disconnected sub-domains.</caption>", "markdown": "Figure 13 – Multiple disconnected sub-domains.", "text": "Figure 13 – Multiple disconnected sub-domains."}, "coordinates": [{"x": 0.3511, "y": 0.4101}, {"x": 0.6471, "y": 0.4101}, {"x": 0.6471, "y": 0.4235}, {"x": 0.3511, "y": 0.4235}], "id": 285, "page": 25}, {"category": "table", "content": {"html": "<table id='286' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>25</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 25 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 25 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0031, "y": 0.9481}, {"x": 0.9993, "y": 0.9481}, {"x": 0.9993, "y": 1}, {"x": 0.0031, "y": 1}], "id": 286, "page": 25}, {"category": "heading1", "content": {"html": "<h1 id='287' style='font-size:22px'>8. Repairing the boundary mesh</h1>", "markdown": "# 8. Repairing the boundary mesh", "text": "8. Repairing the boundary mesh"}, "coordinates": [{"x": 0.0774, "y": 0.0638}, {"x": 0.5164, "y": 0.0638}, {"x": 0.5164, "y": 0.0886}, {"x": 0.0774, "y": 0.0886}], "id": 287, "page": 26}, {"category": "paragraph", "content": {"html": "<br><p id='288' data-category='paragraph' style='font-size:20px'>It is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not<br>watertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes.</p>", "markdown": "It is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not\nwatertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes.", "text": "It is a well-known CAD problem that the boundary meshes may sometimes be not perfectly closed (not\nwatertight). In addition, gaps and overlapping elements can be found in 3-D surface meshes."}, "coordinates": [{"x": 0.0758, "y": 0.0988}, {"x": 0.8554, "y": 0.0988}, {"x": 0.8554, "y": 0.1295}, {"x": 0.0758, "y": 0.1295}], "id": 288, "page": 26}, {"category": "paragraph", "content": {"html": "<br><p id='289' data-category='paragraph' style='font-size:20px'>CM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23.</p>", "markdown": "CM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23.", "text": "CM2 TetraMesh Iso/Aniso have a correction algorithm that can repair some of these pathologies23."}, "coordinates": [{"x": 0.076, "y": 0.1391}, {"x": 0.8216, "y": 0.1391}, {"x": 0.8216, "y": 0.1559}, {"x": 0.076, "y": 0.1559}], "id": 289, "page": 26}, {"category": "paragraph", "content": {"html": "<br><p id='290' data-category='paragraph' style='font-size:20px'>To illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple<br>extrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some<br>nodes are also coincident.</p>", "markdown": "To illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple\nextrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some\nnodes are also coincident.", "text": "To illustrate this point we take two cylinders that intersect each other. The cylinders are generated by simple\nextrusion of a circle. They are not closed at their extremities and several triangles intersect each others. Some\nnodes are also coincident."}, "coordinates": [{"x": 0.077, "y": 0.1655}, {"x": 0.9091, "y": 0.1655}, {"x": 0.9091, "y": 0.2099}, {"x": 0.077, "y": 0.2099}], "id": 290, "page": 26}, {"category": "figure", "content": {"html": "<figure id='291'><img style='font-size:16px' alt=\"Figure 14 – Intersecting meshes.\" data-coord=\"top-left:(164,392); bottom-right:(1079,969)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 14 – Intersecting meshes.", "text": "![image](/image/placeholder)\nFigure 14 – Intersecting meshes."}, "coordinates": [{"x": 0.1327, "y": 0.2238}, {"x": 0.8699, "y": 0.2238}, {"x": 0.8699, "y": 0.5528}, {"x": 0.1327, "y": 0.5528}], "id": 291, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='292' data-category='paragraph' style='font-size:20px'>In strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,<br>they remove the intersecting and overlapping triangles and fill all the gaps.</p>", "markdown": "In strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,\nthey remove the intersecting and overlapping triangles and fill all the gaps.", "text": "In strict-constraint mode (see reference manual), the generators would stop with an error. In non-strict mode,\nthey remove the intersecting and overlapping triangles and fill all the gaps."}, "coordinates": [{"x": 0.0756, "y": 0.5932}, {"x": 0.9098, "y": 0.5932}, {"x": 0.9098, "y": 0.6244}, {"x": 0.0756, "y": 0.6244}], "id": 292, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='293' data-category='paragraph' style='font-size:14px'>23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual).</p>", "markdown": "23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual).", "text": "23 This algorithm is effective only in MESH_MODE and non-strict constraints mode (see reference manual)."}, "coordinates": [{"x": 0.0634, "y": 0.8987}, {"x": 0.6966, "y": 0.8987}, {"x": 0.6966, "y": 0.9132}, {"x": 0.0634, "y": 0.9132}], "id": 293, "page": 26}, {"category": "table", "content": {"html": "<table id='294' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>26</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 26 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 26 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0106, "y": 0.9477}, {"x": 0.9982, "y": 0.9477}, {"x": 0.9982, "y": 1}, {"x": 0.0106, "y": 1}], "id": 294, "page": 26}, {"category": "figure", "content": {"html": "<figure id='295'><img alt=\"\" data-coord=\"top-left:(406,97); bottom-right:(841,678)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3275, "y": 0.0558}, {"x": 0.6783, "y": 0.0558}, {"x": 0.6783, "y": 0.3868}, {"x": 0.3275, "y": 0.3868}], "id": 295, "page": 27}, {"category": "paragraph", "content": {"html": "<br><p id='296' data-category='paragraph' style='font-size:14px'>Figure 15 – Repaired mesh.</p>", "markdown": "Figure 15 – Repaired mesh.", "text": "Figure 15 – Repaired mesh."}, "coordinates": [{"x": 0.4158, "y": 0.3834}, {"x": 0.5842, "y": 0.3834}, {"x": 0.5842, "y": 0.3948}, {"x": 0.4158, "y": 0.3948}], "id": 296, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='297' data-category='paragraph' style='font-size:20px'>Note that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry<br>of the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by<br>adding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials.</p>", "markdown": "Note that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry\nof the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by\nadding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials.", "text": "Note that the repairing algorithm uses only the hard nodes of the initial mesh and usually change the geometry\nof the surface. A more specific tool, called CM2 Intersect® T3 can fix intersections much more precisely by\nadding new nodes at intersection points (but doesn’t close open gaps). See CM2 Intersect T3 - tutorials."}, "coordinates": [{"x": 0.0767, "y": 0.4298}, {"x": 0.9227, "y": 0.4298}, {"x": 0.9227, "y": 0.4767}, {"x": 0.0767, "y": 0.4767}], "id": 297, "page": 27}, {"category": "table", "content": {"html": "<table id='298' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>27</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 27 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 27 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.003, "y": 0.9481}, {"x": 0.9994, "y": 0.9481}, {"x": 0.9994, "y": 1}, {"x": 0.003, "y": 1}], "id": 298, "page": 27}, {"category": "heading1", "content": {"html": "<h1 id='299' style='font-size:20px'>9. Background mesh</h1>", "markdown": "# 9. Background mesh", "text": "9. Background mesh"}, "coordinates": [{"x": 0.0774, "y": 0.0645}, {"x": 0.3616, "y": 0.0645}, {"x": 0.3616, "y": 0.0875}, {"x": 0.0774, "y": 0.0875}], "id": 299, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='300' data-category='paragraph' style='font-size:18px'>Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially<br>when automatic mesh adaptivity is involved. The background mesh option is the solution in this case.</p>", "markdown": "Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.", "text": "Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case."}, "coordinates": [{"x": 0.0757, "y": 0.0987}, {"x": 0.9118, "y": 0.0987}, {"x": 0.9118, "y": 0.1295}, {"x": 0.0757, "y": 0.1295}], "id": 300, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='301' data-category='paragraph' style='font-size:18px'>The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside<br>the domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher.</p>", "markdown": "The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher.", "text": "The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It’s represented by the connectivity matrix background_mesh in the data of the mesher."}, "coordinates": [{"x": 0.0766, "y": 0.1393}, {"x": 0.9112, "y": 0.1393}, {"x": 0.9112, "y": 0.1704}, {"x": 0.0766, "y": 0.1704}], "id": 301, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='302' data-category='paragraph' style='font-size:18px'>As always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices<br>or vectors (such as connectM or connectB).</p>", "markdown": "As always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices\nor vectors (such as connectM or connectB).", "text": "As always, the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices\nor vectors (such as connectM or connectB)."}, "coordinates": [{"x": 0.0762, "y": 0.18}, {"x": 0.9043, "y": 0.18}, {"x": 0.9043, "y": 0.2099}, {"x": 0.0762, "y": 0.2099}], "id": 302, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='303' data-category='paragraph' style='font-size:18px'>The nodes of the background mesh can be all different from the nodes of connectB or some can be common.<br>They must all have a valid associated size value in the metrics array. The size map (also called metrics map) is<br>interpolated inside the background mesh.</p>", "markdown": "The nodes of the background mesh can be all different from the nodes of connectB or some can be common.\nThey must all have a valid associated size value in the metrics array. The size map (also called metrics map) is\ninterpolated inside the background mesh.", "text": "The nodes of the background mesh can be all different from the nodes of connectB or some can be common.\nThey must all have a valid associated size value in the metrics array. The size map (also called metrics map) is\ninterpolated inside the background mesh."}, "coordinates": [{"x": 0.0762, "y": 0.2201}, {"x": 0.9164, "y": 0.2201}, {"x": 0.9164, "y": 0.2645}, {"x": 0.0762, "y": 0.2645}], "id": 303, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='304' data-category='paragraph' style='font-size:18px'>In the following example, a simple regular background mesh is used to support a sinusoidal metrics map<br>varying in the three directions. The domain to be meshed is a simple cube regularly discretized on its<br>boundaries.</p>", "markdown": "In the following example, a simple regular background mesh is used to support a sinusoidal metrics map\nvarying in the three directions. The domain to be meshed is a simple cube regularly discretized on its\nboundaries.", "text": "In the following example, a simple regular background mesh is used to support a sinusoidal metrics map\nvarying in the three directions. The domain to be meshed is a simple cube regularly discretized on its\nboundaries."}, "coordinates": [{"x": 0.0771, "y": 0.2753}, {"x": 0.8703, "y": 0.2753}, {"x": 0.8703, "y": 0.3185}, {"x": 0.0771, "y": 0.3185}], "id": 304, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='305' data-category='paragraph' style='font-size:18px'>To simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a<br>cube centered at the origin.</p>", "markdown": "To simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a\ncube centered at the origin.", "text": "To simplify the program, we use the auxiliary function cube_boundary to generate the boundary mesh of a\ncube centered at the origin."}, "coordinates": [{"x": 0.0761, "y": 0.3299}, {"x": 0.8967, "y": 0.3299}, {"x": 0.8967, "y": 0.3604}, {"x": 0.0761, "y": 0.3604}], "id": 305, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='306' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1051, "y": 0.396}, {"x": 0.2643, "y": 0.396}, {"x": 0.2643, "y": 0.4101}, {"x": 0.1051, "y": 0.4101}], "id": 306, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='307' data-category='paragraph' style='font-size:14px'>// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),<br>// with edge length equal to \"L\" and with \"N\" elements along each edge.<br>void<br>cube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)</p>", "markdown": "// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),\n// with edge length equal to \"L\" and with \"N\" elements along each edge.\nvoid\ncube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)", "text": "// Auxiliary function to generate the 6 faces of a cube centered at (0,0,0),\n// with edge length equal to \"L\" and with \"N\" elements along each edge.\nvoid\ncube_boundary (double L, unsigned N, DoubleMat& pos, UIntMat& connectB)"}, "coordinates": [{"x": 0.1068, "y": 0.4258}, {"x": 0.7251, "y": 0.4258}, {"x": 0.7251, "y": 0.4677}, {"x": 0.1068, "y": 0.4677}], "id": 307, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='308' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.4653}, {"x": 0.1184, "y": 0.4653}, {"x": 0.1184, "y": 0.476}, {"x": 0.1087, "y": 0.476}], "id": 308, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='309' data-category='paragraph' style='font-size:14px'>UIntVec indices;<br>UIntMat connectE, connectB1, connectB2;</p>", "markdown": "UIntVec indices;\nUIntMat connectE, connectB1, connectB2;", "text": "UIntVec indices;\nUIntMat connectE, connectB1, connectB2;"}, "coordinates": [{"x": 0.128, "y": 0.4734}, {"x": 0.5282, "y": 0.4734}, {"x": 0.5282, "y": 0.4957}, {"x": 0.128, "y": 0.4957}], "id": 309, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='310' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),<br>DoubleVec3(L, 0., 0.), N, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);</p>", "markdown": "meshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),\nDoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);", "text": "meshtools2d::extrude_translate(pos, DoubleVec3(-L/2, -L/2, +L/2),\nDoubleVec3(L, 0., 0.), N, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., L, 0.), N, 2, connectB2);"}, "coordinates": [{"x": 0.1283, "y": 0.5014}, {"x": 0.8512, "y": 0.5014}, {"x": 0.8512, "y": 0.5449}, {"x": 0.1283, "y": 0.5449}], "id": 310, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='311' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB2);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);<br>connectB2.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB2.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., M_PI, 0.), connectB1);\nconnectB2.push_back(connectB1);"}, "coordinates": [{"x": 0.1317, "y": 0.5499}, {"x": 0.7487, "y": 0.5499}, {"x": 0.7487, "y": 0.5808}, {"x": 0.1317, "y": 0.5808}], "id": 311, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='312' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB2);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);<br>connectB2.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB2.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB2);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(M_PI/2, 0., 0.), connectB1);\nconnectB2.push_back(connectB1);"}, "coordinates": [{"x": 0.1322, "y": 0.5879}, {"x": 0.7648, "y": 0.5879}, {"x": 0.7648, "y": 0.6181}, {"x": 0.1322, "y": 0.6181}], "id": 312, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='313' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB1);<br>meshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);<br>connectB2.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB1);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);\nconnectB2.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB1);\nmeshtools::rotate(pos, DoubleVec3(0.), DoubleVec3(0., 0., M_PI/2), connectB1);\nconnectB2.push_back(connectB1);"}, "coordinates": [{"x": 0.1309, "y": 0.6261}, {"x": 0.765, "y": 0.6261}, {"x": 0.765, "y": 0.6571}, {"x": 0.1309, "y": 0.6571}], "id": 313, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='314' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);<br>connectB.push_back(connectB2);</p>", "markdown": "meshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\nconnectB.push_back(connectB2);", "text": "meshtools::merge(pos, connectB2, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);\nconnectB.push_back(connectB2);"}, "coordinates": [{"x": 0.1261, "y": 0.6632}, {"x": 0.6924, "y": 0.6632}, {"x": 0.6924, "y": 0.6852}, {"x": 0.1261, "y": 0.6852}], "id": 314, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='315' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1075, "y": 0.6836}, {"x": 0.1176, "y": 0.6836}, {"x": 0.1176, "y": 0.6947}, {"x": 0.1075, "y": 0.6947}], "id": 315, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='316' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1091, "y": 0.7119}, {"x": 0.1899, "y": 0.7119}, {"x": 0.1899, "y": 0.7232}, {"x": 0.1091, "y": 0.7232}], "id": 316, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='317' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1087, "y": 0.7219}, {"x": 0.1184, "y": 0.7219}, {"x": 0.1184, "y": 0.7326}, {"x": 0.1087, "y": 0.7326}], "id": 317, "page": 28}, {"category": "table", "content": {"html": "<br><table id='318' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L(4.), h0(0.5), h1(0.1);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB1, connectB2, BGM, connectM2;</td></tr><tr><td>DoubleVec</td><td>sizes;</td></tr><tr><td>unsigned</td><td>N, N_BGM, n;</td></tr><tr><td>double</td><td>w, h;</td></tr><tr><td>tetramesh_iso::mesher</td><td>the_mesher;</td></tr><tr><td>tetramesh_iso::mesher::data_type</td><td>dataTH;</td></tr></tbody></table>", "markdown": "| const double | L(4.), h0(0.5), h1(0.1); |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB1, connectB2, BGM, connectM2; |\n| DoubleVec | sizes; |\n| unsigned | N, N_BGM, n; |\n| double | w, h; |\n| tetramesh_iso::mesher | the_mesher; |\n| tetramesh_iso::mesher::data_type | dataTH; |\n", "text": "| const double | L(4.), h0(0.5), h1(0.1); |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB1, connectB2, BGM, connectM2; |\n| DoubleVec | sizes; |\n| unsigned | N, N_BGM, n; |\n| double | w, h; |\n| tetramesh_iso::mesher | the_mesher; |\n| tetramesh_iso::mesher::data_type | dataTH; |\n"}, "coordinates": [{"x": 0.1246, "y": 0.7294}, {"x": 0.7091, "y": 0.7294}, {"x": 0.7091, "y": 0.8176}, {"x": 0.1246, "y": 0.8176}], "id": 318, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='319' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_iso::registration(\"Licensed to SMART Inc.\", \"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1307, "y": 0.825}, {"x": 0.6994, "y": 0.825}, {"x": 0.6994, "y": 0.8472}, {"x": 0.1307, "y": 0.8472}], "id": 319, "page": 28}, {"category": "paragraph", "content": {"html": "<br><p id='320' data-category='paragraph' style='font-size:14px'>// THE BOUNDARY OF THE BACKGROUND MESH<br>N_BGM = unsigned(std::max(L/h0, L/h1));</p>", "markdown": "// THE BOUNDARY OF THE BACKGROUND MESH\nN_BGM = unsigned(std::max(L/h0, L/h1));", "text": "// THE BOUNDARY OF THE BACKGROUND MESH\nN_BGM = unsigned(std::max(L/h0, L/h1));"}, "coordinates": [{"x": 0.1323, "y": 0.8535}, {"x": 0.4475, "y": 0.8535}, {"x": 0.4475, "y": 0.8759}, {"x": 0.1323, "y": 0.8759}], "id": 320, "page": 28}, {"category": "table", "content": {"html": "<table id='321' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>28</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 28 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 28 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0108, "y": 0.9482}, {"x": 0.9992, "y": 0.9482}, {"x": 0.9992, "y": 1}, {"x": 0.0108, "y": 1}], "id": 321, "page": 28}, {"category": "heading1", "content": {"html": "<h1 id='322' style='font-size:14px'>cube_boundary(L, N_BGM, pos, connectB1);</h1>", "markdown": "# cube_boundary(L, N_BGM, pos, connectB1);", "text": "cube_boundary(L, N_BGM, pos, connectB1);"}, "coordinates": [{"x": 0.1325, "y": 0.0862}, {"x": 0.4562, "y": 0.0862}, {"x": 0.4562, "y": 0.0984}, {"x": 0.1325, "y": 0.0984}], "id": 322, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='323' data-category='paragraph' style='font-size:14px'>// THE 3D BACKGROUND MESH.<br>dataTH.pos = pos;<br>dataTH.connectB = connectB1;<br>the_mesher.run(dataTH);<br>dataTH.extract(pos, BGM);</p>", "markdown": "// THE 3D BACKGROUND MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB1;\nthe_mesher.run(dataTH);\ndataTH.extract(pos, BGM);", "text": "// THE 3D BACKGROUND MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB1;\nthe_mesher.run(dataTH);\ndataTH.extract(pos, BGM);"}, "coordinates": [{"x": 0.1319, "y": 0.1048}, {"x": 0.3588, "y": 0.1048}, {"x": 0.3588, "y": 0.1544}, {"x": 0.1319, "y": 0.1544}], "id": 323, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='324' data-category='paragraph' style='font-size:14px'>// THE METRICS ON THE 3D BACKGROUND MESH.<br>meshtools::unique_indices(indices, BGM);<br>sizes.resize (pos.cols(), 0.);<br>for (size_t i = 0; i < indices.size(); ++i)</p>", "markdown": "// THE METRICS ON THE 3D BACKGROUND MESH.\nmeshtools::unique_indices(indices, BGM);\nsizes.resize (pos.cols(), 0.);\nfor (size_t i = 0; i < indices.size(); ++i)", "text": "// THE METRICS ON THE 3D BACKGROUND MESH.\nmeshtools::unique_indices(indices, BGM);\nsizes.resize (pos.cols(), 0.);\nfor (size_t i = 0; i < indices.size(); ++i)"}, "coordinates": [{"x": 0.1313, "y": 0.1619}, {"x": 0.482, "y": 0.1619}, {"x": 0.482, "y": 0.2036}, {"x": 0.1313, "y": 0.2036}], "id": 324, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='325' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1329, "y": 0.2009}, {"x": 0.1425, "y": 0.2009}, {"x": 0.1425, "y": 0.2116}, {"x": 0.1329, "y": 0.2116}], "id": 325, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='326' data-category='paragraph' style='font-size:14px'>n = indices[i];<br>w = vecscal::max_norm(pos.col(n));<br>h = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;<br>sizes[n] = h;</p>", "markdown": "n = indices[i];\nw = vecscal::max_norm(pos.col(n));\nh = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;\nsizes[n] = h;", "text": "n = indices[i];\nw = vecscal::max_norm(pos.col(n));\nh = ::cos(8.*M_PI* w/L) * (h0-h1)/2. + (h0+h1)/2.;\nsizes[n] = h;"}, "coordinates": [{"x": 0.1531, "y": 0.2107}, {"x": 0.5614, "y": 0.2107}, {"x": 0.5614, "y": 0.2501}, {"x": 0.1531, "y": 0.2501}], "id": 326, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='327' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1325, "y": 0.2474}, {"x": 0.1421, "y": 0.2474}, {"x": 0.1421, "y": 0.2587}, {"x": 0.1325, "y": 0.2587}], "id": 327, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='328' data-category='paragraph' style='font-size:14px'>// THE BOUNDARY OF THE FINAL MESH.<br>cube_boundary(L, N, pos, connectB2);</p>", "markdown": "// THE BOUNDARY OF THE FINAL MESH.\ncube_boundary(L, N, pos, connectB2);", "text": "// THE BOUNDARY OF THE FINAL MESH.\ncube_boundary(L, N, pos, connectB2);"}, "coordinates": [{"x": 0.1313, "y": 0.2657}, {"x": 0.4231, "y": 0.2657}, {"x": 0.4231, "y": 0.288}, {"x": 0.1313, "y": 0.288}], "id": 328, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='329' data-category='paragraph' style='font-size:14px'>// THE 3D MESH.<br>dataTH.pos = pos;<br>dataTH.connectB = connectB2;<br>dataTH.background_mesh = BGM;<br>dataTH.metrics = sizes;<br>the_mesher.run(dataTH);</p>", "markdown": "// THE 3D MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB2;\ndataTH.background_mesh = BGM;\ndataTH.metrics = sizes;\nthe_mesher.run(dataTH);", "text": "// THE 3D MESH.\ndataTH.pos = pos;\ndataTH.connectB = connectB2;\ndataTH.background_mesh = BGM;\ndataTH.metrics = sizes;\nthe_mesher.run(dataTH);"}, "coordinates": [{"x": 0.132, "y": 0.2947}, {"x": 0.3679, "y": 0.2947}, {"x": 0.3679, "y": 0.3545}, {"x": 0.132, "y": 0.3545}], "id": 329, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='330' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.</p>", "markdown": "// MESH VISUALISATION.", "text": "// MESH VISUALISATION."}, "coordinates": [{"x": 0.1344, "y": 0.3611}, {"x": 0.3105, "y": 0.3611}, {"x": 0.3105, "y": 0.3726}, {"x": 0.1344, "y": 0.3726}], "id": 330, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='331' data-category='paragraph' style='font-size:14px'>meshtools::clip(dataTH.pos, dataTH.connectM,<br>DoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);<br>meshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);</p>", "markdown": "meshtools::clip(dataTH.pos, dataTH.connectM,\nDoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);", "text": "meshtools::clip(dataTH.pos, dataTH.connectM,\nDoubleVec3(0., 0., -1E-6), DoubleVec3(0., 0., -1.), connectM2);\nmeshtools::medit_output(\"TH.mesh\", data.pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1301, "y": 0.3668}, {"x": 0.7716, "y": 0.3668}, {"x": 0.7716, "y": 0.4025}, {"x": 0.1301, "y": 0.4025}], "id": 331, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='332' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.1184, "y": 0.4096}, {"x": 0.2085, "y": 0.4096}, {"x": 0.2085, "y": 0.4299}, {"x": 0.1184, "y": 0.4299}], "id": 332, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='333' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.4195}, {"x": 0.1184, "y": 0.4195}, {"x": 0.1184, "y": 0.4301}, {"x": 0.1087, "y": 0.4301}], "id": 333, "page": 29}, {"category": "figure", "content": {"html": "<figure id='334'><img alt=\"\" data-coord=\"top-left:(318,821); bottom-right:(919,1385)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2562, "y": 0.4681}, {"x": 0.7413, "y": 0.4681}, {"x": 0.7413, "y": 0.7897}, {"x": 0.2562, "y": 0.7897}], "id": 334, "page": 29}, {"category": "caption", "content": {"html": "<caption id='335' style='font-size:14px'>Figure 16 – Use of a background mesh to support a metric map on the domain (mesh cut).</caption>", "markdown": "Figure 16 – Use of a background mesh to support a metric map on the domain (mesh cut).", "text": "Figure 16 – Use of a background mesh to support a metric map on the domain (mesh cut)."}, "coordinates": [{"x": 0.2233, "y": 0.8007}, {"x": 0.7744, "y": 0.8007}, {"x": 0.7744, "y": 0.8151}, {"x": 0.2233, "y": 0.8151}], "id": 335, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='336' data-category='paragraph' style='font-size:20px'>The background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be<br>partially outside of the domain. In the zones not covered by the background mesh, the default interpolation of<br>the sizes from the hard nodes is used instead.</p>", "markdown": "The background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be\npartially outside of the domain. In the zones not covered by the background mesh, the default interpolation of\nthe sizes from the hard nodes is used instead.", "text": "The background mesh does not need to fit exactly the domain to be meshed. It can cover only a part of it or be\npartially outside of the domain. In the zones not covered by the background mesh, the default interpolation of\nthe sizes from the hard nodes is used instead."}, "coordinates": [{"x": 0.0761, "y": 0.8495}, {"x": 0.9192, "y": 0.8495}, {"x": 0.9192, "y": 0.8957}, {"x": 0.0761, "y": 0.8957}], "id": 336, "page": 29}, {"category": "table", "content": {"html": "<table id='337' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>29</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 29 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 29 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0109, "y": 0.9477}, {"x": 0.9994, "y": 0.9477}, {"x": 0.9994, "y": 1}, {"x": 0.0109, "y": 1}], "id": 337, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='338' data-category='paragraph' style='font-size:20px'>Here is an example where the domain and the background mesh are both spheres but the latter is half the<br>radius of the former. We have set a uniform value for the metric map on the background mesh to get a finer<br>mesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still<br>conformal.</p>", "markdown": "Here is an example where the domain and the background mesh are both spheres but the latter is half the\nradius of the former. We have set a uniform value for the metric map on the background mesh to get a finer\nmesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still\nconformal.", "text": "Here is an example where the domain and the background mesh are both spheres but the latter is half the\nradius of the former. We have set a uniform value for the metric map on the background mesh to get a finer\nmesh in this part. Hence, the metric drops abruptly at the limit of the background mesh, but the mesh is still\nconformal."}, "coordinates": [{"x": 0.0766, "y": 0.064}, {"x": 0.8961, "y": 0.064}, {"x": 0.8961, "y": 0.1231}, {"x": 0.0766, "y": 0.1231}], "id": 338, "page": 30}, {"category": "figure", "content": {"html": "<figure id='339'><img alt=\"\" data-coord=\"top-left:(320,246); bottom-right:(924,703)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2579, "y": 0.1404}, {"x": 0.745, "y": 0.1404}, {"x": 0.745, "y": 0.4013}, {"x": 0.2579, "y": 0.4013}], "id": 339, "page": 30}, {"category": "caption", "content": {"html": "<caption id='340' style='font-size:16px'>Figure 17 – Background mesh covering only a fraction of the domain (mesh cut).</caption>", "markdown": "Figure 17 – Background mesh covering only a fraction of the domain (mesh cut).", "text": "Figure 17 – Background mesh covering only a fraction of the domain (mesh cut)."}, "coordinates": [{"x": 0.2534, "y": 0.4099}, {"x": 0.7422, "y": 0.4099}, {"x": 0.7422, "y": 0.4247}, {"x": 0.2534, "y": 0.4247}], "id": 340, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='341' data-category='paragraph' style='font-size:20px'>The background mesh is a very useful feature to control precisely the size of the elements all over the domain.<br>It can however be time consuming. The finer the background mesh, the longer the meshing process. The<br>background mesh should be coarse wherever the metric is slowly varying and fine only in the regions where<br>the metric is sharply varying and should be approximated with accuracy.</p>", "markdown": "The background mesh is a very useful feature to control precisely the size of the elements all over the domain.\nIt can however be time consuming. The finer the background mesh, the longer the meshing process. The\nbackground mesh should be coarse wherever the metric is slowly varying and fine only in the regions where\nthe metric is sharply varying and should be approximated with accuracy.", "text": "The background mesh is a very useful feature to control precisely the size of the elements all over the domain.\nIt can however be time consuming. The finer the background mesh, the longer the meshing process. The\nbackground mesh should be coarse wherever the metric is slowly varying and fine only in the regions where\nthe metric is sharply varying and should be approximated with accuracy."}, "coordinates": [{"x": 0.0762, "y": 0.4593}, {"x": 0.9126, "y": 0.4593}, {"x": 0.9126, "y": 0.5185}, {"x": 0.0762, "y": 0.5185}], "id": 341, "page": 30}, {"category": "paragraph", "content": {"html": "<br><p id='342' data-category='paragraph' style='font-size:20px'>We can also consider the case where the boundary surface mesh of the domain must also be governed by<br>background mesh. Two steps with two different background meshes are required24. First, the surface mesh is<br>generated with the help of a surface background mesh. An anisotropic mesher supporting the background<br>mesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -<br>CM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to<br>generate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final<br>adapted 3-D mesh.</p>", "markdown": "We can also consider the case where the boundary surface mesh of the domain must also be governed by\nbackground mesh. Two steps with two different background meshes are required24. First, the surface mesh is\ngenerated with the help of a surface background mesh. An anisotropic mesher supporting the background\nmesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -\nCM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to\ngenerate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final\nadapted 3-D mesh.", "text": "We can also consider the case where the boundary surface mesh of the domain must also be governed by\nbackground mesh. Two steps with two different background meshes are required24. First, the surface mesh is\ngenerated with the help of a surface background mesh. An anisotropic mesher supporting the background\nmesh option such as CM2 TriaMesh® Aniso can be used for this purpose (refer to the manual CM2 TriaMesh -\nCM2 QuadMesh Iso/Aniso - tutorials). After the surface mesh, we can proceed as the previous example to\ngenerate a 3-D background mesh supporting the metric map and run the tetrahedral mesher to get the final\nadapted 3-D mesh."}, "coordinates": [{"x": 0.077, "y": 0.5291}, {"x": 0.9052, "y": 0.5291}, {"x": 0.9052, "y": 0.6291}, {"x": 0.077, "y": 0.6291}], "id": 342, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='343' data-category='paragraph' style='font-size:20px'>☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a<br>changed metrics map (saving a new meshing from scratch).</p>", "markdown": "☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a\nchanged metrics map (saving a new meshing from scratch).", "text": "☞ A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it to a\nchanged metrics map (saving a new meshing from scratch)."}, "coordinates": [{"x": 0.0477, "y": 0.6462}, {"x": 0.9005, "y": 0.6462}, {"x": 0.9005, "y": 0.6772}, {"x": 0.0477, "y": 0.6772}], "id": 343, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='344' data-category='paragraph' style='font-size:14px'>24 A third kind of background mesh can be needed to generate the line meshes.</p>", "markdown": "24 A third kind of background mesh can be needed to generate the line meshes.", "text": "24 A third kind of background mesh can be needed to generate the line meshes."}, "coordinates": [{"x": 0.0629, "y": 0.899}, {"x": 0.5469, "y": 0.899}, {"x": 0.5469, "y": 0.9128}, {"x": 0.0629, "y": 0.9128}], "id": 344, "page": 30}, {"category": "table", "content": {"html": "<table id='345' style='font-size:18px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>30</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 30 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 30 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0102, "y": 0.9479}, {"x": 0.9981, "y": 0.9479}, {"x": 0.9981, "y": 1}, {"x": 0.0102, "y": 1}], "id": 345, "page": 30}, {"category": "heading1", "content": {"html": "<h1 id='346' style='font-size:22px'>10. Anisotropic meshes (CM2 TetraMesh Aniso)</h1>", "markdown": "# 10. Anisotropic meshes (CM2 TetraMesh Aniso)", "text": "10. Anisotropic meshes (CM2 TetraMesh Aniso)"}, "coordinates": [{"x": 0.0764, "y": 0.0634}, {"x": 0.7179, "y": 0.0634}, {"x": 0.7179, "y": 0.0884}, {"x": 0.0764, "y": 0.0884}], "id": 346, "page": 31}, {"category": "paragraph", "content": {"html": "<br><p id='347' data-category='paragraph' style='font-size:18px'>CM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.<br>It’s sometimes useful however to have elements stretched in some special directions. To deal with complex<br>domains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator<br>CM2 TetraMesh Aniso.<br>CM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This<br>array is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define<br>the size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in<br>the metrics array.</p>", "markdown": "CM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.\nIt’s sometimes useful however to have elements stretched in some special directions. To deal with complex\ndomains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator\nCM2 TetraMesh Aniso.\nCM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This\narray is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define\nthe size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in\nthe metrics array.", "text": "CM2 TetraMesh Iso is an isotropic unstructured mesh generator: it tends to produce equilateral tetrahedrons.\nIt’s sometimes useful however to have elements stretched in some special directions. To deal with complex\ndomains, we still need an unstructured mesher. Here comes the anisotropic unstructured mesh generator\nCM2 TetraMesh Aniso.\nCM2 TetraMesh Aniso is almost identical to the isotropic version except for the data.metrics array. This\narray is now a matrix (instead of a vector). In the isotropic case, we need only a scalar at each node to define\nthe size. Now, the size is defined by a 3 x 3 symmetric matrix at each node (6 doubles), stored column-wise in\nthe metrics array."}, "coordinates": [{"x": 0.0774, "y": 0.0992}, {"x": 0.9051, "y": 0.0992}, {"x": 0.9051, "y": 0.2149}, {"x": 0.0774, "y": 0.2149}], "id": 347, "page": 31}, {"category": "figure", "content": {"html": "<figure id='348'><img style='font-size:18px' alt=\"h\nP\" data-coord=\"top-left:(227,448); bottom-right:(408,623)\" /></figure>", "markdown": "![image](/image/placeholder)\nh\nP", "text": "![image](/image/placeholder)\nh\nP"}, "coordinates": [{"x": 0.1836, "y": 0.2555}, {"x": 0.3293, "y": 0.2555}, {"x": 0.3293, "y": 0.3555}, {"x": 0.1836, "y": 0.3555}], "id": 348, "page": 31}, {"category": "figure", "content": {"html": "<figure id='349'><img alt=\"\" data-coord=\"top-left:(263,713); bottom-right:(371,819)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2123, "y": 0.407}, {"x": 0.2993, "y": 0.407}, {"x": 0.2993, "y": 0.4674}, {"x": 0.2123, "y": 0.4674}], "id": 349, "page": 31}, {"category": "paragraph", "content": {"html": "<p id='350' data-category='paragraph' style='font-size:14px'>Isotropic tet<br>(size 1 in the isotropic metric h)</p>", "markdown": "Isotropic tet\n(size 1 in the isotropic metric h)", "text": "Isotropic tet\n(size 1 in the isotropic metric h)"}, "coordinates": [{"x": 0.1825, "y": 0.4974}, {"x": 0.3764, "y": 0.4974}, {"x": 0.3764, "y": 0.5221}, {"x": 0.1825, "y": 0.5221}], "id": 350, "page": 31}, {"category": "figure", "content": {"html": "<br><figure id='351'><img style='font-size:18px' alt=\"h2\nh0\nP\nh1\" data-coord=\"top-left:(657,435); bottom-right:(947,829)\" /></figure>", "markdown": "![image](/image/placeholder)\nh2\nh0\nP\nh1", "text": "![image](/image/placeholder)\nh2\nh0\nP\nh1"}, "coordinates": [{"x": 0.5298, "y": 0.248}, {"x": 0.7637, "y": 0.248}, {"x": 0.7637, "y": 0.4728}, {"x": 0.5298, "y": 0.4728}], "id": 351, "page": 31}, {"category": "paragraph", "content": {"html": "<p id='352' data-category='paragraph' style='font-size:14px'>Anisotropic tet<br>(size 1 in the anisotropic metric M)</p>", "markdown": "Anisotropic tet\n(size 1 in the anisotropic metric M)", "text": "Anisotropic tet\n(size 1 in the anisotropic metric M)"}, "coordinates": [{"x": 0.5522, "y": 0.4971}, {"x": 0.7678, "y": 0.4971}, {"x": 0.7678, "y": 0.5225}, {"x": 0.5522, "y": 0.5225}], "id": 352, "page": 31}, {"category": "paragraph", "content": {"html": "<p id='353' data-category='paragraph' style='font-size:14px'>Figure 18 – A single scalar defines an isotropic metric (left).<br>A 3-D anisotropic metric needs three vectors (right).</p>", "markdown": "Figure 18 – A single scalar defines an isotropic metric (left).\nA 3-D anisotropic metric needs three vectors (right).", "text": "Figure 18 – A single scalar defines an isotropic metric (left).\nA 3-D anisotropic metric needs three vectors (right)."}, "coordinates": [{"x": 0.3224, "y": 0.5403}, {"x": 0.6768, "y": 0.5403}, {"x": 0.6768, "y": 0.5657}, {"x": 0.3224, "y": 0.5657}], "id": 353, "page": 31}, {"category": "paragraph", "content": {"html": "<p id='354' data-category='paragraph' style='font-size:18px'>3-D anisotropic metrics are defined as below:</p>", "markdown": "3-D anisotropic metrics are defined as below:", "text": "3-D anisotropic metrics are defined as below:"}, "coordinates": [{"x": 0.0759, "y": 0.5879}, {"x": 0.4237, "y": 0.5879}, {"x": 0.4237, "y": 0.6039}, {"x": 0.0759, "y": 0.6039}], "id": 354, "page": 31}, {"category": "chart", "content": {"html": "<br><figure id='355' data-category='chart'><img data-coord=\"top-left:(136,1071); bottom-right:(906,1533)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>a</td><td>b</td><td>c</td><td>d</td></tr></thead><tbody><tr><td>item_01</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: line\n|  | a | b | c | d |\n| --- | --- | --- | --- | --- |\n| item_01 | 0 | 0 | 0 | 0 |\n", "text": "![image](/image/placeholder)\n- Chart Type: line\n|  | a | b | c | d |\n| --- | --- | --- | --- | --- |\n| item_01 | 0 | 0 | 0 | 0 |\n"}, "coordinates": [{"x": 0.1098, "y": 0.6109}, {"x": 0.7301, "y": 0.6109}, {"x": 0.7301, "y": 0.8742}, {"x": 0.1098, "y": 0.8742}], "id": 355, "page": 31}, {"category": "caption", "content": {"html": "<br><caption id='356' style='font-size:14px'>Figure 19 – Definition and storage of the 3-D anisotropic metrics.</caption>", "markdown": "Figure 19 – Definition and storage of the 3-D anisotropic metrics.", "text": "Figure 19 – Definition and storage of the 3-D anisotropic metrics."}, "coordinates": [{"x": 0.3089, "y": 0.8664}, {"x": 0.7068, "y": 0.8664}, {"x": 0.7068, "y": 0.8816}, {"x": 0.3089, "y": 0.8816}], "id": 356, "page": 31}, {"category": "table", "content": {"html": "<table id='357' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>31</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 31 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 31 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0052, "y": 0.9484}, {"x": 0.9981, "y": 0.9484}, {"x": 0.9981, "y": 1}, {"x": 0.0052, "y": 1}], "id": 357, "page": 31}, {"category": "paragraph", "content": {"html": "<p id='358' data-category='paragraph' style='font-size:18px'>Let (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:</p>", "markdown": "Let (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:", "text": "Let (v0, v1, v2) be the three orthonormal vectors along the axes of the ellipsoid:"}, "coordinates": [{"x": 0.0752, "y": 0.0639}, {"x": 0.6774, "y": 0.0639}, {"x": 0.6774, "y": 0.0816}, {"x": 0.0752, "y": 0.0816}], "id": 358, "page": 32}, {"category": "equation", "content": {"html": "<p id='359' data-category='equation'>$$\\begin{array}{l}{{\\mathbf{v}_{0}\\lVert=\\lVert\\mathbf{v}_{1}\\rVert=\\lVert\\mathbf{v}_{2}\\rVert=1}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{2}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0}\\times\\mathbf{v}_{1},\\mathbf{v}_{2}\\rfloor=1}}\\end{array}$$</p>", "markdown": "$$\\begin{array}{l}{{\\mathbf{v}_{0}\\lVert=\\lVert\\mathbf{v}_{1}\\rVert=\\lVert\\mathbf{v}_{2}\\rVert=1}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{2}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0},\\mathbf{v}_{1}\\rbrack=0}}\\\\ {{\\mathbf{v}_{0}\\times\\mathbf{v}_{1},\\mathbf{v}_{2}\\rfloor=1}}\\end{array}$$", "text": "v 0 � v1 � v 2 � 1\n v 0 , v1 0\n v 0 , v 2 ��� 0\n v1 , v 2 0\n v 0 � v1 , v 2 � 1"}, "coordinates": [{"x": 0.1187, "y": 0.0941}, {"x": 0.2944, "y": 0.0941}, {"x": 0.2944, "y": 0.2126}, {"x": 0.1187, "y": 0.2126}], "id": 359, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='360' data-category='paragraph' style='font-size:20px'>Then, the metric Mj writes:</p>", "markdown": "Then, the metric Mj writes:", "text": "Then, the metric Mj writes:"}, "coordinates": [{"x": 0.0766, "y": 0.2335}, {"x": 0.2831, "y": 0.2335}, {"x": 0.2831, "y": 0.2502}, {"x": 0.0766, "y": 0.2502}], "id": 360, "page": 32}, {"category": "equation", "content": {"html": "<br><p id='361' data-category='equation'>$$\\begin{array}{c c c}{{}}&{{}}&{{\\left[\\frac{1}{h_{0}^{~2}}~}&{{}}&{{}}&{{0}}\\\\ {{}}&{{}}&{{}}\\\\ {{0~~~~~{\\frac{1}{h_{1}^{~2}}}}}&{{}}\\\\ {{}}&{{}}&{{}}&{{}}\\\\ {{}}&{{}}&{{}}&{{\\displaystyle{\\frac{1}{h_{2}^{~2}}}\\right]}}\\end{array}$$</p>", "markdown": "$$\\begin{array}{c c c}{{}}&{{}}&{{\\left[\\frac{1}{h_{0}^{~2}}~}&{{}}&{{}}&{{0}}\\\\ {{}}&{{}}&{{}}\\\\ {{0~~~~~{\\frac{1}{h_{1}^{~2}}}}}&{{}}\\\\ {{}}&{{}}&{{}}&{{}}\\\\ {{}}&{{}}&{{}}&{{\\displaystyle{\\frac{1}{h_{2}^{~2}}}\\right]}}\\end{array}$$", "text": "� 1 �\n 0 0 �������\n 2\n h 0\n 1\n M j� ��B ������� 0 0\n 2\n h 1\n 1\n 0 0\n 2\n � h 2 �"}, "coordinates": [{"x": 0.1125, "y": 0.2573}, {"x": 0.3641, "y": 0.2573}, {"x": 0.3641, "y": 0.3856}, {"x": 0.1125, "y": 0.3856}], "id": 361, "page": 32}, {"category": "paragraph", "content": {"html": "<br><p id='362' data-category='paragraph' style='font-size:16px'>T B</p>", "markdown": "T B", "text": "T B"}, "coordinates": [{"x": 0.3649, "y": 0.3114}, {"x": 0.3903, "y": 0.3114}, {"x": 0.3903, "y": 0.3273}, {"x": 0.3649, "y": 0.3273}], "id": 362, "page": 32}, {"category": "heading1", "content": {"html": "<br><h1 id='363' style='font-size:20px'>B � �v 0 v1 v 2 �</h1>", "markdown": "# B � �v 0 v1 v 2 �", "text": "B � �v 0 v1 v 2 �"}, "coordinates": [{"x": 0.5209, "y": 0.3013}, {"x": 0.6769, "y": 0.3013}, {"x": 0.6769, "y": 0.3261}, {"x": 0.5209, "y": 0.3261}], "id": 363, "page": 32}, {"category": "paragraph", "content": {"html": "<br><p id='364' data-category='paragraph' style='font-size:18px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.449, "y": 0.3181}, {"x": 0.4876, "y": 0.3181}, {"x": 0.4876, "y": 0.3314}, {"x": 0.449, "y": 0.3314}], "id": 364, "page": 32}, {"category": "heading1", "content": {"html": "<br><h1 id='365' style='font-size:20px'>stored column � wise</h1>", "markdown": "# stored column � wise", "text": "stored column � wise"}, "coordinates": [{"x": 0.5224, "y": 0.3278}, {"x": 0.7021, "y": 0.3278}, {"x": 0.7021, "y": 0.3449}, {"x": 0.5224, "y": 0.3449}], "id": 365, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='366' data-category='paragraph' style='font-size:18px'>The h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are<br>the inverse of the square root of the eigen values of metric Mj.</p>", "markdown": "The h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are\nthe inverse of the square root of the eigen values of metric Mj.", "text": "The h0 , h1 and h2 values are the target sizes of the tets in the three principal directions near point Pj. They are\nthe inverse of the square root of the eigen values of metric Mj."}, "coordinates": [{"x": 0.0738, "y": 0.4043}, {"x": 0.9013, "y": 0.4043}, {"x": 0.9013, "y": 0.4361}, {"x": 0.0738, "y": 0.4361}], "id": 366, "page": 32}, {"category": "paragraph", "content": {"html": "<br><p id='367' data-category='paragraph' style='font-size:18px'>The 3-D metric equivalent of an isotropic size of h writes:</p>", "markdown": "The 3-D metric equivalent of an isotropic size of h writes:", "text": "The 3-D metric equivalent of an isotropic size of h writes:"}, "coordinates": [{"x": 0.0751, "y": 0.4444}, {"x": 0.5081, "y": 0.4444}, {"x": 0.5081, "y": 0.4624}, {"x": 0.0751, "y": 0.4624}], "id": 367, "page": 32}, {"category": "equation", "content": {"html": "<p id='368' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$</p>", "markdown": "$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$", "text": "� 1 �\n 0 0\n h 2 ������\n 1\n M j � ������ 0 0\n h 2\n 1\n 0 0\n �\n � h 2"}, "coordinates": [{"x": 0.1189, "y": 0.4717}, {"x": 0.3165, "y": 0.4717}, {"x": 0.3165, "y": 0.5838}, {"x": 0.1189, "y": 0.5838}], "id": 368, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='369' data-category='paragraph' style='font-size:18px'>A null matrix would lead to infinite sizes in the three directions (infinite sphere).</p>", "markdown": "A null matrix would lead to infinite sizes in the three directions (infinite sphere).", "text": "A null matrix would lead to infinite sizes in the three directions (infinite sphere)."}, "coordinates": [{"x": 0.0747, "y": 0.6042}, {"x": 0.6753, "y": 0.6042}, {"x": 0.6753, "y": 0.6209}, {"x": 0.0747, "y": 0.6209}], "id": 369, "page": 32}, {"category": "paragraph", "content": {"html": "<br><p id='370' data-category='paragraph' style='font-size:18px'>When the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic<br>case we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.<br>This leads to the same default behavior as their related isotropic counterparts. Take the previous examples and<br>replace:</p>", "markdown": "When the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic\ncase we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.\nThis leads to the same default behavior as their related isotropic counterparts. Take the previous examples and\nreplace:", "text": "When the user doesn’t specify any metric, the mesher uses the default one which is equivalent to the isotropic\ncase we have seen before. For each hard node, the default metric is based on the length of the adjacent edges.\nThis leads to the same default behavior as their related isotropic counterparts. Take the previous examples and\nreplace:"}, "coordinates": [{"x": 0.076, "y": 0.6303}, {"x": 0.9219, "y": 0.6303}, {"x": 0.9219, "y": 0.6889}, {"x": 0.076, "y": 0.6889}], "id": 370, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='371' data-category='paragraph' style='font-size:14px'>tetramesh_iso::mesher the_mesher;</p>", "markdown": "tetramesh_iso::mesher the_mesher;", "text": "tetramesh_iso::mesher the_mesher;"}, "coordinates": [{"x": 0.1067, "y": 0.721}, {"x": 0.4086, "y": 0.721}, {"x": 0.4086, "y": 0.7351}, {"x": 0.1067, "y": 0.7351}], "id": 371, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='372' data-category='paragraph' style='font-size:18px'>with</p>", "markdown": "with", "text": "with"}, "coordinates": [{"x": 0.077, "y": 0.7721}, {"x": 0.1149, "y": 0.7721}, {"x": 0.1149, "y": 0.7859}, {"x": 0.077, "y": 0.7859}], "id": 372, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='373' data-category='paragraph' style='font-size:14px'>tetramesh_aniso::mesher the_mesher;</p>", "markdown": "tetramesh_aniso::mesher the_mesher;", "text": "tetramesh_aniso::mesher the_mesher;"}, "coordinates": [{"x": 0.1059, "y": 0.8254}, {"x": 0.4095, "y": 0.8254}, {"x": 0.4095, "y": 0.8381}, {"x": 0.1059, "y": 0.8381}], "id": 373, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='374' data-category='paragraph' style='font-size:18px'>and you get the same output meshes25.</p>", "markdown": "and you get the same output meshes25.", "text": "and you get the same output meshes25."}, "coordinates": [{"x": 0.0732, "y": 0.8815}, {"x": 0.3778, "y": 0.8815}, {"x": 0.3778, "y": 0.8961}, {"x": 0.0732, "y": 0.8961}], "id": 374, "page": 32}, {"category": "paragraph", "content": {"html": "<br><p id='375' data-category='paragraph' style='font-size:14px'>25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower).</p>", "markdown": "25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower).", "text": "25 The anisotropic mesher is much slower than its isotropic counterpart though (about 6 times slower)."}, "coordinates": [{"x": 0.0629, "y": 0.8994}, {"x": 0.6836, "y": 0.8994}, {"x": 0.6836, "y": 0.9127}, {"x": 0.0629, "y": 0.9127}], "id": 375, "page": 32}, {"category": "table", "content": {"html": "<table id='376' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>32</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 32 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 32 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.016, "y": 0.9481}, {"x": 0.9981, "y": 0.9481}, {"x": 0.9981, "y": 1}, {"x": 0.016, "y": 1}], "id": 376, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='377' data-category='paragraph' style='font-size:16px'>The following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements<br>along each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic<br>metric. Here, the metric is uniform on all the beam and equals simply:</p>", "markdown": "The following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements\nalong each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic\nmetric. Here, the metric is uniform on all the beam and equals simply:", "text": "The following example shows a long \"beam\" as a parallelepiped of size 10x10x100 discretized with 10 elements\nalong each direction. To get stretched tets in the direction of the beam, we need also to specify an anisotropic\nmetric. Here, the metric is uniform on all the beam and equals simply:"}, "coordinates": [{"x": 0.0757, "y": 0.0636}, {"x": 0.9196, "y": 0.0636}, {"x": 0.9196, "y": 0.1099}, {"x": 0.0757, "y": 0.1099}], "id": 377, "page": 33}, {"category": "equation", "content": {"html": "<p id='378' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{{\\displaystyle{\\left[\\frac{1}{h_{0}^{2}}}}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\displaystyle{{\\frac{1}{h_{0}^{2}}}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\displaystyle{{\\bar{h}_{1}^{2}}}}}\\end{array}\\right]$$</p>", "markdown": "$$M_{j}=\\left[\\begin{array}{c c c}{{{\\displaystyle{\\left[\\frac{1}{h_{0}^{2}}}}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\displaystyle{{\\frac{1}{h_{0}^{2}}}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\displaystyle{{\\bar{h}_{1}^{2}}}}}\\end{array}\\right]$$", "text": "1 ��������\n 0 0\n 2\n h 0\n 1\n M j � �������� 0 0\n 2\n h 0\n 1\n 0 0\n 2h1 �\n �"}, "coordinates": [{"x": 0.1156, "y": 0.1192}, {"x": 0.3227, "y": 0.1192}, {"x": 0.3227, "y": 0.2401}, {"x": 0.1156, "y": 0.2401}], "id": 378, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='379' data-category='paragraph' style='font-size:16px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.4006, "y": 0.1716}, {"x": 0.4416, "y": 0.1716}, {"x": 0.4416, "y": 0.1864}, {"x": 0.4006, "y": 0.1864}], "id": 379, "page": 33}, {"category": "heading1", "content": {"html": "<br><h1 id='380' style='font-size:18px'>h0� �</h1>", "markdown": "# h0� �", "text": "h0� �"}, "coordinates": [{"x": 0.4739, "y": 0.1466}, {"x": 0.5139, "y": 0.1466}, {"x": 0.5139, "y": 0.1662}, {"x": 0.4739, "y": 0.1662}], "id": 380, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='381' data-category='paragraph' style='font-size:20px'>L0</p>", "markdown": "L0", "text": "L0"}, "coordinates": [{"x": 0.5199, "y": 0.1377}, {"x": 0.5409, "y": 0.1377}, {"x": 0.5409, "y": 0.1565}, {"x": 0.5199, "y": 0.1565}], "id": 381, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='382' data-category='paragraph' style='font-size:14px'>N 0</p>", "markdown": "N 0", "text": "N 0"}, "coordinates": [{"x": 0.5176, "y": 0.1577}, {"x": 0.5435, "y": 0.1577}, {"x": 0.5435, "y": 0.1771}, {"x": 0.5176, "y": 0.1771}], "id": 382, "page": 33}, {"category": "heading1", "content": {"html": "<br><h1 id='383' style='font-size:18px'>h1� �</h1>", "markdown": "# h1� �", "text": "h1� �"}, "coordinates": [{"x": 0.4739, "y": 0.1881}, {"x": 0.5118, "y": 0.1881}, {"x": 0.5118, "y": 0.2078}, {"x": 0.4739, "y": 0.2078}], "id": 383, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='384' data-category='paragraph' style='font-size:20px'>L1</p>", "markdown": "L1", "text": "L1"}, "coordinates": [{"x": 0.518, "y": 0.1795}, {"x": 0.5376, "y": 0.1795}, {"x": 0.5376, "y": 0.198}, {"x": 0.518, "y": 0.198}], "id": 384, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='385' data-category='paragraph' style='font-size:14px'>N 1</p>", "markdown": "N 1", "text": "N 1"}, "coordinates": [{"x": 0.5157, "y": 0.1993}, {"x": 0.5402, "y": 0.1993}, {"x": 0.5402, "y": 0.2185}, {"x": 0.5157, "y": 0.2185}], "id": 385, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='386' data-category='paragraph' style='font-size:16px'>Here, the directions of anisotropy are identical to the global axes X, Y, Z.</p>", "markdown": "Here, the directions of anisotropy are identical to the global axes X, Y, Z.", "text": "Here, the directions of anisotropy are identical to the global axes X, Y, Z."}, "coordinates": [{"x": 0.077, "y": 0.2608}, {"x": 0.6226, "y": 0.2608}, {"x": 0.6226, "y": 0.2783}, {"x": 0.077, "y": 0.2783}], "id": 386, "page": 33}, {"category": "table", "content": {"html": "<table id='387' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>33</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 33 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 33 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0032, "y": 0.9481}, {"x": 0.9996, "y": 0.9481}, {"x": 0.9996, "y": 1}, {"x": 0.0032, "y": 1}], "id": 387, "page": 33}, {"category": "heading1", "content": {"html": "<h1 id='388' style='font-size:14px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1052, "y": 0.0857}, {"x": 0.2645, "y": 0.0857}, {"x": 0.2645, "y": 0.0969}, {"x": 0.1052, "y": 0.0969}], "id": 388, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='389' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1102, "y": 0.1068}, {"x": 0.1901, "y": 0.1068}, {"x": 0.1901, "y": 0.1179}, {"x": 0.1102, "y": 0.1179}], "id": 389, "page": 34}, {"category": "heading1", "content": {"html": "<br><h1 id='390' style='font-size:20px'>{{</h1>", "markdown": "# {{", "text": "{{"}, "coordinates": [{"x": 0.1087, "y": 0.1179}, {"x": 0.1184, "y": 0.1179}, {"x": 0.1184, "y": 0.1389}, {"x": 0.1087, "y": 0.1389}], "id": 390, "page": 34}, {"category": "table", "content": {"html": "<br><table id='391' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L0(10.), L1(100.);</td></tr><tr><td>const unsigned</td><td>N0(10), N1(10);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectE, connectB1, connectB2, connectB;</td></tr><tr><td>UIntMat</td><td>connectM, connectM2;</td></tr><tr><td>DoubleMat</td><td>metrics;</td></tr><tr><td>double</td><td>D0, D1;</td></tr></tbody></table>", "markdown": "| const double | L0(10.), L1(100.); |\n| --- | --- |\n| const unsigned | N0(10), N1(10); |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE, connectB1, connectB2, connectB; |\n| UIntMat | connectM, connectM2; |\n| DoubleMat | metrics; |\n| double | D0, D1; |\n", "text": "| const double | L0(10.), L1(100.); |\n| --- | --- |\n| const unsigned | N0(10), N1(10); |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE, connectB1, connectB2, connectB; |\n| UIntMat | connectM, connectM2; |\n| DoubleMat | metrics; |\n| double | D0, D1; |\n"}, "coordinates": [{"x": 0.1297, "y": 0.1377}, {"x": 0.6852, "y": 0.1377}, {"x": 0.6852, "y": 0.2214}, {"x": 0.1297, "y": 0.2214}], "id": 391, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='392' data-category='paragraph' style='font-size:14px'>// UNLOCK THE DLL.<br>tetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");</p>", "markdown": "// UNLOCK THE DLL.\ntetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");", "text": "// UNLOCK THE DLL.\ntetramesh_aniso::registration(\"Licensed to SMART Inc.\",\"F53EA108BCWX\");"}, "coordinates": [{"x": 0.1306, "y": 0.2294}, {"x": 0.7062, "y": 0.2294}, {"x": 0.7062, "y": 0.2533}, {"x": 0.1306, "y": 0.2533}], "id": 392, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='393' data-category='paragraph' style='font-size:14px'>// BOUNDARY 2D MESH.</p>", "markdown": "// BOUNDARY 2D MESH.", "text": "// BOUNDARY 2D MESH."}, "coordinates": [{"x": 0.1333, "y": 0.2603}, {"x": 0.2944, "y": 0.2603}, {"x": 0.2944, "y": 0.2729}, {"x": 0.1333, "y": 0.2729}], "id": 393, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='394' data-category='paragraph' style='font-size:14px'>meshtools2d::extrude_translate(pos, DoubleVec3(0.),<br>DoubleVec3(0., L0, 0.), N0, indices);<br>meshtools2d::indices_to_connectE2(indices, connectE);<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),<br>N0, 2, connectB);</p>", "markdown": "meshtools2d::extrude_translate(pos, DoubleVec3(0.),\nDoubleVec3(0., L0, 0.), N0, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),\nN0, 2, connectB);", "text": "meshtools2d::extrude_translate(pos, DoubleVec3(0.),\nDoubleVec3(0., L0, 0.), N0, indices);\nmeshtools2d::indices_to_connectE2(indices, connectE);\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(L0, 0., 0.),\nN0, 2, connectB);"}, "coordinates": [{"x": 0.1311, "y": 0.2714}, {"x": 0.7114, "y": 0.2714}, {"x": 0.7114, "y": 0.325}, {"x": 0.1311, "y": 0.325}], "id": 394, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='395' data-category='paragraph' style='font-size:14px'>meshtools::copy_mesh(pos, connectB1, connectB);<br>meshtools2d::flip_T3(connectB1);<br>meshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);<br>connectB.push_back(connectB1);</p>", "markdown": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools2d::flip_T3(connectB1);\nmeshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);\nconnectB.push_back(connectB1);", "text": "meshtools::copy_mesh(pos, connectB1, connectB);\nmeshtools2d::flip_T3(connectB1);\nmeshtools::translate(pos, DoubleVec3(0., 0., L1), connectB1);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.1318, "y": 0.3342}, {"x": 0.6245, "y": 0.3342}, {"x": 0.6245, "y": 0.3767}, {"x": 0.1318, "y": 0.3767}], "id": 395, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='396' data-category='paragraph' style='font-size:14px'>connectB1.clear();<br>meshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),</p>", "markdown": "connectB1.clear();\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),", "text": "connectB1.clear();\nmeshtools2d::extrude_translate_T3(pos, connectE, DoubleVec3(0., 0., L1),"}, "coordinates": [{"x": 0.1315, "y": 0.3849}, {"x": 0.7124, "y": 0.3849}, {"x": 0.7124, "y": 0.4103}, {"x": 0.1315, "y": 0.4103}], "id": 396, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='397' data-category='paragraph' style='font-size:14px'>N1, 2, connectB1);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),<br>DoubleVec3(0,0,M_PI/2), connectB2);<br>connectB1.push_back(connectB2);<br>meshtools::copy_mesh(pos, connectB2, connectB1);<br>meshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),<br>DoubleVec3(0., 0., M_PI), connectB2);<br>connectB1.push_back(connectB2);<br>connectB.push_back(connectB1);</p>", "markdown": "N1, 2, connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0,0,M_PI/2), connectB2);\nconnectB1.push_back(connectB2);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0., 0., M_PI), connectB2);\nconnectB1.push_back(connectB2);\nconnectB.push_back(connectB1);", "text": "N1, 2, connectB1);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0,0,M_PI/2), connectB2);\nconnectB1.push_back(connectB2);\nmeshtools::copy_mesh(pos, connectB2, connectB1);\nmeshtools::rotate(pos, DoubleVec3(L0/2, L0/2, L1/2),\nDoubleVec3(0., 0., M_PI), connectB2);\nconnectB1.push_back(connectB2);\nconnectB.push_back(connectB1);"}, "coordinates": [{"x": 0.131, "y": 0.3946}, {"x": 0.7113, "y": 0.3946}, {"x": 0.7113, "y": 0.5116}, {"x": 0.131, "y": 0.5116}], "id": 397, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='398' data-category='paragraph' style='font-size:14px'>meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);</p>", "markdown": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);", "text": "meshtools::merge(pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>*/ 0);"}, "coordinates": [{"x": 0.1326, "y": 0.5192}, {"x": 0.6825, "y": 0.5192}, {"x": 0.6825, "y": 0.533}, {"x": 0.1326, "y": 0.533}], "id": 398, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='399' data-category='paragraph' style='font-size:14px'>// METRICS.<br>metrics.resize(6, pos.cols(), 0.);</p>", "markdown": "// METRICS.\nmetrics.resize(6, pos.cols(), 0.);", "text": "// METRICS.\nmetrics.resize(6, pos.cols(), 0.);"}, "coordinates": [{"x": 0.132, "y": 0.54}, {"x": 0.4083, "y": 0.54}, {"x": 0.4083, "y": 0.5632}, {"x": 0.132, "y": 0.5632}], "id": 399, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='400' data-category='paragraph' style='font-size:14px'>D0 = 1. / ((L0 / N0) * (L0 / N0));<br>D1 = 1. / ((L1 / N1) * (L1 / N1));</p>", "markdown": "D0 = 1. / ((L0 / N0) * (L0 / N0));\nD1 = 1. / ((L1 / N1) * (L1 / N1));", "text": "D0 = 1. / ((L0 / N0) * (L0 / N0));\nD1 = 1. / ((L1 / N1) * (L1 / N1));"}, "coordinates": [{"x": 0.1297, "y": 0.5704}, {"x": 0.4095, "y": 0.5704}, {"x": 0.4095, "y": 0.5944}, {"x": 0.1297, "y": 0.5944}], "id": 400, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='401' data-category='paragraph' style='font-size:14px'>for (size_t n = 0; n < pos.cols(); ++n)</p>", "markdown": "for (size_t n = 0; n < pos.cols(); ++n)", "text": "for (size_t n = 0; n < pos.cols(); ++n)"}, "coordinates": [{"x": 0.1317, "y": 0.6026}, {"x": 0.4487, "y": 0.6026}, {"x": 0.4487, "y": 0.6153}, {"x": 0.1317, "y": 0.6153}], "id": 401, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='402' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1329, "y": 0.6139}, {"x": 0.1425, "y": 0.6139}, {"x": 0.1425, "y": 0.6246}, {"x": 0.1329, "y": 0.6246}], "id": 402, "page": 34}, {"category": "table", "content": {"html": "<br><table id='403' style='font-size:14px'><thead></thead><tbody><tr><td>metrics(0,n) = D0;</td><td>//</td><td>Mxx</td></tr><tr><td>metrics(1,n) = 0.0;</td><td>//</td><td>Mxy</td></tr><tr><td>metrics(2,n) = D0;</td><td>//</td><td>Myy = Mxx</td></tr><tr><td>metrics(3,n) = 0.0;</td><td>//</td><td>Mxz</td></tr><tr><td>metrics(4,n) = 0.0;</td><td>//</td><td>Myz</td></tr><tr><td>metrics(5,n) = D1;</td><td>//</td><td>Mzz</td></tr></tbody></table>", "markdown": "| metrics(0,n) = D0; | // | Mxx |\n| --- | --- | --- |\n| metrics(1,n) = 0.0; | // | Mxy |\n| metrics(2,n) = D0; | // | Myy = Mxx |\n| metrics(3,n) = 0.0; | // | Mxz |\n| metrics(4,n) = 0.0; | // | Myz |\n| metrics(5,n) = D1; | // | Mzz |\n", "text": "| metrics(0,n) = D0; | // | Mxx |\n| --- | --- | --- |\n| metrics(1,n) = 0.0; | // | Mxy |\n| metrics(2,n) = D0; | // | Myy = Mxx |\n| metrics(3,n) = 0.0; | // | Mxz |\n| metrics(4,n) = 0.0; | // | Myz |\n| metrics(5,n) = D1; | // | Mzz |\n"}, "coordinates": [{"x": 0.1518, "y": 0.6239}, {"x": 0.4367, "y": 0.6239}, {"x": 0.4367, "y": 0.6867}, {"x": 0.1518, "y": 0.6867}], "id": 403, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='404' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1315, "y": 0.6851}, {"x": 0.142, "y": 0.6851}, {"x": 0.142, "y": 0.6968}, {"x": 0.1315, "y": 0.6968}], "id": 404, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='405' data-category='paragraph' style='font-size:14px'>// 3D MESH.<br>tetramesh_aniso::mesher the_mesher;<br>tetramesh_aniso::mesher::data_type data(pos, connectB);<br>the_mesher.settings.compute_Qh_flag = true;<br>data.metrics = metrics;<br>the_mesher.run(data);<br>data.extract(pos, connectM);<br>data.print_info(&display_hdl);</p>", "markdown": "// 3D MESH.\ntetramesh_aniso::mesher the_mesher;\ntetramesh_aniso::mesher::data_type data(pos, connectB);\nthe_mesher.settings.compute_Qh_flag = true;\ndata.metrics = metrics;\nthe_mesher.run(data);\ndata.extract(pos, connectM);\ndata.print_info(&display_hdl);", "text": "// 3D MESH.\ntetramesh_aniso::mesher the_mesher;\ntetramesh_aniso::mesher::data_type data(pos, connectB);\nthe_mesher.settings.compute_Qh_flag = true;\ndata.metrics = metrics;\nthe_mesher.run(data);\ndata.extract(pos, connectM);\ndata.print_info(&display_hdl);"}, "coordinates": [{"x": 0.1311, "y": 0.7064}, {"x": 0.6048, "y": 0.7064}, {"x": 0.6048, "y": 0.7901}, {"x": 0.1311, "y": 0.7901}], "id": 405, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='406' data-category='paragraph' style='font-size:14px'>// MESH VISUALISATION.<br>meshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),<br>DoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0<br>meshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);</p>", "markdown": "// MESH VISUALISATION.\nmeshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),\nDoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0\nmeshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);", "text": "// MESH VISUALISATION.\nmeshtools::clip(pos, connectM, DoubleVec3(L0/2 +1E-6, L0/2 +1E-6, 0.),\nDoubleVec3(-1., 0., 0.), connectM2); // clip out X > 0\nmeshtools::medit_output(\"TH.mesh\", pos, connectM2, CM2_TETRA4);"}, "coordinates": [{"x": 0.1306, "y": 0.799}, {"x": 0.7015, "y": 0.799}, {"x": 0.7015, "y": 0.8428}, {"x": 0.1306, "y": 0.8428}], "id": 406, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='407' data-category='paragraph' style='font-size:14px'>return 0;<br>// main</p>", "markdown": "return 0;\n// main", "text": "return 0;\n// main"}, "coordinates": [{"x": 0.1251, "y": 0.8514}, {"x": 0.2065, "y": 0.8514}, {"x": 0.2065, "y": 0.8726}, {"x": 0.1251, "y": 0.8726}], "id": 407, "page": 34}, {"category": "paragraph", "content": {"html": "<br><p id='408' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1087, "y": 0.8619}, {"x": 0.1184, "y": 0.8619}, {"x": 0.1184, "y": 0.8726}, {"x": 0.1087, "y": 0.8726}], "id": 408, "page": 34}, {"category": "table", "content": {"html": "<table id='409' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>34</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 34 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 34 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0131, "y": 0.9481}, {"x": 0.9985, "y": 0.9481}, {"x": 0.9985, "y": 1}, {"x": 0.0131, "y": 1}], "id": 409, "page": 34}, {"category": "figure", "content": {"html": "<figure id='410'><img alt=\"\" data-coord=\"top-left:(294,164); bottom-right:(944,1256)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2371, "y": 0.094}, {"x": 0.7612, "y": 0.094}, {"x": 0.7612, "y": 0.7165}, {"x": 0.2371, "y": 0.7165}], "id": 410, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='411' data-category='paragraph' style='font-size:14px'>Figure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom).</p>", "markdown": "Figure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom).", "text": "Figure 20 – An anisotropic beam. Complete model (up) and mesh cut (bottom)."}, "coordinates": [{"x": 0.2589, "y": 0.7507}, {"x": 0.7389, "y": 0.7507}, {"x": 0.7389, "y": 0.7657}, {"x": 0.2589, "y": 0.7657}], "id": 411, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='412' data-category='paragraph' style='font-size:20px'>Here is the output given by data.print_info. Note that the qualities (shape and edge) are computed using<br>the local anisotropic metrics.</p>", "markdown": "Here is the output given by data.print_info. Note that the qualities (shape and edge) are computed using\nthe local anisotropic metrics.", "text": "Here is the output given by data.print_info. Note that the qualities (shape and edge) are computed using\nthe local anisotropic metrics."}, "coordinates": [{"x": 0.0747, "y": 0.8009}, {"x": 0.911, "y": 0.8009}, {"x": 0.911, "y": 0.8321}, {"x": 0.0747, "y": 0.8321}], "id": 412, "page": 35}, {"category": "table", "content": {"html": "<table id='413' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>35</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0066, "y": 0.9479}, {"x": 0.998, "y": 0.9479}, {"x": 0.998, "y": 1}, {"x": 0.0066, "y": 1}], "id": 413, "page": 35}, {"category": "figure", "content": {"html": "<figure id='414'><img style='font-size:14px' alt=\"*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23\" data-coord=\"top-left:(113,123); bottom-right:(1141,839)\" /></figure>", "markdown": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23", "text": "![image](/image/placeholder)\n*******************************************************\n* CM2 TetraMesh Aniso(R) (5.6.0.0) *\n*******************************************************\nHard nodes : 602/602\nHard edges : 1800/1800\nHard faces : 1200/1200\nNodes : 1729\nTets : 8360\nMissing faces : 0\nSubdomains : 1\nVolume : 1.000000E+04\nQmin : 4.381141E-01 (max-min: 7.821716E-01)\nSteiner nodes : 0\nFront time : 0.02 s.\nRefine time : 0.12 s.\nOptim time : 0.06 s.\nTotal time : 0.20 s. (42222.23 th/s.)\n************ HISTOGRAM QS *************\nTotal number of bins : 11\nTotal number of counts : 8360\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 9.796000E-01\nV mean : 7.451805E-01\nV min : 4.381141E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 302\n9 0.80 0.90 2168\n8 0.70 0.80 3138\n7 0.60 0.70 2417\n6 0.50 0.60 334\n5 0.40 0.50 1\n4 0.30 0.40 0\n3 0.20 0.30 0\n2 0.10 0.20 0\n1 0.01 0.10 0\n0 0.00 0.01 0\nNODES : 1729\nNEFS : 8360\nTIME : 0.20 s.\nNEFS / s : 42222.23"}, "coordinates": [{"x": 0.0911, "y": 0.0704}, {"x": 0.9197, "y": 0.0704}, {"x": 0.9197, "y": 0.4787}, {"x": 0.0911, "y": 0.4787}], "id": 414, "page": 36}, {"category": "caption", "content": {"html": "<caption id='415' style='font-size:16px'>Figure 21 – Output info. Shape qualities are computed in the anisotropic metrics.</caption>", "markdown": "Figure 21 – Output info. Shape qualities are computed in the anisotropic metrics.", "text": "Figure 21 – Output info. Shape qualities are computed in the anisotropic metrics."}, "coordinates": [{"x": 0.2516, "y": 0.4901}, {"x": 0.745, "y": 0.4901}, {"x": 0.745, "y": 0.5044}, {"x": 0.2516, "y": 0.5044}], "id": 415, "page": 36}, {"category": "figure", "content": {"html": "<figure id='416'><img style='font-size:14px' alt=\"************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0\" data-coord=\"top-left:(107,947); bottom-right:(1142,1462)\" /></figure>", "markdown": "![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0", "text": "![image](/image/placeholder)\n************ HISTOGRAM QH *************\nTotal number of bins : 20\nTotal number of counts : 10688\nNumber of larger values : 0\nNumber of smaller values : 0\nV max : 1.589670E+00\nV mean : 1.073384E+00\nV min : 5.940392E-01\nBin number -- Bin boundaries -- Hits\n19 10.00 +INF 0\n18 5.00 10.00 0\n17 3.33 5.00 0\n16 2.50 3.33 0\n15 2.00 2.50 0\n14 1.67 2.00 0\n13 1.43 1.67 83\n12 1.25 1.43 1689\n11 1.11 1.25 1979\n10 1.00 1.11 2737\n9 0.90 1.00 2741\n8 0.80 0.90 1034\n7 0.70 0.80 396\n6 0.60 0.70 28\n5 0.50 0.60 1\n4 0.40 0.50 0\n3 0.30 0.40 0\n2 0.20 0.30 0\n1 0.10 0.20 0\n0 0.00 0.10 0"}, "coordinates": [{"x": 0.0864, "y": 0.5402}, {"x": 0.9204, "y": 0.5402}, {"x": 0.9204, "y": 0.8338}, {"x": 0.0864, "y": 0.8338}], "id": 416, "page": 36}, {"category": "caption", "content": {"html": "<caption id='417' style='font-size:16px'>Figure 22 – Edge quality histogram in the anisotropic metrics.</caption>", "markdown": "Figure 22 – Edge quality histogram in the anisotropic metrics.", "text": "Figure 22 – Edge quality histogram in the anisotropic metrics."}, "coordinates": [{"x": 0.3107, "y": 0.8443}, {"x": 0.6865, "y": 0.8443}, {"x": 0.6865, "y": 0.8588}, {"x": 0.3107, "y": 0.8588}], "id": 417, "page": 36}, {"category": "table", "content": {"html": "<table id='418' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>36</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 36 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 36 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0082, "y": 0.9483}, {"x": 0.998, "y": 0.9483}, {"x": 0.998, "y": 1}, {"x": 0.0082, "y": 1}], "id": 418, "page": 36}, {"category": "paragraph", "content": {"html": "<p id='419' data-category='paragraph' style='font-size:16px'>In the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We<br>used the following metric map:</p>", "markdown": "In the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We\nused the following metric map:", "text": "In the next example the metric is not uniform. A sphere (radius R) is uniformly meshed on its boundary. We\nused the following metric map:"}, "coordinates": [{"x": 0.0754, "y": 0.064}, {"x": 0.8896, "y": 0.064}, {"x": 0.8896, "y": 0.096}, {"x": 0.0754, "y": 0.096}], "id": 419, "page": 37}, {"category": "figure", "content": {"html": "<br><figure id='420'><img style='font-size:22px' alt=\"� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�\" data-coord=\"top-left:(155,180); bottom-right:(561,398)\" /></figure>", "markdown": "![image](/image/placeholder)\n� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�", "text": "![image](/image/placeholder)\n� 1 �\n0 0 ������� B�r��T\nh 2\n0\n1\nM�r���� B�� � ������� 0 0\nr\nh�r��2\n1\n0 0\nh�r��2 �\n�"}, "coordinates": [{"x": 0.1251, "y": 0.103}, {"x": 0.4528, "y": 0.103}, {"x": 0.4528, "y": 0.2274}, {"x": 0.1251, "y": 0.2274}], "id": 420, "page": 37}, {"category": "equation", "content": {"html": "<br><p id='421' data-category='equation'>$$\\mathrm{\\bf{B}}{\\bf{\\tilde{(}}}(r)\\!\\!\\mathrm{\\bf{\\tilde{|}}_{r}}{\\bf{\\tilde{|}}_{l e}}{\\bf{\\tilde{u}}_{\\mathrm{spheric}}\\mathrm{\\basi}_{\\mathrm{\\tilde{l}}}}.$$</p>", "markdown": "$$\\mathrm{\\bf{B}}{\\bf{\\tilde{(}}}(r)\\!\\!\\mathrm{\\bf{\\tilde{|}}_{r}}{\\bf{\\tilde{|}}_{l e}}{\\bf{\\tilde{u}}_{\\mathrm{spheric}}\\mathrm{\\basi}_{\\mathrm{\\tilde{l}}}}.$$", "text": "B�r������� ur �r�� v θ �r�� w � �r���\n the local spheric basis."}, "coordinates": [{"x": 0.6, "y": 0.1207}, {"x": 0.8453, "y": 0.1207}, {"x": 0.8453, "y": 0.1633}, {"x": 0.6, "y": 0.1633}], "id": 421, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='422' data-category='paragraph' style='font-size:16px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.519, "y": 0.16}, {"x": 0.5609, "y": 0.16}, {"x": 0.5609, "y": 0.1766}, {"x": 0.519, "y": 0.1766}], "id": 422, "page": 37}, {"category": "equation", "content": {"html": "<br><p id='423' data-category='equation'>$$h{\\binom{\\alpha}{\\alpha}}=h_{1}{\\frac{\\displaystyle r}{R}}+h_{0}\\Biggl(1-{\\frac{\\displaystyle r}{R}}\\Biggr)$$</p>", "markdown": "$$h{\\binom{\\alpha}{\\alpha}}=h_{1}{\\frac{\\displaystyle r}{R}}+h_{0}\\Biggl(1-{\\frac{\\displaystyle r}{R}}\\Biggr)$$", "text": "r �\n h�r�� � h1 Rr � h0 ��� 1 � ��\n R"}, "coordinates": [{"x": 0.6009, "y": 0.1696}, {"x": 0.7983, "y": 0.1696}, {"x": 0.7983, "y": 0.2132}, {"x": 0.6009, "y": 0.2132}], "id": 423, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='424' data-category='paragraph' style='font-size:16px'>Radially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the<br>boundary of the sphere.</p>", "markdown": "Radially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the\nboundary of the sphere.", "text": "Radially we want the constant size h0 but tangentially the size varies between h0 at center and h1 on the\nboundary of the sphere."}, "coordinates": [{"x": 0.0761, "y": 0.2461}, {"x": 0.855, "y": 0.2461}, {"x": 0.855, "y": 0.2776}, {"x": 0.0761, "y": 0.2776}], "id": 424, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='425' data-category='paragraph' style='font-size:16px'>The mesher input metric map is only given at the boundary nodes of the external sphere and at the center<br>node. The mesher will do the interpolation in-between.</p>", "markdown": "The mesher input metric map is only given at the boundary nodes of the external sphere and at the center\nnode. The mesher will do the interpolation in-between.", "text": "The mesher input metric map is only given at the boundary nodes of the external sphere and at the center\nnode. The mesher will do the interpolation in-between."}, "coordinates": [{"x": 0.0752, "y": 0.2869}, {"x": 0.8869, "y": 0.2869}, {"x": 0.8869, "y": 0.3183}, {"x": 0.0752, "y": 0.3183}], "id": 425, "page": 37}, {"category": "figure", "content": {"html": "<figure id='426'><img alt=\"\" data-coord=\"top-left:(315,587); bottom-right:(927,1057)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2541, "y": 0.335}, {"x": 0.7476, "y": 0.335}, {"x": 0.7476, "y": 0.6029}, {"x": 0.2541, "y": 0.6029}], "id": 426, "page": 37}, {"category": "table", "content": {"html": "<table id='427' style='font-size:14px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>37</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 37 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 37 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.003, "y": 0.9479}, {"x": 0.9994, "y": 0.9479}, {"x": 0.9994, "y": 1}, {"x": 0.003, "y": 1}], "id": 427, "page": 37}, {"category": "figure", "content": {"html": "<figure id='428'><img alt=\"\" data-coord=\"top-left:(316,110); bottom-right:(928,728)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2549, "y": 0.0628}, {"x": 0.748, "y": 0.0628}, {"x": 0.748, "y": 0.4155}, {"x": 0.2549, "y": 0.4155}], "id": 428, "page": 38}, {"category": "caption", "content": {"html": "<br><caption id='429' style='font-size:14px'>Figure 23 – An anisotropic sphere (mesh cut).</caption>", "markdown": "Figure 23 – An anisotropic sphere (mesh cut).", "text": "Figure 23 – An anisotropic sphere (mesh cut)."}, "coordinates": [{"x": 0.36, "y": 0.4148}, {"x": 0.6392, "y": 0.4148}, {"x": 0.6392, "y": 0.4291}, {"x": 0.36, "y": 0.4291}], "id": 429, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='430' data-category='paragraph' style='font-size:20px'>Background meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic<br>counter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid<br>(three strictly positive eigen-values).</p>", "markdown": "Background meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic\ncounter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid\n(three strictly positive eigen-values).", "text": "Background meshes can also be used with the 3-D anisotropic mesher in the same way as the isotropic\ncounter-part (see Example 9). Recall that the metric matrix at each node of the background mesh must be valid\n(three strictly positive eigen-values)."}, "coordinates": [{"x": 0.0764, "y": 0.4637}, {"x": 0.9195, "y": 0.4637}, {"x": 0.9195, "y": 0.5098}, {"x": 0.0764, "y": 0.5098}], "id": 430, "page": 38}, {"category": "table", "content": {"html": "<table id='431' style='font-size:16px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>38</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 38 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 38 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0037, "y": 0.9479}, {"x": 0.9994, "y": 0.9479}, {"x": 0.9994, "y": 1}, {"x": 0.0037, "y": 1}], "id": 431, "page": 38}, {"category": "heading1", "content": {"html": "<h1 id='432' style='font-size:20px'>CM2 TetraMesh® Iso</h1>", "markdown": "# CM2 TetraMesh® Iso", "text": "CM2 TetraMesh® Iso"}, "coordinates": [{"x": 0.0984, "y": 0.6987}, {"x": 0.6077, "y": 0.6987}, {"x": 0.6077, "y": 0.7365}, {"x": 0.0984, "y": 0.7365}], "id": 432, "page": 39}, {"category": "heading1", "content": {"html": "<br><h1 id='433' style='font-size:16px'>Version 5.6</h1>", "markdown": "# Version 5.6", "text": "Version 5.6"}, "coordinates": [{"x": 0.1, "y": 0.7412}, {"x": 0.2296, "y": 0.7412}, {"x": 0.2296, "y": 0.7619}, {"x": 0.1, "y": 0.7619}], "id": 433, "page": 39}, {"category": "heading1", "content": {"html": "<h1 id='434' style='font-size:18px'>mesh gallery</h1>", "markdown": "# mesh gallery", "text": "mesh gallery"}, "coordinates": [{"x": 0.1008, "y": 0.7948}, {"x": 0.3376, "y": 0.7948}, {"x": 0.3376, "y": 0.8232}, {"x": 0.1008, "y": 0.8232}], "id": 434, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='435' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>", "markdown": "Revision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.", "text": "Revision February 2025.\nhttps://www.computing-objects.com\n© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France."}, "coordinates": [{"x": 0.1002, "y": 0.9238}, {"x": 0.5961, "y": 0.9238}, {"x": 0.5961, "y": 0.9763}, {"x": 0.1002, "y": 0.9763}], "id": 435, "page": 39}, {"category": "figure", "content": {"html": "<figure id='436'><img style='font-size:16px' alt=\"Figure 1 – Block-stop.\" data-coord=\"top-left:(390,406); bottom-right:(858,1005)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 1 – Block-stop.", "text": "![image](/image/placeholder)\nFigure 1 – Block-stop."}, "coordinates": [{"x": 0.3148, "y": 0.2319}, {"x": 0.692, "y": 0.2319}, {"x": 0.692, "y": 0.5732}, {"x": 0.3148, "y": 0.5732}], "id": 436, "page": 40}, {"category": "figure", "content": {"html": "<figure id='437'><img style='font-size:14px' alt=\"Nodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)\" data-coord=\"top-left:(374,1152); bottom-right:(916,1375)\" /></figure>", "markdown": "![image](/image/placeholder)\nNodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)", "text": "![image](/image/placeholder)\nNodes : 270\nTets : 883\nMissing faces : 0\nSubdomains : 1\nVolume : 9.277810E-01\nQmin : 3.409671E-01 (max-min: 5.641645E-01)\nSteiner nodes : 0\nFront time : 0.00 s.\nRefine time : 0.01 s.\nOptim time : 0.00 s.\nTotal time : 0.01 s. (63071.70 th/s.)"}, "coordinates": [{"x": 0.3014, "y": 0.6568}, {"x": 0.7388, "y": 0.6568}, {"x": 0.7388, "y": 0.784}, {"x": 0.3014, "y": 0.784}], "id": 437, "page": 40}, {"category": "footer", "content": {"html": "<footer id='438' style='font-size:20px'>The output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)<br>on Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled).</footer>", "markdown": "The output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)\non Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled).", "text": "The output information given here are only indicative. All runs were done with x64 CM2 libs (Visual Studio 2022 MD build)\non Windows 8.1 x64 with Intel Xeon E3-1270 V2 3.5 GHz (4 cores with hyper-threading, turbo boost disabled)."}, "coordinates": [{"x": 0.0742, "y": 0.8847}, {"x": 0.9048, "y": 0.8847}, {"x": 0.9048, "y": 0.9139}, {"x": 0.0742, "y": 0.9139}], "id": 438, "page": 40}, {"category": "table", "content": {"html": "<table id='439' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>40</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 40 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 40 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0091, "y": 0.9474}, {"x": 0.999, "y": 0.9474}, {"x": 0.999, "y": 1}, {"x": 0.0091, "y": 1}], "id": 439, "page": 40}, {"category": "figure", "content": {"html": "<figure id='440'><img alt=\"\" data-coord=\"top-left:(393,410); bottom-right:(846,965)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3171, "y": 0.2339}, {"x": 0.6824, "y": 0.2339}, {"x": 0.6824, "y": 0.5504}, {"x": 0.3171, "y": 0.5504}], "id": 440, "page": 41}, {"category": "caption", "content": {"html": "<br><caption id='441' style='font-size:16px'>Figure 2 – Hammer.</caption>", "markdown": "Figure 2 – Hammer.", "text": "Figure 2 – Hammer."}, "coordinates": [{"x": 0.4365, "y": 0.5487}, {"x": 0.5612, "y": 0.5487}, {"x": 0.5612, "y": 0.5622}, {"x": 0.4365, "y": 0.5622}], "id": 441, "page": 41}, {"category": "figure", "content": {"html": "<figure id='442'><img style='font-size:14px' alt=\"odes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)\" data-coord=\"top-left:(377,1176); bottom-right:(914,1373)\" /></figure>", "markdown": "![image](/image/placeholder)\nodes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)", "text": "![image](/image/placeholder)\nodes : 3027\nTets : 12031\nMissing faces : 0\nSubdomains : 1\nVolume : 2.019083E+11\nQmin : 3.017365E-02 (max-min: 3.031752E-02)\nSteiner nodes : 0\nFront time : 0.07 s.\nRefine time : 0.08 s.\nOptim time : 0.01 s.\nTotal time : 0.16 s. (75193.71 th/s.)"}, "coordinates": [{"x": 0.3044, "y": 0.6708}, {"x": 0.737, "y": 0.6708}, {"x": 0.737, "y": 0.7828}, {"x": 0.3044, "y": 0.7828}], "id": 442, "page": 41}, {"category": "table", "content": {"html": "<table id='443' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>41</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 41 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 41 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0064, "y": 0.9481}, {"x": 0.9989, "y": 0.9481}, {"x": 0.9989, "y": 1}, {"x": 0.0064, "y": 1}], "id": 443, "page": 41}, {"category": "figure", "content": {"html": "<figure id='444'><img style='font-size:16px' alt=\"Figure 3 – Driving Rod.\" data-coord=\"top-left:(258,402); bottom-right:(975,991)\" /></figure>", "markdown": "![image](/image/placeholder)\nFigure 3 – Driving Rod.", "text": "![image](/image/placeholder)\nFigure 3 – Driving Rod."}, "coordinates": [{"x": 0.2082, "y": 0.2296}, {"x": 0.7857, "y": 0.2296}, {"x": 0.7857, "y": 0.5655}, {"x": 0.2082, "y": 0.5655}], "id": 444, "page": 42}, {"category": "figure", "content": {"html": "<figure id='445'><img style='font-size:14px' alt=\"Nodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)\" data-coord=\"top-left:(376,1171); bottom-right:(916,1372)\" /></figure>", "markdown": "![image](/image/placeholder)\nNodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)", "text": "![image](/image/placeholder)\nNodes : 1844\nTets : 5937\nMissing faces : 0\nSubdomains : 1\nVolume : 9.848692E-01\nQmin : 2.677825E-01 (max-min: 6.300594E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.02 s.\nTotal time : 0.09 s. (62494.88 th/s.)"}, "coordinates": [{"x": 0.3035, "y": 0.6681}, {"x": 0.7384, "y": 0.6681}, {"x": 0.7384, "y": 0.7827}, {"x": 0.3035, "y": 0.7827}], "id": 445, "page": 42}, {"category": "table", "content": {"html": "<table id='446' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>42</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 42 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 42 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0063, "y": 0.9477}, {"x": 0.999, "y": 0.9477}, {"x": 0.999, "y": 1}, {"x": 0.0063, "y": 1}], "id": 446, "page": 42}, {"category": "figure", "content": {"html": "<figure id='447'><img alt=\"\" data-coord=\"top-left:(280,403); bottom-right:(954,973)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2257, "y": 0.23}, {"x": 0.7693, "y": 0.23}, {"x": 0.7693, "y": 0.5551}, {"x": 0.2257, "y": 0.5551}], "id": 447, "page": 43}, {"category": "paragraph", "content": {"html": "<br><p id='448' data-category='paragraph' style='font-size:16px'>Figure 4 – Blade.</p>", "markdown": "Figure 4 – Blade.", "text": "Figure 4 – Blade."}, "coordinates": [{"x": 0.4458, "y": 0.549}, {"x": 0.5522, "y": 0.549}, {"x": 0.5522, "y": 0.5618}, {"x": 0.4458, "y": 0.5618}], "id": 448, "page": 43}, {"category": "figure", "content": {"html": "<figure id='449'><img style='font-size:14px' alt=\"Nodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)\" data-coord=\"top-left:(374,1163); bottom-right:(915,1378)\" /></figure>", "markdown": "![image](/image/placeholder)\nNodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)", "text": "![image](/image/placeholder)\nNodes : 1631\nTets : 5542\nMissing faces : 0\nSubdomains : 1\nVolume : 1.149084E-01\nQmin : 1.701167E-01 (max-min: 2.183494E-01)\nSteiner nodes : 0\nFront time : 0.04 s.\nRefine time : 0.03 s.\nOptim time : 0.01 s.\nTotal time : 0.08 s. (70151.90 th/s.)"}, "coordinates": [{"x": 0.3015, "y": 0.6634}, {"x": 0.7377, "y": 0.6634}, {"x": 0.7377, "y": 0.7858}, {"x": 0.3015, "y": 0.7858}], "id": 449, "page": 43}, {"category": "table", "content": {"html": "<table id='450' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>43</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0062, "y": 0.9477}, {"x": 0.9991, "y": 0.9477}, {"x": 0.9991, "y": 1}, {"x": 0.0062, "y": 1}], "id": 450, "page": 43}, {"category": "figure", "content": {"html": "<figure id='451'><img alt=\"\" data-coord=\"top-left:(398,405); bottom-right:(849,966)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3212, "y": 0.2314}, {"x": 0.6842, "y": 0.2314}, {"x": 0.6842, "y": 0.551}, {"x": 0.3212, "y": 0.551}], "id": 451, "page": 44}, {"category": "caption", "content": {"html": "<br><caption id='452' style='font-size:16px'>Figure 5 – Rim.</caption>", "markdown": "Figure 5 – Rim.", "text": "Figure 5 – Rim."}, "coordinates": [{"x": 0.4513, "y": 0.5487}, {"x": 0.5467, "y": 0.5487}, {"x": 0.5467, "y": 0.5624}, {"x": 0.4513, "y": 0.5624}], "id": 452, "page": 44}, {"category": "figure", "content": {"html": "<figure id='453'><img style='font-size:14px' alt=\"Nodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)\" data-coord=\"top-left:(381,1177); bottom-right:(907,1369)\" /></figure>", "markdown": "![image](/image/placeholder)\nNodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)", "text": "![image](/image/placeholder)\nNodes : 63984\nTets : 238849\nMissing faces : 0\nSubdomains : 1\nVolume : 6.174414E+06\nQmin : 4.427687E-02 (max-min: 2.414112E-01)\nSteiner nodes : 2\nFront time : 2.55 s.\nRefine time : 1.14 s.\nOptim time : 0.78 s.\nTotal time : 4.52 s. (52819.33 th/s.)"}, "coordinates": [{"x": 0.3073, "y": 0.6713}, {"x": 0.7309, "y": 0.6713}, {"x": 0.7309, "y": 0.7807}, {"x": 0.3073, "y": 0.7807}], "id": 453, "page": 44}, {"category": "table", "content": {"html": "<table id='454' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>44</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 44 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 44 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0061, "y": 0.9477}, {"x": 0.9991, "y": 0.9477}, {"x": 0.9991, "y": 1}, {"x": 0.0061, "y": 1}], "id": 454, "page": 44}, {"category": "figure", "content": {"html": "<figure id='455'><img alt=\"\" data-coord=\"top-left:(284,409); bottom-right:(946,956)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.2296, "y": 0.2336}, {"x": 0.7629, "y": 0.2336}, {"x": 0.7629, "y": 0.5452}, {"x": 0.2296, "y": 0.5452}], "id": 455, "page": 45}, {"category": "caption", "content": {"html": "<br><caption id='456' style='font-size:16px'>Figure 6 – Crank.</caption>", "markdown": "Figure 6 – Crank.", "text": "Figure 6 – Crank."}, "coordinates": [{"x": 0.4443, "y": 0.5485}, {"x": 0.5533, "y": 0.5485}, {"x": 0.5533, "y": 0.5624}, {"x": 0.4443, "y": 0.5624}], "id": 456, "page": 45}, {"category": "figure", "content": {"html": "<figure id='457'><img style='font-size:14px' alt=\"Nodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)\" data-coord=\"top-left:(374,1165); bottom-right:(918,1377)\" /></figure>", "markdown": "![image](/image/placeholder)\nNodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)", "text": "![image](/image/placeholder)\nNodes : 50260\nTets : 253949\nMissing faces : 0\nSubdomains : 1\nVolume : 1.170195E+05\nQmin : 3.187160E-01 (max-min: 4.462804E-01)\nSteiner nodes : 0\nFront time : 0.65 s.\nRefine time : 2.04 s.\nOptim time : 1.34 s.\nTotal time : 4.05 s. (62734.43 th/s.)"}, "coordinates": [{"x": 0.3015, "y": 0.6642}, {"x": 0.7399, "y": 0.6642}, {"x": 0.7399, "y": 0.7855}, {"x": 0.3015, "y": 0.7855}], "id": 457, "page": 45}, {"category": "table", "content": {"html": "<table id='458' style='font-size:20px'><thead></thead><tbody><tr><td>© Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TetraMesh® Iso/Aniso - tutorials</td><td>45</td></tr></tbody></table>", "markdown": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 45 |\n| --- | --- | --- |\n", "text": "| © Computing Objects /version 5.6 rev. February 2025 | CM2 TetraMesh® Iso/Aniso - tutorials | 45 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0063, "y": 0.9482}, {"x": 0.9989, "y": 0.9482}, {"x": 0.9989, "y": 1}, {"x": 0.0063, "y": 1}], "id": 458, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='459' data-category='paragraph' style='font-size:14px'>https://www.computing-objects.com</p>", "markdown": "https://www.computing-objects.com", "text": "https://www.computing-objects.com"}, "coordinates": [{"x": 0.1015, "y": 0.9025}, {"x": 0.3335, "y": 0.9025}, {"x": 0.3335, "y": 0.9149}, {"x": 0.1015, "y": 0.9149}], "id": 459, "page": 46}, {"category": "paragraph", "content": {"html": "<br><p id='460' data-category='paragraph' style='font-size:14px'>© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.</p>", "markdown": "© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France.", "text": "© Computing Objects SARL - 25 rue du Maréchal Foch, 78000 Versailles, France."}, "coordinates": [{"x": 0.1007, "y": 0.9216}, {"x": 0.5965, "y": 0.9216}, {"x": 0.5965, "y": 0.9332}, {"x": 0.1007, "y": 0.9332}], "id": 460, "page": 46}, {"category": "paragraph", "content": {"html": "<br><p id='461' data-category='paragraph' style='font-size:14px'>Limited Liability Company with a capital of 100 000 €.<br>Registered at Versailles RCS under SIRET number 422 791 038 00033.<br>EU VAT registration FR59422791038.</p>", "markdown": "Limited Liability Company with a capital of 100 000 €.\nRegistered at Versailles RCS under SIRET number 422 791 038 00033.\nEU VAT registration FR59422791038.", "text": "Limited Liability Company with a capital of 100 000 €.\nRegistered at Versailles RCS under SIRET number 422 791 038 00033.\nEU VAT registration FR59422791038."}, "coordinates": [{"x": 0.1023, "y": 0.9391}, {"x": 0.5392, "y": 0.9391}, {"x": 0.5392, "y": 0.9749}, {"x": 0.1023, "y": 0.9749}], "id": 461, "page": 46}], "model": "document-parse-250618", "ocr": false, "usage": {"pages": 46}}