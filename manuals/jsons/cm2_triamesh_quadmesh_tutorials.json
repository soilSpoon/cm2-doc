{"api": "2.0", "content": {"html": "<h1 id='0' style='font-size:20px'>COMPUTING<br>OBJECTS</h1>\n<h1 id='1' style='font-size:22px'>CM2 TriaMeshⓇ Iso/Aniso<br>CM2 QuadMesh � Iso/Aniso</h1>\n<br><h1 id='2' style='font-size:16px'>Version 5.6</h1>\n<p id='3' data-category='paragraph' style='font-size:18px'>tutorials</p>\n<p id='4' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>Ⓒ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France.</p>\n<h1 id='5' style='font-size:20px'>Forewords</h1>\n<p id='6' data-category='paragraph' style='font-size:16px'>This manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:</p>\n<p id='7' data-category='list' style='font-size:14px'>· The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,<br>· The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso.</p>\n<p id='8' data-category='paragraph' style='font-size:16px'>All these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well<br>as the internal hard edges and hard points (embedded) are kept unmodified in the final mesh.</p>\n<p id='9' data-category='paragraph' style='font-size:16px'>Based on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality<br>elements with smooth grading sizes according to the length of the boundary edges or to the user-specified<br>sizes. The speed is near independent of the number of the elements to be generated.</p>\n<p id='10' data-category='paragraph' style='font-size:16px'>Setting switches can be used to adapt the meshers to the various needs of the user concerning mesh<br>generation, refinement and optimization (they can also be used as optimizer-only of some already existing<br>meshes).</p>\n<p id='11' data-category='paragraph' style='font-size:16px'>The quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes.</p>\n<p id='12' data-category='paragraph' style='font-size:16px'>Many data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the<br>neighbors, number of sub-domains, area...</p>\n<p id='13' data-category='paragraph' style='font-size:16px'>Like many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-<br>threaded (you can select in the settings the maximum number of threads the generator can use).<br>The generated meshes are reproducible (same mesh with same input data and same mesh with any number of<br>threads).</p>\n<p id='14' data-category='paragraph' style='font-size:16px'>Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners<br>should start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers.</p>\n<p id='15' data-category='paragraph' style='font-size:14px'>For a complete description of the data and settings structures used with these meshers please refer to the<br>CM2 TriaMesh & CM2 QuadMesh - reference manual.</p>\n<p id='16' data-category='paragraph' style='font-size:18px'>The source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit<br>number IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.<br>S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.</p>\n<p id='17' data-category='paragraph' style='font-size:16px'>The source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly<br>deposited since then.</p>\n<p id='18' data-category='paragraph' style='font-size:16px'>The source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly<br>deposited since then.</p>\n<table id='19' style='font-size:16px'><thead></thead><tbody><tr><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 2 tutorials</td></tr></tbody></table>\n<h1 id='20' style='font-size:20px'>Table of contents</h1>\n<p id='21' data-category='paragraph' style='font-size:14px'>Forewords. ...... 2</p>\n<br><p id='22' data-category='list' style='font-size:18px'>1. Getting started - a simple square .......... ········· 5<br>Some declarations 6<br>Authorization of the library........ 6<br>Contour mesh 7<br>2. Square with an internal line.......... ...... 14<br>3. Square with internal hole ....... 17<br>4. Quadratic elements & high-order nodes ........ ........ 19<br>5. Square with grading mesh size. ........ 21<br>6. Square with an internal hard node ......... ....... 23<br>7. Multiple meshes ........ ·········· 25<br>8. Shared boundaries ......... ....... 28<br>9. Background mesh ..... ······· 32<br>10. Anisotropic meshes. ...... 38<br>11. 3-D surface meshes (aniso meshers only) .... ...... 43</p>\n<table id='23' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials</td></tr></tbody></table>\n<p id='24' data-category='paragraph' style='font-size:20px'>Before meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter<br>mostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One<br>example (Section 7) illustrates the case where the boundary mesh has been generated by other means and is<br>simply read from a file.</p>\n<p id='25' data-category='paragraph' style='font-size:20px'>Each example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the<br>classes and the functions of the library (API).</p>\n<p id='26' data-category='paragraph' style='font-size:18px'>The general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:<br>: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.<br>h file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to<br>avoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.</p>\n<p id='27' data-category='paragraph' style='font-size:18px'>File stdafx.h1:</p>\n<p id='28' data-category='paragraph' style='font-size:14px'>CM2 MESHTOOLS</p>\n<br><p id='29' data-category='paragraph' style='font-size:14px'>11<br>#include \" meshtools. h\"<br>#include \" meshtoo ls1d.h\"<br>#include \" tri amesh_iso. h\"<br>#include \" quadmesh_iso. h\"<br>#include \" triamesh_aniso.h\"<br>#include \"quadmesh_aniso.h\"</p>\n<br><table id='30' style='font-size:16px'><thead></thead><tbody><tr><td>General purpose mesh routines</td></tr><tr><td>To generate 1D meshes</td></tr><tr><td>CM2 TriaMesh Iso</td></tr><tr><td>CM2 QuadMesh Iso</td></tr><tr><td>CM2 TriaMesh Aniso (Section 10 onlyly)</td></tr><tr><td>CM2 QuadMesh Aniso (Section 10</td></tr></tbody></table>\n<br><p id='31' data-category='paragraph' style='font-size:18px'>using namespace cm2;</p>\n<br><p id='32' data-category='paragraph' style='font-size:14px'>/ Main cm2 namespace can now be omitted.</p>\n<p id='33' data-category='paragraph' style='font-size:22px'>Required libraries2:</p>\n<p id='34' data-category='list' style='font-size:14px'>· cm2math1<br>· cm2misc<br>· cm2meshtools<br>· cm2meshtools1d<br>· cm2meshtools2d<br>· cm2triamesh_ iso<br>· cm2quadmesh_ iso<br>· cm2triamesh_aniso (Section 10 only)<br>· cm2quadmesh_aniso (Section 10 only)</p>\n<p id='35' data-category='footnote' style='font-size:16px'>1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_<br>iso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.<br>2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are<br>lib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib).</p>\n<table id='36' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>4</td></tr></tbody></table>\n<h1 id='37' style='font-size:22px'>1. Getting started - a simple square</h1>\n<p id='38' data-category='paragraph' style='font-size:18px'>This first example is a regular mesh of a square. The four boundary segments are equally discretized with 10<br>elements.</p>\n<p id='39' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream></p>\n<p id='40' data-category='paragraph' style='font-size:14px'>11 Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }</p>\n<p id='41' data-category='paragraph' style='font-size:14px'>int main()</p>\n<br><p id='42' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='43' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L(10.);</td></tr><tr><td>const unsublevec2</td><td>N(10) ;</td></tr><tr><td>const Doub</td><td>PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>\n<p id='44' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;<br>,</p>\n<br><p id='45' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.</p>\n<br><p id='46' data-category='paragraph' style='font-size:14px'>pos . push_back (PO) ;<br>pos · push_back(P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;<br>meshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;<br>meshtools1d: : indices_to_connectE2(indices, connectB) ;</p>\n<p id='47' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_iso: : mesher the_mesher;<br>triamesh_iso: : mesher: :data_type data (pos, connectB) ;<br>the_mesher . run(data) ;</p>\n<p id='48' data-category='paragraph' style='font-size:14px'>11 SOME OUTPUT INFO (OPTIONAL) .<br>data.print_info(&display_hdl) ;</p>\n<p id='49' data-category='paragraph' style='font-size:14px'>11 VISUALISATION (OPTIONAL) .<br>meshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;</p>\n<br><p id='50' data-category='paragraph' style='font-size:14px'>return 0;<br>} 11 main</p>\n<h1 id='51' style='font-size:20px'>The resulting mesh is shown Figure 1.</h1>\n<table id='52' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials</td></tr></tbody></table>\n<figure id='53'><img alt=\"\" data-coord=\"top-left:(380,118); bottom-right:(859,592)\" /><figcaption id='54' style='font-size:14px'>Figure 1 - Triangle mesh of a square.</figcaption></figure>\n\n<p id='55' data-category='paragraph' style='font-size:18px'>Let us explain this program line by line.</p>\n<h1 id='56' style='font-size:20px'>Some declarations</h1>\n<p id='57' data-category='paragraph' style='font-size:16px'>Matrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a<br>UIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column<br>number in matrix pos where the coordinates of this node can be found4.</p>\n<p id='58' data-category='paragraph' style='font-size:18px'>indices is a temporary vector.</p>\n<p id='59' data-category='paragraph' style='font-size:22px'>Authorization of the library</p>\n<p id='60' data-category='paragraph' style='font-size:16px'>The library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to<br>tri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for<br>each library: the name of your company or organization that has acquired the license and a secret code5. Note<br>that both strings are case sensitive and the registration call must be made each time the library is loaded into<br>memory and before the first run of the mesher.</p>\n<p id='61' data-category='paragraph' style='font-size:14px'>triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<p id='62' data-category='list' style='font-size:14px'>3 See manual CM2 Math1 - overview.<br>4 Recall that array indices are zero based (from 0 to N-1).<br>5 Contact license@computing-objects.com for any licensing inquiry.</p>\n<table id='63' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials</td></tr></tbody></table>\n<p id='64' data-category='paragraph' style='font-size:22px'>Contour mesh</p>\n<p id='65' data-category='paragraph' style='font-size:20px'>This is usually the heaviest part of the work for the user. In this example, we only use routines from the<br>CM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it<br>form a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos<br>containing the points' coordinates and the connectivity matrix connectB of the boundary edges.</p>\n<p id='66' data-category='paragraph' style='font-size:20px'>First, the corners of the square are created as four pair of coordinates in the pos matrix:</p>\n<p id='67' data-category='paragraph' style='font-size:14px'>pos · push_back(P0) ;<br>pos · push_back(P1) ;<br>pos . push_back(P2) ;<br>pos . push_back(P3) ;</p>\n<p id='68' data-category='paragraph' style='font-size:20px'>The push_back function appends a new column at the end of a matrix. The size of the column must match the<br>current number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows.</p>\n<p id='69' data-category='paragraph' style='font-size:20px'>After these four push-backs, the dimensions of the pos matrix are 2 X 4.</p>\n<table id='70' style='font-size:16px'><thead></thead><tbody><tr><td>meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ;</td></tr><tr><td>meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ;</td></tr></tbody></table>\n<p id='71' data-category='paragraph' style='font-size:20px'>Now that the four corners are present, we can create the points in between and the associated edges:</p>\n<p id='72' data-category='paragraph' style='font-size:20px'>The mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new<br>appended columns in the pos matrix:</p>\n<p id='73' data-category='paragraph' style='font-size:18px'>meshtoo ls1d : : mesh_straight<br>(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;</p>\n<p id='74' data-category='paragraph' style='font-size:20px'>The index of each point, i.e. the column in matrix pos, is also appended to the vector indices.<br>With i0 = 0 and i1 = 1, this vector contains upon exit of this function:</p>\n<p id='75' data-category='paragraph' style='font-size:18px'>[0 4 5 6 7 8 9 10 11 12 1]</p>\n<p id='76' data-category='paragraph' style='font-size:20px'>And the matrix pos is now of size 2 X 13:</p>\n<figure id='77' data-category='chart'><img data-coord=\"top-left:(377,1294); bottom-right:(866,1482)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>Four corners</td><td>New generated nodes</td></tr></thead><tbody><tr><td>item_01</td><td>12</td><td>12</td></tr></tbody></table></figure>\n<p id='78' data-category='paragraph' style='font-size:18px'>6 See Section 5, \"Square with Grading Mesh Size\".</p>\n<table id='79' style='font-size:20px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>7 tutorials</td></tr></tbody></table>\n<p id='80' data-category='paragraph' style='font-size:20px'>The last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:</p>\n<p id='81' data-category='paragraph' style='font-size:14px'>indices · pop_back() ;</p>\n<p id='82' data-category='paragraph' style='font-size:18px'>The second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:</p>\n<br><p id='83' data-category='paragraph' style='font-size:18px'>[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]</p>\n<p id='84' data-category='paragraph' style='font-size:18px'>After the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index<br>equals to the first, here zero, to close the contour7.</p>\n<p id='85' data-category='paragraph' style='font-size:22px'>The vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:</p>\n<p id='86' data-category='paragraph' style='font-size:14px'>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>\n<p id='87' data-category='paragraph' style='font-size:18px'>The connectB matrix has now dimensions 2 X 40:</p>\n<p id='88' data-category='paragraph' style='font-size:14px'>2x40 [0 4 5 6 7 · · · 39<br>4 5 6 7 8 · · · 0]</p>\n<p id='89' data-category='paragraph' style='font-size:18px'>Now that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a<br>data structure holding this 1-D mesh and make the mesher run on it:</p>\n<p id='90' data-category='paragraph' style='font-size:14px'>triamesh_iso : : mesher : :data_type data (pos, connectB) ;<br>the_mesher · run (data) ;</p>\n<p id='91' data-category='paragraph' style='font-size:18px'>This constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos<br>and data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated<br>inside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40<br>points are left untouched in the first 40 columns.</p>\n<p id='92' data-category='paragraph' style='font-size:20px'>The connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of<br>the nodes for an element8. connectM(i, j) is the ith local node of the jth element.</p>\n<p id='93' data-category='paragraph' style='font-size:14px'>7 The same result could have been achieved with:</p>\n<br><p id='94' data-category='paragraph' style='font-size:16px'>UIntVec hard_nodes (5) ;<br>hard_nodes [0] = 日;<br>hard_nodes[1] = 1;<br>hard_nodes[2] = 2;<br>hard_nodes[3] = 3;<br>hard_nodes [4] = 日;<br>meshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;<br>This variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes).</p>\n\n<table id='96' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials</td><td>8</td></tr></tbody><caption id='95' style='font-size:16px'>8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule).</caption></table>\n<p id='97' data-category='paragraph' style='font-size:18px'>Printed information about the generated mesh and a MEDIT9 output file are obtained with:</p>\n<p id='98' data-category='paragraph' style='font-size:14px'>data.print_info(&display_hdl) ;<br>meshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;</p>\n<p id='99' data-category='paragraph' style='font-size:22px'>Here is the output given by data.print_ info(&display_hdl) :</p>\n<figure id='100'><img style='font-size:14px' alt=\"* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙\" data-coord=\"top-left:(106,386); bottom-right:(1141,987)\" /><figcaption id='101' style='font-size:16px'>Figure 2 - Output info for the square example.</figcaption></figure>\n\n<p id='102' data-category='paragraph' style='font-size:20px'>The generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges<br>(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,<br>optimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.<br>In the second step new nodes are generated inside the domain to get elements with good shape and size.<br>Finally, the last step is for geometrical and topological optimizations to improve the quality of the elements.</p>\n<p id='103' data-category='paragraph' style='font-size:16px'>9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront<br>OBJ.</p>\n<p id='104' data-category='footnote' style='font-size:14px'>10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270<br>V2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh<br>Aniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso).</p>\n<table id='105' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials</td></tr></tbody></table>\n<p id='106' data-category='paragraph' style='font-size:18px'>The formula used to compute the shape quality of a triangle writes:</p>\n<table id='107' style='font-size:18px'><thead></thead><tbody><tr><td>S</td><td>S</td><td>Area of the triangle.</td></tr><tr><td>Qs = 4V3 L P</td><td>L with: max</td><td>Length of the longest edge of the triangle.</td></tr><tr><td>max</td><td>P</td><td>Perimeter of the triangle.</td></tr></tbody></table>\n<p id='108' data-category='paragraph' style='font-size:18px'>This quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.<br>On the square example, the worst shape quality is 0.83 and the average is 0.94.</p>\n<p id='109' data-category='paragraph' style='font-size:16px'>The size quality is also an important parameter to take into account. The size quality of an edge is a measure<br>based upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates<br>that the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,<br>and a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as<br>it should be (and should have been split).</p>\n<p id='110' data-category='paragraph' style='font-size:18px'>The formula used to compute the length quality of an edge AB writes:</p>\n<p id='111' data-category='equation'>$$Q_{h}^{4B}=L_{A B}\\,\\frac{\\left|\\displaystyle\\left(\\frac{h_{A}}{h_{B}}\\right)}{h_{A}-h_{B}}$$</p>\n<br><p id='112' data-category='paragraph' style='font-size:14px'>AB</p>\n<br><p id='113' data-category='paragraph' style='font-size:20px'>L</p>\n<br><p id='114' data-category='paragraph' style='font-size:18px'>with:</p>\n<br><p id='115' data-category='paragraph' style='font-size:18px'>h</p>\n<br><p id='116' data-category='paragraph' style='font-size:18px'>Actual length of edge AB.</p>\n<p id='117' data-category='paragraph' style='font-size:14px'>A</p>\n<br><p id='118' data-category='paragraph' style='font-size:18px'>Target size at node A (expected edge length at A).</p>\n<br><p id='119' data-category='paragraph' style='font-size:18px'>h B Target size at node B (expected edge length at B).</p>\n<p id='120' data-category='paragraph' style='font-size:16px'>Let's introduce also at this point the h-shock measure of an edge:</p>\n<p id='121' data-category='equation'>$$h s^{A B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{B}^{A B}}}-1$$</p>\n<p id='122' data-category='paragraph' style='font-size:16px'>These two measures are dimensionless and positive.</p>\n<p id='123' data-category='paragraph' style='font-size:18px'>When hA = hB the h-shock is null and the length quality simply writes QAB</p>\n<br><p id='124' data-category='paragraph' style='font-size:14px'>AB</p>\n<br><p id='125' data-category='paragraph' style='font-size:20px'>L</p>\n<br><p id='126' data-category='paragraph' style='font-size:22px'>hA</p>\n<br><p id='127' data-category='paragraph' style='font-size:18px'>When QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB.</p>\n<p id='128' data-category='paragraph' style='font-size:18px'>To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size<br>quality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure<br>smooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this<br>makes the job of the optimizer difficult and heuristics must be used.</p>\n<p id='129' data-category='paragraph' style='font-size:18px'>The histogram of the size qualities can be computed either inside the mesher by raising the flag settings .<br>compute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :<br>: edge_qualities.</p>\n<p id='130' data-category='paragraph' style='font-size:14px'>11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options.</p>\n<table id='131' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>10 tutorials</td></tr></tbody></table>\n<p id='132' data-category='paragraph' style='font-size:20px'>On the square example, the size qualities are well centered on the value 1 with a small variance:</p>\n<figure id='133'><img style='font-size:14px' alt=\"* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙\" data-coord=\"top-left:(100,176); bottom-right:(1142,693)\" /><figcaption id='134' style='font-size:16px'>Figure 3 - Histogram of the size-qualities of all the edges in the square example.</figcaption></figure>\n\n<table id='135' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials</td></tr></tbody></table>\n<p id='136' data-category='paragraph' style='font-size:22px'>To mesh with quadrangles all is needed is to change the class of the mesher:</p>\n<p id='137' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"<br>#include <iostream></p>\n<p id='138' data-category='paragraph' style='font-size:18px'>11 Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }</p>\n<p id='139' data-category='paragraph' style='font-size:18px'>int main()</p>\n<br><p id='140' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='141' data-category='paragraph' style='font-size:14px'>const</p>\n<br><p id='142' data-category='paragraph' style='font-size:16px'>const</p>\n<br><p id='143' data-category='paragraph' style='font-size:14px'>const</p>\n<br><table id='144' style='font-size:18px'><thead></thead><tbody><tr><td>double</td><td>L(10.);</td></tr><tr><td>unsi gned</td><td>N(10) ;</td></tr><tr><td>Doub leVec2</td><td>PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; ,</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>\n<p id='145' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>quadmesh_iso : :registration(\"Licensed to SMART Inc .<br>,</p>\n<p id='146' data-category='paragraph' style='font-size:16px'>11 VERTICES AND LINE MESHES.<br>pos . push_back (PO) ;<br>pos . push_back (P1) ;<br>pos · push_back(P2) ;<br>pos . push_back (P3) ;<br>meshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;<br>meshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;<br>meshtools1d: : indices_ to_connectE2(indices, connectB) ;</p>\n<table id='147' style='font-size:18px'><thead></thead><tbody><tr><td>11 THE 2D MESH.</td><td></td></tr><tr><td>quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ;</td><td>the_mesher; data (pos, connectB) ;</td></tr></tbody></table>\n<p id='148' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;</p>\n<br><p id='149' data-category='paragraph' style='font-size:18px'>return 0;<br>11 main</p>\n<br><p id='150' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='151' data-category='paragraph' style='font-size:22px'>In this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12.</p>\n<p id='152' data-category='paragraph' style='font-size:16px'>12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4.</p>\n<table id='153' style='font-size:20px'><thead></thead><tbody><tr><td>QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials</td></tr></tbody></table>\n<caption id='154' style='font-size:14px'>Figure 4 - Square meshed with quads.</caption>\n<p id='155' data-category='paragraph' style='font-size:22px'>For a plane quadrangle, we use the following measure of the shape quality:</p>\n<table id='156' style='font-size:18px'><thead></thead><tbody><tr><td>S</td><td>S min</td><td>Minimum area of the four triangles.</td></tr><tr><td>Qs = 8V2 min</td><td>with: L</td><td>Max length of the four sides and the two diagonals.</td></tr><tr><td>L P max</td><td>max P</td><td>Perimeter of the quad.</td></tr></tbody></table>\n<p id='157' data-category='paragraph' style='font-size:18px'>This measure gives the maximal value 1 only for a square.</p>\n<p id='158' data-category='paragraph' style='font-size:20px'>The size quality is given by the same measure as for the triangles (because it is based on edges only).</p>\n<table id='159' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials</td></tr></tbody></table>\n<h1 id='160' style='font-size:22px'>2. Square with an internal line</h1>\n<p id='161' data-category='paragraph' style='font-size:20px'>Starting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:</p>\n<p id='162' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"</p>\n<p id='163' data-category='paragraph' style='font-size:16px'>int main()</p>\n\n<br><table id='165' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.), R(3.) ;</td></tr><tr><td>const Doubtevec2</td><td>N1(10) , N2(20) ;</td></tr><tr><td>const Doub</td><td>PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ;</td></tr><tr><td>const DoubleVec2</td><td>P4(L/2 + R, L/2);</td></tr><tr><td>DoubleMat</td><td>pos ;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody><br><caption id='164' style='font-size:14px'>{</caption></table>\n<p id='166' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>triamesh_iso: : registration(\"Licensed to SMART Inc .<br>,</p>\n<p id='167' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos . push_back (PO) ;<br>pos · push_back (P1) ;<br>pos . push_back(P2) ;<br>pos · push_back (P3) ;<br>pos . push_back (P4) ;<br>meshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on<br>meshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;<br>meshtools1d : : indices_ to_connectE2(indices, connectB) ;</p>\n<br><p id='168' data-category='paragraph' style='font-size:20px'>indices.clear();</p>\n<br><p id='169' data-category='paragraph' style='font-size:16px'>meshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;<br>indices.back() = indices. front();<br>meshtools1d::indices_ to_connectE2(indices, connectB) ;</p>\n<p id='170' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH.<br>triamesh_iso: :mesher the_mesher;<br>triamesh_iso: : mesher::data_type data (pos, connectB) ;<br>the_mesher. run(data) ;</p>\n<p id='171' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>\n<br><p id='172' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>\n<table id='173' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials</td></tr></tbody></table>\n<figure id='174' data-category='chart'><img data-coord=\"top-left:(114,115); bottom-right:(593,593)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>Red</td><td>Blue</td><td>Green</td><td>Yellow</td><td>Purple</td><td>Orange</td></tr></thead><tbody><tr><td>item_01</td><td>10</td><td>12</td><td>8</td><td>5</td><td>4</td><td>3</td></tr></tbody></figure></table>\n<br><figure id='175'><img alt=\"\" data-coord=\"top-left:(646,115); bottom-right:(1124,592)\" /><figcaption id='176' style='font-size:16px'>Figure 5 - Square with internal line (T3 and all-Q4).</figcaption></figure>\n\n<p id='177' data-category='paragraph' style='font-size:18px'>The mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation<br>is defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �.</p>\n<p id='178' data-category='paragraph' style='font-size:18px'>The circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point<br>#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to<br>replace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only<br>coincident17:</p>\n<p id='179' data-category='paragraph' style='font-size:14px'>indices. back() = indices. front() ;</p>\n<p id='180' data-category='paragraph' style='font-size:18px'>As for the external contour, these indices are converted into edges with the indices_ to_connectE2<br>function and appended to the connectB matrix.</p>\n<p id='181' data-category='paragraph' style='font-size:20px'>Again, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,<br>if we accept some triangles we can get a better mesh.</p>\n<p id='182' data-category='footnote' style='font-size:14px'>13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.<br>14 Note that the coordinates at column 24 in the pos matrix will remain unused.</p>\n<table id='183' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials</td></tr></tbody></table>\n<p id='184' data-category='paragraph' style='font-size:22px'>Here with CM2 QuadMesh� Iso in quad-dominant mode:</p>\n<p id='185' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"</p>\n<br><p id='186' data-category='paragraph' style='font-size:16px'>int main()</p>\n<br><p id='187' data-category='paragraph' style='font-size:16px'>{</p>\n<br><table id='188' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(10) , R(3.) ·</td></tr><tr><td>const unsigned</td><td>N1(10), N2(20);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>const DoubleVec2</td><td>0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R;</td></tr><tr><td>const DoubleVec2</td><td>L/2);</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>\n<p id='189' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>quadmesh_iso: : registration(\"Licensed to SMART Inc .<br>,</p>\n<p id='190' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos. push_back (PO) ;<br>pos . push_back (P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;<br>pos . push_back (P4) ;<br>meshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;<br>meshtools1d: :indices_to_connectE2(indices, connectB) ;<br>indices.clear() ;<br>meshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;<br>indices. back() = indices. front() ;<br>meshtools1d: :indices_to_connectE2 (indices, connectB) ;</p>\n<p id='191' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.</p>\n<br><p id='192' data-category='paragraph' style='font-size:16px'>quadmesh_iso: :mesher the_mesher;<br>quadmesh_iso: :mesher: :data_type data(pos, connectB) ;<br>the_mesher.settings.all_quad_flag = false;<br>the_mesher run(data) ;</p>\n<p id='193' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;</p>\n<br><p id='194' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>\n<figure id='195' data-category='chart'><img data-coord=\"top-left:(379,1005); bottom-right:(860,1482)\" /><figcaption><p>Chart Type: pie</p></figcaption><table><thead><tr><td></td><td>Purple</td><td>Orange</td><td>Red</td><td>Blue</td><td>Green</td></tr></thead><tbody><tr><td>item_01</td><td>20%</td><td>20%</td><td>20%</td><td>20%</td><td>20%</td></tr></tbody></figure></table>\n<caption id='196' style='font-size:16px'>Figure 6 - Square with internal line (quad-dominant mode).</caption>\n<table id='197' style='font-size:20px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials</td></tr></tbody></table>\n<h1 id='198' style='font-size:22px'>3. Square with internal hole</h1>\n<p id='199' data-category='paragraph' style='font-size:18px'>A hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that<br>this implies that all edges of the external contour should be oriented in a uniform way (either clockwise or<br>counter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert<br>the orientation of the internal edges and thus to remove the disk from the domain:</p>\n<p id='200' data-category='paragraph' style='font-size:14px'>meshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;</p>\n<p id='201' data-category='paragraph' style='font-size:20px'>And the resulting meshes:</p>\n<figure id='202'><img alt=\"\" data-coord=\"top-left:(97,481); bottom-right:(572,954)\" /></figure>\n<br><figure id='203'><img alt=\"\" data-coord=\"top-left:(628,480); bottom-right:(1107,952)\" /><figcaption id='204' style='font-size:14px'>Figure 7 - Square with a circular hole (T3 and all-Q4).</figcaption></figure>\n\n<p id='205' data-category='paragraph' style='font-size:14px'>15 Without any closed internal hard line, the orientation of the external contour is irrelevant.</p>\n<table id='206' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials</td></tr></tbody></table>\n<p id='207' data-category='paragraph' style='font-size:20px'>One can nest alternatively positive and negative rotations:</p>\n<figure id='208'><img alt=\"\" data-coord=\"top-left:(111,174); bottom-right:(591,653)\" /></figure>\n<br><figure id='209'><img alt=\"\" data-coord=\"top-left:(650,171); bottom-right:(1132,658)\" /><figcaption id='210' style='font-size:14px'>Figure 8 - Concentric circles with alternate orientation (T3 and all-Q4).</figcaption></figure>\n\n<table id='211' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials</td></tr></tbody></table>\n<h1 id='212' style='font-size:22px'>4. Quadratic elements & high-order nodes</h1>\n<p id='213' data-category='paragraph' style='font-size:20px'>Let us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we<br>would like also the edges along the circular hole to be curved.</p>\n<p id='214' data-category='paragraph' style='font-size:16px'>For that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :<br>: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic.</p>\n<p id='215' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>\n<br><p id='216' data-category='paragraph' style='font-size:16px'>int main()</p>\n<br><p id='217' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='218' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.), R(3.) in</td></tr><tr><td>const unsigned</td><td>N1(10); N2(20) �.),</td></tr><tr><td>const Doub [eVec2</td><td>P2(L, L) , P3(0 * , L) ; P1(L,</td></tr><tr><td>const DoubleVec2</td><td>P4(L/2 + R, L/2);</td></tr><tr><td>DoubleMat</td><td>indices;</td></tr><tr><td>UIntVec</td><td></td></tr><tr><td>UIntMat</td><td>connectB, connectE2;</td></tr></tbody></table>\n<br><p id='219' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<p id='220' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos · push_back (PO) ;<br>pos · push_back (P1) ;<br>pos · push_back (P2) ;<br>pos · push_back (P3) ;<br>meshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;<br>. push_back (P4) ;<br>meshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on<br>meshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;<br>meshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;<br>meshtools1d: : indices_ to_connectE2(indices, connectB) ;<br>meshtools1d: : convert_into_quadratic(pos, connectB);<br>indi ces. clear () ;<br>meshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;<br>indi ces. back() = indi ces. front() ;<br>meshtools1d: :indices_ to_connectE3(indices, connectB) ;<br>connectE2.copy (connectB) ;<br>meshtools1d: :convert_into_linear (connectE2) ;</p>\n<p id='221' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here.</p>\n<br><p id='222' data-category='paragraph' style='font-size:14px'>the_mesher. run (data) ;</p>\n<br><p id='223' data-category='paragraph' style='font-size:16px'>meshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;</p>\n<br><p id='224' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;</p>\n<br><p id='225' data-category='paragraph' style='font-size:14px'>return 0;<br>} 11 main</p>\n<p id='226' data-category='paragraph' style='font-size:20px'>To keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter<br>(this will create new high-order nodes, different from those in connectB):</p>\n<p id='227' data-category='paragraph' style='font-size:16px'>meshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;</p>\n<p id='228' data-category='footnote' style='font-size:14px'>16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_<br>order · Refer to the HTML reference manual for detailed information.</p>\n<table id='229' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>19</td></tr></tbody></table>\n<p id='230' data-category='paragraph' style='font-size:18px'>This would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity<br>matrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly<br>interpolated between the initial vertices, all the edges would remain straight.</p>\n<p id='231' data-category='paragraph' style='font-size:20px'>This is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity<br>matrix of the boundary edges (or some of them) is usually required later to setup boundary conditions<br>(Dirichlet, Neumann...)</p>\n<p id='232' data-category='paragraph' style='font-size:20px'>So, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-<br>node edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):</p>\n<p id='233' data-category='paragraph' style='font-size:16px'>meshtools1d : : convert_into_quadratic (pos, connectB) ;</p>\n<p id='234' data-category='paragraph' style='font-size:18px'>The connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are<br>unchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17).</p>\n<p id='235' data-category='paragraph' style='font-size:16px'>0</p>\n<br><p id='236' data-category='paragraph' style='font-size:16px'>linear nodes</p>\n<br><p id='237' data-category='paragraph' style='font-size:14px'>1</p>\n<br><table id='238' style='font-size:16px'><thead><tr><td></td><td>1</td><td>2 3</td><td>4</td><td>6</td><td>8</td><td>10</td></tr></thead><tbody><tr><td></td><td>2</td><td>3</td><td>4</td><td>5 7</td><td>9</td><td>11</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16 17</td><td>18</td><td>19</td></tr></tbody></table>\n<caption id='239' style='font-size:16px'>Figure 9 - Example of connectivity matrix for quadratic edges and view to linear edges.</caption>\n<p id='240' data-category='paragraph' style='font-size:20px'>For the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence<br>of node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).<br>This is possible because we have generated along the circle twice as much nodes as in the previous example<br>(extrude_rotate with 2 N2).</p>\n<p id='241' data-category='paragraph' style='font-size:22px'>Now we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along<br>the circle.</p>\n<p id='242' data-category='paragraph' style='font-size:20px'>However, the mesh generators accept only linear edges upon entry and give only linear face elements upon<br>exit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called<br>connectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear<br>edges with convert_ into_ linear.</p>\n<p id='243' data-category='paragraph' style='font-size:20px'>After the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes<br>along the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity<br>matrix connectB created before:</p>\n<p id='244' data-category='footnote' style='font-size:14px'>meshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;</p>\n<p id='245' data-category='paragraph' style='font-size:20px'>This forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match.</p>\n<p id='246' data-category='paragraph' style='font-size:16px'>17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them.</p>\n<table id='247' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>20 tutorials</td></tr></tbody></table>\n<h1 id='248' style='font-size:22px'>5. Square with grading mesh size</h1>\n<p id='249' data-category='paragraph' style='font-size:20px'>There are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along<br>the boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates<br>these values inside the domain and generates elements accordingly.</p>\n<p id='250' data-category='paragraph' style='font-size:20px'>To illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of<br>the contour we specify different mesh sizes on each four vertices:</p>\n<p id='251' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>\n<br><p id='252' data-category='paragraph' style='font-size:16px'>int main()</p>\n<br><p id='253' data-category='paragraph' style='font-size:14px'>{</p>\n<br><table id='254' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(10.);</td></tr><tr><td>const unsi gLevec2</td><td>N(10).3,</td></tr><tr><td>const Doub</td><td>P1(L, 0.) , P2(L, L), P3(0. , L) ;</td></tr><tr><td>DoubleMat</td><td>indices</td></tr><tr><td>UIntVec</td><td>, hard_nodes (5) ;</td></tr><tr><td>DoubleVec</td><td>sizes(5);</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>\n<p id='255' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<br><p id='256' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.</p>\n<br><p id='257' data-category='paragraph' style='font-size:14px'>pos · push_back (PO) ;<br>pos · push_back (P1) ;<br>pos . push_back (P2) ;<br>pos · push_back(P3) ;<br>hard_nodes [0] = 0; sizes [0] = 0. 1*L/N;<br>hard_nodes [1] 1; sizes [1] = 2. 0*L/N;<br>hard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;<br>hard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;<br>hard_nodes [4] = 0; sizes [4] = 0. 1*L/N;<br>meshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>\n<p id='258' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_iso: : mesher: :data_type data (pos, connectB) ;<br>the_mesher . run(data) ;</p>\n<p id='259' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>\n<br><p id='260' data-category='paragraph' style='font-size:14px'>return 0;<br>11 main</p>\n<br><p id='261' data-category='paragraph' style='font-size:14px'>}</p>\n<p id='262' data-category='paragraph' style='font-size:18px'>This variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal<br>line) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best<br>the target values on the four corners.</p>\n<p id='263' data-category='paragraph' style='font-size:20px'>These target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used<br>to compute the 2-D size map.</p>\n<p id='264' data-category='paragraph' style='font-size:14px'>18 By averaging the lengths of the adjacent edges to each hard node.</p>\n<table id='265' style='font-size:18px'><thead></thead><tbody><tr><td>TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 & CM2 - 21 tutorials</td></tr></tbody></table>\n<figure id='266'><img alt=\"\" data-coord=\"top-left:(114,117); bottom-right:(593,591)\" /><figcaption id='268' style='font-size:14px'>Figure 10 - Meshes with grading size (T3 and all-Q4).</figcaption></figure>\n<br><figure id='267'><img alt=\"\" data-coord=\"top-left:(648,116); bottom-right:(1123,590)\" /><figcaption id='268' style='font-size:14px'>Figure 10 - Meshes with grading size (T3 and all-Q4).</figcaption></figure>\n\n<p id='269' data-category='paragraph' style='font-size:18px'>The second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some<br>hard nodes. This is explained in the next section.</p>\n<table id='270' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials</td></tr></tbody></table>\n<h1 id='271' style='font-size:20px'>6. Square with an internal hard node</h1>\n<p id='272' data-category='paragraph' style='font-size:18px'>So far, we have seen only three fields of the structure used to exchange data with the mesher:</p>\n<p id='273' data-category='list' style='font-size:18px'>· The pos matrix for the coordinates of the points.<br>· The connectB matrix for the connectivity of the hard edges.<br>· The connectM matrix for the connectivity of the 2-D mesh.</p>\n<p id='274' data-category='paragraph' style='font-size:18px'>In this example we add an isolated hard node at the center of the square and specify a target size on it. This will<br>be done using the two new fields isolated_nodes and metrics:</p>\n<figure id='275'><img style='font-size:14px' alt=\"#include 'stdafx.h'\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration('Licensed to SMART Inc. ' 'F53EA108BCWX') ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output('out.mesh' , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\" data-coord=\"top-left:(100,405); bottom-right:(1144,1135)\" /></figure>\n<p id='276' data-category='paragraph' style='font-size:18px'>We have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is<br>pushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be<br>honored in the final mesh.</p>\n<p id='277' data-category='paragraph' style='font-size:16px'>The vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or<br>not present- a default value will be used instead19.</p>\n<p id='278' data-category='paragraph' style='font-size:18px'>In our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10<br>times finer mesh around it.</p>\n<p id='279' data-category='paragraph' style='font-size:14px'>19 For an isolated node, the default computed size is based on the size value of the nearest nodes.</p>\n<table id='280' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>23 tutorials</td></tr></tbody></table>\n<figure id='281'><img alt=\"\" data-coord=\"top-left:(116,117); bottom-right:(593,592)\" /><figcaption id='283' style='font-size:14px'>Figure 11 - Mesh concentration near a hard node (T3 and all-Q4).</figcaption></figure>\n<br><figure id='282'><img alt=\"\" data-coord=\"top-left:(649,116); bottom-right:(1123,590)\" /></figure>\n\n<table id='284' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials</td></tr></tbody></table>\n<h1 id='285' style='font-size:22px'>7. Multiple meshes</h1>\n\n<figure id='287'><img alt=\"\" data-coord=\"top-left:(117,335); bottom-right:(595,810)\" /><figcaption id='286' style='font-size:20px'>The matrix connectB can contain internal lines. It can also contain several external disconnected contours (to<br>mesh several disconnected domains simultaneously). Some care must be taken however in the orientation of<br>these contours. For multiple domains, the edges of all external contours must be oriented the same way, for<br>instance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect<br>each other.</figcaption></figure>\n<br><figure id='288'><img alt=\"\" data-coord=\"top-left:(651,337); bottom-right:(1121,807)\" /></figure>\n<p id='289' data-category='paragraph' style='font-size:16px'>Figure 12 - Multiple meshes (T3 and all-Q4).<br>The four sub-domains are meshed simultaneously.</p>\n<p id='290' data-category='paragraph' style='font-size:20px'>In this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:</p>\n<figure id='291'><img style='font-size:14px' alt=\"#include 'stdafx.h'\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm('cards.dat') ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration('Licensed to SMART Inc. ' 'F53EA108BCWX') ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( 'out.mesh' , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main\" data-coord=\"top-left:(100,993); bottom-right:(1139,1389)\" /></figure>\n<p id='292' data-category='paragraph' style='font-size:14px'>20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines.</p>\n<table id='293' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>& 25 tutorials</td></tr></tbody></table>\n<p id='294' data-category='paragraph' style='font-size:20px'>The input boundary meshes are read from an ASCII file with cm2 : : matio: :read21</p>\n<p id='295' data-category='paragraph' style='font-size:20px'>The format for the matrices is:</p>\n<table id='296' style='font-size:16px'><thead></thead><tbody><tr><td>n X m</td><td>[ <table><thead></thead><tbody><tr><td>do,o</td><td>do,1</td><td>do,2</td><td>· · ·</td><td>do,m-1</td></tr><tr><td>d1,0</td><td>d1,1</td><td>d1,2</td><td>· · ·</td><td>d1,m-1</td></tr></tbody></table></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>dn-1, 0</td><td></td><td>dn-1,1</td><td>dn-1,2 ·</td><td>· ·</td><td>dn-1,m-1</td><td>]</td></tr></tbody></table>\n<p id='297' data-category='paragraph' style='font-size:22px'>The format for each component of the matrix is free.</p>\n<p id='298' data-category='paragraph' style='font-size:18px'>For instance a 2 X 4 Doub leMat can be stored as:</p>\n<p id='299' data-category='paragraph' style='font-size:16px'>2 X 4 [<br>0 0.5 1 2.0<br>0 1 1 2.E-1]</p>\n<h1 id='300' style='font-size:20px'>Notes:</h1>\n<p id='301' data-category='list' style='font-size:20px'>· We can see in this example that the meshes may not always be symmetric even with a symmetric contour.<br>· We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-<br>domain to be meshed in a structured manner.</p>\n<p id='302' data-category='paragraph' style='font-size:14px'>21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.<br>This can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files.</p>\n<table id='303' style='font-size:20px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>26 tutorials</td></tr></tbody></table>\n<p id='304' data-category='paragraph' style='font-size:22px'>As an exercise we can get the same result by making four successive meshes and concatenating the results:</p>\n<p id='305' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"<br>#include <fstream></p>\n<p id='306' data-category='paragraph' style='font-size:18px'>int main()</p>\n<br><p id='307' data-category='paragraph' style='font-size:18px'>{</p>\n<br><table id='308' style='font-size:18px'><thead></thead><tbody><tr><td>std: :ifstream</td><td>istrm</td></tr><tr><td>UIntMat</td><td>connectM;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr></tbody></table>\n<p id='309' data-category='paragraph' style='font-size:14px'>\" \"F53EA108BCWX\") ;<br>triamesh_iso : : registration(\"Licensed to SMART Inc . ,</p>\n<p id='310' data-category='paragraph' style='font-size:16px'>triamesh_ iso : : mesher the_mesher;<br>triamesh_iso : : mesher: :data_type data;</p>\n<p id='311' data-category='paragraph' style='font-size:16px'>istrm. open(\"heart.dat\") ;<br>matio : : read (istrm, data · pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run (data) ;<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>\n<p id='312' data-category='paragraph' style='font-size:16px'>istrm. open(\"spade.dat\") ;<br>matio: : read(istrm, data . pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher ・ run (data) ;<br>matscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>\n<p id='313' data-category='paragraph' style='font-size:16px'>istrm. open(\"diamond. dat\") ;<br>matio : : read (istrm, data. pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run(data) ;<br>matscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>\n<p id='314' data-category='paragraph' style='font-size:16px'>istrm. open(\"club. dat\") ;<br>matio: : read (istrm, data. pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run (data) ;<br>matscal: : add (pos. cols () , data.connectM) ; / / Shift indices.<br>pos. push_back(data.pos) ;<br>connectM.push_back(data.connectM) ;</p>\n<p id='315' data-category='paragraph' style='font-size:16px'>meshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;</p>\n<br><footer id='316' style='font-size:18px'>return 0;<br>} 11 main</footer>\n<table id='317' style='font-size:20px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials</td></tr></tbody></table>\n<h1 id='318' style='font-size:22px'>8. Shared boundaries</h1>\n<p id='319' data-category='paragraph' style='font-size:16px'>Edges can be shared between some contours and lines. In this case some edges are defined several times<br>(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more<br>convenient for the user to generate the 1-D meshes of the contours independently from each other. That<br>usually implies duplicated nodes on the shared contours.</p>\n<p id='320' data-category='paragraph' style='font-size:18px'>The following example deals with such a case.</p>\n<p id='321' data-category='paragraph' style='font-size:18px'>Consider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared<br>between sub-domains but with different orientation. We also want to mesh the contours of the sub-domains<br>independently from each other but without any duplicated nodes.</p>\n<figure id='322' data-category='chart'><img data-coord=\"top-left:(359,446); bottom-right:(868,863)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>P0</td><td>P</td><td>P3</td><td>P4</td><td>P5</td><td>P6</td></tr></thead><tbody><tr><td>item_01</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></figure></table>\n<caption id='323' style='font-size:14px'>Figure 13 - Domain composed of three attached sub-domains.</caption>\n<p id='324' data-category='paragraph' style='font-size:18px'>The shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict<br>mode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes<br>can be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,<br>the mesher may not be able to tell the sign of the inner square, and that can lead to a hole.</p>\n<p id='325' data-category='paragraph' style='font-size:20px'>The solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:</p>\n<table id='326' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials</td></tr></tbody></table>\n<h1 id='327' style='font-size:18px'>#include \"stdafx.h\"</h1>\n<p id='328' data-category='paragraph' style='font-size:18px'>static void mesh_segment</p>\n<br><p id='329' data-category='paragraph' style='font-size:20px'>(DoubleMat& pos, UIntMat& connectB,<br>unsigned start_index, unsigned stop_index, unsigned num_edges)</p>\n<br><p id='330' data-category='paragraph' style='font-size:16px'>{</p>\n<br><p id='331' data-category='paragraph' style='font-size:18px'>UIntVec indices;<br>meshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>\n<br><p id='332' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='333' data-category='paragraph' style='font-size:18px'>int main()</p>\n<br><p id='334' data-category='paragraph' style='font-size:18px'>{</p>\n<br><table id='335' style='font-size:16px'><thead></thead><tbody><tr><td>const DoubleVec2</td><td>PO (0.,</td><td>0.),</td><td>P1(10. , 0.),</td><td>P2(10. , 2.) ,</td><td></td><td></td><td>P3(8. , 2.) ;</td></tr><tr><td>const DoubleVec2</td><td></td><td>P4 (2. , 2.),</td><td></td><td>P5(0. , 2.) ,</td><td>P6(10. , 10. ) ,</td><td>P7(0. ,</td><td>10.) ;</td></tr><tr><td>const DoubleVec2</td><td></td><td>P8 (2., 8.)</td><td>,</td><td>P9 (8. , 8.) ;</td><td></td><td></td><td></td></tr><tr><td>const unsi gned</td><td></td><td>N(4) ;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DoubleMat</td><td></td><td>pos;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>UIntMat</td><td></td><td>connectB;</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>\n<p id='336' data-category='paragraph' style='font-size:16px'>11 UNLOCK THE DLL.<br>triamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<br><p id='337' data-category='paragraph' style='font-size:18px'>11 VERTICES POINTS.</p>\n<br><p id='338' data-category='paragraph' style='font-size:14px'>pos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;<br>pos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;<br>pos . push_back(P8) ; pos · push_back(P9) ;</p>\n<p id='339' data-category='paragraph' style='font-size:16px'>11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·</p>\n<br><p id='340' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 日, 1, N) ;</p>\n<br><p id='341' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 1, 2, N) ;</p>\n<br><p id='342' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 2, 3, N) ;</p>\n<br><p id='343' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 3, 4, N) ;</p>\n<br><p id='344' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 4, 5, N) ;</p>\n<br><p id='345' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 5, 日, N) ;</p>\n<p id='346' data-category='paragraph' style='font-size:16px'>11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·</p>\n<br><p id='347' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 2, 6, N) ;</p>\n<br><p id='348' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 6, 7, N) ;</p>\n<br><p id='349' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 7, 5, N) ;</p>\n<br><p id='350' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 5, 4, N) ·</p>\n<br><p id='351' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 4, 8, N) ·</p>\n<br><p id='352' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 8, 9, N) ;</p>\n<br><p id='353' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 9, 3, N) ;</p>\n<br><p id='354' data-category='paragraph' style='font-size:18px'>mesh_segment(pos, connectB, 3, 2, N) ;</p>\n<p id='355' data-category='paragraph' style='font-size:18px'>11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·<br>mesh_segment (pos, connectB, 3, 9, N) ;<br>mesh_segment(pos, connectB, 9, 8, N) ;<br>mesh_segment(pos, connectB, 8, 4, N) ;<br>mesh_segment(pos, connectB, 4, 3, N) ;</p>\n<p id='356' data-category='paragraph' style='font-size:18px'>11 MERGE TOGETHER DUPLICATED NODES.<br>meshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;</p>\n<br><p id='357' data-category='paragraph' style='font-size:18px'>11 THE 2D MESH.</p>\n<br><p id='358' data-category='paragraph' style='font-size:16px'>triamesh_iso: : mesher the_mesher;<br>triamesh_iso : : mesher: :data_ type data (pos, connectB) ;<br>the_mesher · run(data) ;</p>\n<p id='359' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>\n<br><p id='360' data-category='paragraph' style='font-size:18px'>return 0;<br>11 main</p>\n<br><p id='361' data-category='paragraph' style='font-size:18px'>}</p>\n<table id='362' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials</td></tr></tbody></table>\n<p id='363' data-category='paragraph' style='font-size:20px'>Note that this solution works because the shared edges are discretized similarly and the nodes are (almost)<br>coincident.</p>\n<figure id='364'><img alt=\"\" data-coord=\"top-left:(114,198); bottom-right:(593,674)\" /></figure>\n<br><figure id='365' data-category='chart'><img data-coord=\"top-left:(648,199); bottom-right:(1124,673)\" /><figcaption><p>Chart Type: bar</p></figcaption><table><thead><tr><td></td><td>Red</td><td>Blue</td><td>Green</td><td>Purple</td><td>Cyan</td></tr></thead><tbody><tr><td>item_01</td><td>10</td><td>10</td><td>10</td><td>10</td><td>20</td></tr></tbody></figure></table>\n<caption id='366' style='font-size:14px'>Figure 14 - Example with shared boundaries (T3 and all-Q4).</caption>\n<p id='367' data-category='paragraph' style='font-size:20px'>Note that the contour of the inner square is oriented completely both ways (positive and negative). In such a<br>case, the mesher favors the positive orientation and keeps the inner sub-domain.</p>\n<p id='368' data-category='paragraph' style='font-size:16px'>A similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers<br>the inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external<br>domain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole).</p>\n<figure id='369'><img alt=\"\" data-coord=\"top-left:(450,964); bottom-right:(788,1267)\" /><figcaption id='370' style='font-size:14px'>Figure 15 - Example of ambiguous orientation of an inner contour.</figcaption></figure>\n\n<table id='371' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials</td></tr></tbody></table>\n<p id='372' data-category='paragraph' style='font-size:18px'>Here is another example where a hole is adjacent to the external contour. In this case, the most external<br>domain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole).</p>\n<figure id='373'><img alt=\"\" data-coord=\"top-left:(425,191); bottom-right:(815,559)\" /><br><figcaption id='374' style='font-size:14px'>Figure 16 - Hole adjacent to the external contour.</figcaption></figure>\n\n<figure id='375'><img alt=\"\" data-coord=\"top-left:(113,701); bottom-right:(595,1183)\" /><figcaption id='377' style='font-size:14px'>Figure 17 - Example of ambiguous orientation of an inner contour.</figcaption></figure>\n<br><figure id='376' data-category='chart'><img data-coord=\"top-left:(647,704); bottom-right:(1124,1180)\" /><figcaption><p>Chart Type: bar</p></figcaption><table><thead><tr><td></td><td>Dark Gray</td><td>Light Gray</td></tr></thead><tbody><tr><td>item_01</td><td>50</td><td>50</td></tr></tbody></figure></table>\n\n<table id='378' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials</td></tr></tbody></table>\n<h1 id='379' style='font-size:20px'>9. Background mesh</h1>\n<p id='380' data-category='paragraph' style='font-size:16px'>Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially<br>when automatic mesh adaptivity is involved. The background mesh option is the solution in this case.</p>\n<p id='381' data-category='paragraph' style='font-size:18px'>The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside<br>the domain. It's represented by the connectivity matrix background_mesh in the data of the mesher.</p>\n<p id='382' data-category='paragraph' style='font-size:16px'>As always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or<br>vectors (such as connectM or connectB).</p>\n<p id='383' data-category='paragraph' style='font-size:16px'>The nodes of the background mesh can share nodes with connectB or can all be different. They must all have<br>a valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside<br>the background mesh.</p>\n<p id='384' data-category='paragraph' style='font-size:18px'>In the following example, a regular structured background mesh is used to support a size map with a sinusoidal<br>variation in the two directions. The domain to be meshed is a simple square regularly discretized along its<br>boundaries22.</p>\n<p id='385' data-category='paragraph' style='font-size:14px'>22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities.</p>\n<table id='386' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>& 32 tutorials</td></tr></tbody></table>\n<h1 id='387' style='font-size:18px'>#include \"stdafx.h\"</h1>\n<br><p id='388' data-category='paragraph' style='font-size:20px'>int main()</p>\n<br><p id='389' data-category='paragraph' style='font-size:16px'>{</p>\n<br><table id='390' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(4.), h0 (0. 25) , h1 (0. 05) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectE2, connectT3, BGM;</td></tr><tr><td>DoubleVec</td><td>sizes;</td></tr><tr><td>unsigned</td><td>n;</td></tr><tr><td>double</td><td>W, h;</td></tr></tbody></table>\n<p id='391' data-category='paragraph' style='font-size:16px'>11 UNLOCK THE DLL.<br>triamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<p id='392' data-category='paragraph' style='font-size:18px'>11 VERTICES AND LINE MESHES.<br>pos · push_back (DoubleVec2(-L/2, -L/2)) ;<br>pos · push_back(DoubleVec2 (+L/2, -L/2)) ;<br>pos · push_back(DoubleVec2 (+L/2, +L/2)) ;<br>pos · push_back(DoubleVec2 (-L/2, +L/2))<br>meshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;<br>indices. pop_ back() ;<br>meshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;<br>indices. pop_ back() ;<br>meshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;<br>indices. pop_back() ;<br>meshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;<br>meshtools1d: : indices_to_connectE2(indices, connectE2) ;</p>\n<br><p id='393' data-category='paragraph' style='font-size:18px'>11 THE BACKGROUND MESH.</p>\n<br><p id='394' data-category='paragraph' style='font-size:14px'>n = unsigned(L/h1) ;</p>\n<br><p id='395' data-category='paragraph' style='font-size:20px'>indices.clear () ;<br>meshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;<br>indices.pop_ back() ;<br>meshtools1d: :mesh_ straight(pos, 1, 2, n, indices);<br>indices.pop_back() ;<br>meshtools1d: :mesh_ straight(pos, 2, 3, n, indices);<br>indices.pop_back() ;<br>meshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;<br>meshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;</p>\n<p id='396' data-category='paragraph' style='font-size:18px'>11 THE METRICS ON THE BACKGROUND MESH.<br>indices.clear();<br>meshtools: :unique_ indices(indices, BGM) ;<br>sizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.<br>for (size_t i = 0; i く indices.size(); ++i)</p>\n<br><p id='397' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='398' data-category='paragraph' style='font-size:18px'>n = indices[i];<br>n)));<br>W = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;<br>h = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +<br>sizes[n] = h;</p>\n<br><p id='399' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='400' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;<br>data.background_mesh = BGM;<br>data. metrics = sizes;<br>the_mesher · run(data) ;</p>\n<p id='401' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>\n<br><p id='402' data-category='paragraph' style='font-size:18px'>return 0;<br>} 11 main</p>\n<table id='403' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials</td></tr></tbody></table>\n<figure id='404'><img alt=\"\" data-coord=\"top-left:(117,118); bottom-right:(593,592)\" /><figcaption id='406' style='font-size:14px'>Figure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).</figcaption></figure>\n<br><figure id='405'><img alt=\"\" data-coord=\"top-left:(650,117); bottom-right:(1124,591)\" /><figcaption id='406' style='font-size:14px'>Figure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).</figcaption></figure>\n\n<p id='407' data-category='paragraph' style='font-size:20px'>The background mesh is the same structured triangle mesh in both cases (here, covering all the domain):</p>\n<figure id='408'><img alt=\"\" data-coord=\"top-left:(381,756); bottom-right:(860,1233)\" /><figcaption id='409' style='font-size:16px'>Figure 19 - The background mesh used in the previous examples.</figcaption></figure>\n\n<p id='410' data-category='paragraph' style='font-size:18px'>The background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it<br>and/or be partially outside of the domain. In the areas not covered by the background mesh, the default size<br>field based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead.</p>\n<p id='411' data-category='paragraph' style='font-size:18px'>Here is an example where the domain is a disk and the background mesh is also a disk but with half the radius.<br>We have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area.</p>\n<table id='412' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials</td></tr></tbody></table>\n<figure id='413'><img alt=\"\" data-coord=\"top-left:(374,111); bottom-right:(867,598)\" /><figcaption id='414' style='font-size:16px'>Figure 20 - Background mesh covering only a fraction of the domain.</figcaption></figure>\n\n<p id='415' data-category='paragraph' style='font-size:20px'>We can also consider the case where the boundary mesh of the domain must also be governed by a<br>background mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to<br>support the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"<br>and the associated sizes. The discretization for this 1D background mesh must be fine enough to represent<br>accurately the geometry of the line.</p>\n<p id='416' data-category='paragraph' style='font-size:18px'>An overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full<br>circle with 200 nodes in indices0 starting from node #1 and centered on point CR:</p>\n<p id='417' data-category='paragraph' style='font-size:14px'>meshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;<br>indices0 . back() = indices0. front();</p>\n<p id='418' data-category='paragraph' style='font-size:18px'>Sizes are specified on the nodes of this circle and a new set of adapted nodes are generated:</p>\n<p id='419' data-category='paragraph' style='font-size:16px'>vecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.<br>meshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,<br>UINT_MAX, 0. , indices, new U, new_sizes) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectE) ;</p>\n<p id='420' data-category='paragraph' style='font-size:20px'>The parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,<br>maximum of UINT_MAX edges along the arc and no chordal control21.</p>\n<p id='421' data-category='paragraph' style='font-size:18px'>The indices vector now contains the nodes of the circle mesh adapted to the metrics.</p>\n<p id='422' data-category='paragraph' style='font-size:18px'>new_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these<br>nodes but these vectors are not used in the rest of the example.</p>\n\n<table id='424' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>35</td></tr></tbody><caption id='423' style='font-size:16px'>23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library.</caption></table>\n<figure id='425'><img alt=\"\" data-coord=\"top-left:(117,117); bottom-right:(597,590)\" /><figcaption id='427' style='font-size:16px'>Figure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).</figcaption></figure>\n<br><figure id='426'><img alt=\"\" data-coord=\"top-left:(645,109); bottom-right:(1127,593)\" /><figcaption id='427' style='font-size:16px'>Figure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).</figcaption></figure>\n\n<p id='428' data-category='paragraph' style='font-size:20px'>Note: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it<br>to a changed metrics map.</p>\n<p id='429' data-category='paragraph' style='font-size:14px'>24 See HTML reference manual for more info on these parameters.</p>\n<table id='430' style='font-size:18px'><thead></thead><tbody><tr><td>QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials</td></tr></tbody></table>\n<h1 id='431' style='font-size:18px'>#include \"stdafx.h\"</h1>\n<br><p id='432' data-category='paragraph' style='font-size:18px'>int main()</p>\n\n<br><table id='434' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>R(4.) ;</td></tr><tr><td>const double</td><td>h0(0.5) , h1(0.05) , sig(0. 40) ;</td></tr><tr><td>const DoubleVec2</td><td>CR(0 · 0.) , PO(R, 0.) ; ,</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>DoubleVec</td><td>new_U, sizes, sizes0, new_sizes;</td></tr><tr><td>UIntVec</td><td>indices0, indices;</td></tr><tr><td>UIntMat</td><td>connectE, connectM, BGM;</td></tr><tr><td>double</td><td>x, y, W, wo, w1, w2;</td></tr></tbody><br><caption id='433' style='font-size:16px'>{</caption></table>\n<p id='435' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;<br>\"<br>,</p>\n<p id='436' data-category='paragraph' style='font-size:14px'>triamesh_iso : : mesher the_mesher;</p>\n<p id='437' data-category='paragraph' style='font-size:14px'>pos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·<br>pos . push_back(P0) ; 11 Point #1 (start of the circle) ·</p>\n<p id='438' data-category='paragraph' style='font-size:16px'>11 THE 2D BACKGROUND MESH<br>n = unsigned (2. *M_PI*R / h1) ;<br>meshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;<br>indices. back() = indices · front() ; 11 Close the circle.<br>meshtools1d: : indices_ to_connectE2(indices, connectE) ;<br>triamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;<br>the_ mesher . run(BGMdata) ;<br>BGMdata.extract(pos, BGM) ;</p>\n<p id='439' data-category='paragraph' style='font-size:18px'>11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·<br>meshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;<br>indices0.back() = indices0.front();</p>\n<p id='440' data-category='paragraph' style='font-size:16px'>11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .<br>indices.clear();<br>meshtools: :unique indices(indices, BGM) ;<br>indices.push_back(indices0); 11 Also the nodes of the circle.<br>sizes. resize(pos. cols() , 0.);<br>for (size_t i = 0; i く indices.size() ; ++i)</p>\n<br><p id='441' data-category='paragraph' style='font-size:16px'>{</p>\n<br><p id='442' data-category='paragraph' style='font-size:14px'>const size_t n = indices[i] ;<br>X = pos(0, n) ;<br>y = pos(1, n) ;<br>w⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;<br>w1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;<br>w2 = : : fabs (x + R/2) ;<br>W = std : : min (wo, w1) ; sigil. Gaussian variations.<br>W = std : : min (w, w2) /<br>W = : :exp(-w*w) ;<br>sizes[n] = = h0* (1. -w) + h1*w;</p>\n<br><p id='443' data-category='paragraph' style='font-size:18px'>}</p>\n<br><p id='444' data-category='paragraph' style='font-size:20px'>11 Pick-up the sizes along the circle.<br>sizes0.clear();<br>vecvec: :push_back(sizes, indices0, sizes0) ;</p>\n<br><p id='445' data-category='paragraph' style='font-size:20px'>11 MESH THE CIRCLE ACCORDING TO THE METRICS.<br>indices.clear();<br>connectE.clear();<br>meshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,<br>UINT MAX, 0. , indices, new U, new_sizes) ;<br>meshtools1d: :indices_to_connectE2(indices, connectE) ;</p>\n<p id='446' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.<br>triamesh_ iso: : mesher : : data_ type data(pos, connectE) ;<br>data.background_mesh = BGM;<br>data.metrics = sizes;<br>the_mesher run(data) ;</p>\n<p id='447' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>\n<p id='448' data-category='paragraph' style='font-size:18px'>return 0;<br>} 11 main</p>\n<table id='449' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials</td></tr></tbody></table>\n<h1 id='450' style='font-size:22px'>10. Anisotropic meshes</h1>\n<p id='451' data-category='paragraph' style='font-size:18px'>CM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce<br>equilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific<br>directions. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic<br>unstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their<br>isotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic<br>case we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined<br>by a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array.</p>\n<figure id='452'><img style='font-size:14px' alt=\"h1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right).\" data-coord=\"top-left:(309,402); bottom-right:(911,841)\" /></figure>\n<p id='453' data-category='paragraph' style='font-size:20px'>Mj = ab b<br>c</p>\n<br><p id='454' data-category='paragraph' style='font-size:16px'>with :</p>\n<p id='455' data-category='paragraph' style='font-size:16px'>a > 0<br>ac - b2 > 0<br>i.e. the two eigen values are > 0</p>\n<br><p id='456' data-category='paragraph' style='font-size:18px'>data.metrics</p>\n<br><p id='457' data-category='paragraph' style='font-size:14px'>a</p>\n<br><p id='458' data-category='paragraph' style='font-size:14px'>·</p>\n<br><p id='459' data-category='paragraph' style='font-size:18px'>b</p>\n<br><p id='460' data-category='paragraph' style='font-size:22px'>:</p>\n<br><p id='461' data-category='paragraph' style='font-size:14px'>c</p>\n<p id='462' data-category='paragraph' style='font-size:20px'>column #j</p>\n<caption id='463' style='font-size:14px'>Figure 23 - Definition and storage of the 2-D anisotropic metrics.</caption>\n<p id='464' data-category='paragraph' style='font-size:18px'>Let (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:</p>\n<br><p id='465' data-category='paragraph' style='font-size:22px'>[vo] = [v1] = 1<br><V0,V1>=0</p>\n<table id='466' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials</td></tr></tbody></table>\n<p id='467' data-category='paragraph' style='font-size:20px'>Then the metrics Mj writes:</p>\n<p id='468' data-category='equation'>$$\\begin{array}{c c}{{M_{j}=\\mathbf{B}}}&{{\\displaystyle\\left[\\frac{1}{h_{0}^{~2}}\\right.\\quad\\qquad}}&{{\\displaystyle\\left|\\begin{array}{c}{{}}\\\\ {{}}\\\\ {{}}&{{}}\\\\ {{\\displaystyle\\qquad\\displaystyle\\frac{1}{h_{1}^{~2}}\\end{array}\\right|}}}\\end{array}\\right.\\qquad}}\\end{array}$$</p>\n<br><p id='469' data-category='paragraph' style='font-size:18px'>with :</p>\n<br><p id='470' data-category='paragraph' style='font-size:22px'>B = [vo v1]<br>stored column - wise</p>\n<p id='471' data-category='paragraph' style='font-size:18px'>The metric equivalent to an isotropic size of h writes:</p>\n<p id='472' data-category='equation'>$$M_{_{j}}=\\left[\\frac{1}{h^{2}}\\quad\\begin{array}{c c c}{{0}}\\\\ {{}}&{{}}\\\\ {{0}}&{{\\frac{1}{h^{2}}\\right]$$</p>\n<p id='473' data-category='paragraph' style='font-size:20px'>A null matrix would lead to infinite sizes in both directions (infinite circle).</p>\n<p id='474' data-category='paragraph' style='font-size:20px'>When the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic<br>default metrics we have seen before. For each hard node the default metric is based on the length of the<br>adjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for<br>instance examples 1, 2, 3 or 4 and replace:</p>\n<p id='475' data-category='paragraph' style='font-size:14px'>triamesh_ iso : : mesher the_mesher;</p>\n<h1 id='476' style='font-size:20px'>with:</h1>\n<p id='477' data-category='paragraph' style='font-size:14px'>triamesh_aniso : : mesher the_mesher;</p>\n<p id='478' data-category='paragraph' style='font-size:20px'>and you get the same meshes25.</p>\n<p id='479' data-category='paragraph' style='font-size:14px'>25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower).</p>\n<table id='480' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>39 tutorials</td></tr></tbody></table>\n<p id='481' data-category='paragraph' style='font-size:20px'>To benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.<br>positive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these<br>matrices as in the following example.</p>\n<figure id='482'><img alt=\"\" data-coord=\"top-left:(113,225); bottom-right:(595,698)\" /></figure>\n<caption id='483' style='font-size:16px'>Figure 24 - Anisotropic meshes (T3 and Q4).</caption>\n<p id='484' data-category='paragraph' style='font-size:20px'>Here a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the<br>previous section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We<br>need also specify that we want a different size along the normals than along the tangents of the boundary lines<br>(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :<br>: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and<br>generates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node<br>Ni, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the<br>horizontal direction27:</p>\n<p id='485' data-category='paragraph' style='font-size:16px'>meshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;</p>\n<p id='486' data-category='paragraph' style='font-size:14px'>26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4.</p>\n\n<table id='488' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40</td></tr></tbody><br><caption id='487' data-category='footnote' style='font-size:16px'>27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in<br>metrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi<br>is replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.<br>Note also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.<br>This property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four<br>summits of the square.</caption></table>\n<h1 id='489' style='font-size:16px'>#include \"stdafx.h\"</h1>\n<br><p id='490' data-category='paragraph' style='font-size:18px'>int main()</p>\n\n<br><table id='492' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.) ;</td></tr><tr><td>const double</td><td>hx(1.) ;</td></tr><tr><td>const double</td><td>Y size at bottom line. h0y(hx) ; </td></tr><tr><td>const double</td><td>Y size at top line. h1y(hx / 20.) ;</td></tr><tr><td>const DoubleVec2</td><td>P0(0 . 0.) ; ,</td></tr><tr><td>const DoubleVec2</td><td>P1(L, 0.) ;</td></tr><tr><td>const DoubleVec2</td><td>P2(L, L);</td></tr><tr><td>const DoubleVec2</td><td>P3(0 · , L) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connect1, connect2, connect3, connect4, connectE;</td></tr><tr><td>UIntMat</td><td>connectM;</td></tr><tr><td>DoubleMat</td><td>metrics;</td></tr></tbody><br><caption id='491' style='font-size:14px'>{</caption></table>\n<p id='493' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<p id='494' data-category='paragraph' style='font-size:14px'>11 VERTICES<br>pos . push_back (PO) ;<br>pos · push_back(P1) ;<br>pos · push_back(P2) ;<br>pos . push_back(P3) ;</p>\n<p id='495' data-category='paragraph' style='font-size:16px'>11 BOTTOM LINE<br>indices. clear () ;<br>meshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect1) ;<br>connectE.push_back (connect1) ;</p>\n<br><p id='496' data-category='paragraph' style='font-size:18px'>11 RIGHT-SIDE LINE</p>\n<br><p id='497' data-category='paragraph' style='font-size:16px'>indices.clear() ;<br>meshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect2) ;<br>connectE.push_back (connect2) ;</p>\n<p id='498' data-category='paragraph' style='font-size:16px'>11 LEFT-SIDE LINE</p>\n<br><p id='499' data-category='paragraph' style='font-size:16px'>indices.clear() ;<br>meshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect3) ;<br>connectE.push_back (connect3) ;</p>\n<p id='500' data-category='paragraph' style='font-size:16px'>11 TOP LINE<br>indices.clear() ··<br>meshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect4) ;<br>connectE.push_back(connect4) ;</p>\n<br><p id='501' data-category='paragraph' style='font-size:16px'>11 METRICS</p>\n<br><table id='502' style='font-size:18px'><thead></thead><tbody><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ;</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ;</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics);</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ;</td></tr></tbody></table>\n<br><p id='503' data-category='paragraph' style='font-size:16px'>11 2D MESH</p>\n<br><p id='504' data-category='paragraph' style='font-size:14px'>triamesh_aniso : : mesher the_mesher;<br>triamesh_aniso: : mesher: :data_type data (pos, connectE2) ;<br>data. metrics = metrics;<br>the_mesher · run(data) ;</p>\n<p id='505' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;</p>\n<br><p id='506' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>\n<p id='507' data-category='paragraph' style='font-size:22px'>As already stated, except for the metrics array, the anisotropic meshers have the very same options and<br>parameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,<br>shared boundaries, background meshes...</p>\n<p id='508' data-category='paragraph' style='font-size:20px'>The following example illustrates the internal hard line feature.<br>We have specified a normal size along the inner circle much smaller than the default tangent size (using again<br>meshtools1d : : metrics_gen_aniso2d).</p>\n<table id='509' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials</td></tr></tbody></table>\n<p id='510' data-category='paragraph' style='font-size:20px'>For the external square, nothing was specified in the metrics array and the mesher used its default isotropic<br>metrics based on the length of the adjacent edges.</p>\n<figure id='511'><img alt=\"\" data-coord=\"top-left:(115,199); bottom-right:(594,673)\" /></figure>\n<br><figure id='512'><img alt=\"\" data-coord=\"top-left:(648,198); bottom-right:(1122,673)\" /><figcaption id='513' style='font-size:14px'>Figure 25 - 2-D anisotropic meshes (T3 and all-Q4).</figcaption></figure>\n\n<p id='514' data-category='paragraph' style='font-size:16px'>The example below is mesh of Figure 21 revisited the anisotropic way.<br>Here we specify a small size in the directions normal to the three lines but a uniform size along the tangents.<br>The normal sizes follow the same kind of Gaussian variation.<br>All these metrics are specified at the nodes of the same uniform background mesh.</p>\n<figure id='515'><img alt=\"\" data-coord=\"top-left:(115,914); bottom-right:(596,1390)\" /></figure>\n<br><figure id='516'><img alt=\"\" data-coord=\"top-left:(643,907); bottom-right:(1130,1390)\" /><figcaption id='517' style='font-size:14px'>Figure 26 - 2-D anisotropic meshes (T3 and all-Q4).</figcaption></figure>\n\n<table id='518' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials</td></tr></tbody></table>\n<h1 id='519' style='font-size:22px'>11. 3-D surface meshes (aniso meshers only)</h1>\n<p id='520' data-category='paragraph' style='font-size:20px'>The four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso<br>and CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.<br>To generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a<br>template function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or<br>CM2 QuadMesh Aniso):</p>\n<p id='521' data-category='paragraph' style='font-size:14px'>template <class Surface, class AnisoMesher, class AuxMesher><br>int<br>meshtools2d : : mesh_surface_param</p>\n<br><p id='522' data-category='paragraph' style='font-size:16px'>(const Surface& S, AnisoMesher& mesher2D,</p>\n<br><p id='523' data-category='paragraph' style='font-size:14px'>typename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,<br>double max_ chordal_error, double min_h, unsi gned chordal_control_type,<br>unsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,<br>doub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,<br>unsi gned max_ bgm_remeshings = 4<br>bool recompute_Qs_flag = true, bool compute_area_flag = true) ;</p>\n<p id='524' data-category='paragraph' style='font-size:20px'>This function can be used as in the following code sample:</p>\n<table id='525' style='font-size:14px'><thead></thead><tbody><tr><td><table><thead></thead><tbody><tr><td>tri amesh_aniso: :mesher amesh_iso : :mesher</td><td>the_mesher; aux_mesher;</td></tr><tr><td>tri tri amesh_ani so: :mesher: :data_type surface_type</td><td>data (pos, connectE2) ; S(some parameters) ; 11 A parametric surface.</td></tr></tbody></table></td></tr><tr><td>meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ;</td></tr></tbody></table>\n<p id='526' data-category='paragraph' style='font-size:18px'>The class Surface for parameter S is a concept of parametric surface with members:</p>\n<p id='527' data-category='paragraph' style='font-size:14px'>int get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;<br>int get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const;<br>int get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;<br>int get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;</p>\n<p id='528' data-category='paragraph' style='font-size:18px'>The Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points<br>located on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in<br>column #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)<br>when failed.</p>\n<p id='529' data-category='paragraph' style='font-size:20px'>The Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give<br>the coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in<br>column #j of pos3D must be returned in column #j of pos2D. This function should return zero when<br>successful and a negative value (-1 for instance) when failed.</p>\n<p id='530' data-category='paragraph' style='font-size:14px'>28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear<br>search. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is<br>not called for the new nodes generated inside the surface by the mesher.</p>\n<table id='531' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>43</td></tr></tbody></table>\n<p id='532' data-category='paragraph' style='font-size:16px'>nodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices<br>of the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix<br>data3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.<br>This array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before.</p>\n<br><p id='533' data-category='paragraph' style='font-size:16px'>aP aP<br>The Surface : : get_ tangents member should compute the two tangents Bu = and Bv =<br>au av<br>on the surface at a set of points given by their reference coordinates.</p>\n<p id='534' data-category='paragraph' style='font-size:18px'>These tangents must not be normalized. They are the mere derivatives of the surface with respect to two<br>reference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T<br>(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),<br>then the next three are for the second tangent29.</p>\n<p id='535' data-category='paragraph' style='font-size:18px'>The Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given<br>by their reference coordinates (optional).</p>\n<p id='536' data-category='paragraph' style='font-size:16px'>The curvatures H are 2 X 2 symmetric matrices defined as:</p>\n<p id='537' data-category='paragraph' style='font-size:20px'>a2P<br>· Huu du2 N)<br>Dot product between the derivative of Bu (first local tangent) with respect to u,<br>and the normal N to the surface.</p>\n<p id='538' data-category='paragraph' style='font-size:18px'>O2P<br>· Huv = N<br>du av<br>Dot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv<br>(second local tangent) with respect to u, and the normal N to the surface.</p>\n<p id='539' data-category='paragraph' style='font-size:18px'>�2P<br>· Hw = N<br>av2<br>Dot product between the derivative of Bv (second local tangent) with respect to V,<br>and the normal N to the surface.</p>\n<p id='540' data-category='paragraph' style='font-size:16px'>These three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.<br>uu</p>\n<br><p id='541' data-category='paragraph' style='font-size:18px'>You can leave the implementation of this member empty (returning -1 for instance). In this case approximate<br>curvatures computed from variations of the tangents will be used instead.</p>\n<p id='542' data-category='paragraph' style='font-size:14px'>29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some<br>singularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to<br>the true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute<br>the target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and<br>replace them with a default one.</p>\n<table id='543' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials</td></tr></tbody></table>\n<p id='544' data-category='paragraph' style='font-size:18px'>The template class AnisoMesher is a concept of triangle anisometric mesher with function:</p>\n<p id='545' data-category='paragraph' style='font-size:14px'>void run (typename AnisoMesher: :data_type& data) const;</p>\n<p id='546' data-category='paragraph' style='font-size:16px'>The mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers<br>CM2 TriaMesh Aniso or CM2 QuadMesh Aniso.</p>\n<p id='547' data-category='paragraph' style='font-size:16px'>The data3D parameter is the structure gathering all the input and output data, just like for any other<br>unstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:<br>: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher<br>used. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D<br>anisotropic metrics (dimensions 6 X NODS).</p>\n<p id='548' data-category='paragraph' style='font-size:16px'>3D-anisotropic metrics are defined as below:</p>\n<p id='549' data-category='equation'>$${\\cal M}_{j}=\\left[\\frac{a}{b}\\begin{array}{c c c}{{b}}&{{d}}\\\\ {{c}}&{{c}}&{{e}}\\\\ {{d}}&{{e}}&{{f}}\\end{array}\\right]$$</p>\n<br><p id='550' data-category='paragraph' style='font-size:16px'>with:</p>\n<p id='551' data-category='paragraph' style='font-size:18px'>a > 0<br>ac - b2 > 0<br>Det (M ) >0<br>i.e. the three eigen values are > 0</p>\n<br><figure id='552'><img style='font-size:14px' alt=\"a\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j\" data-coord=\"top-left:(630,534); bottom-right:(1032,784)\" /></figure>\n<caption id='553' style='font-size:14px'>Figure 27 - Definition and storage of the 3-D anisotropic metrics.</caption>\n<p id='554' data-category='paragraph' style='font-size:16px'>Let (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:</p>\n<p id='555' data-category='equation'>$$\\begin{array}{l}{\\left\\|\\mathbf{v}_{0}\\right\\|=\\left\\|\\mathbf{v}_{1}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=1}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{2}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1},\\mathbf{v}_{2}\\right)=1}\\end{array}$$</p>\n<h1 id='556' style='font-size:20px'>Then, the metrics Mi writes:</h1>\n<p id='557' data-category='equation'>$$M_{j}=\\mathbf{B}\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h_{0}^{~2}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\frac{1}{h_{1}^{~2}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h_{2}^{~2}}}}\\end{array}\\right]$$</p>\n<br><p id='558' data-category='paragraph' style='font-size:14px'>T B</p>\n<br><p id='559' data-category='paragraph' style='font-size:16px'>with:</p>\n<br><p id='560' data-category='paragraph' style='font-size:20px'>B = [vo V1 v2]<br>stored column - wise</p>\n<table id='561' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials</td></tr></tbody></table>\n<p id='562' data-category='paragraph' style='font-size:18px'>The 3-D metric equivalent to an isotropic size of h writes:</p>\n<p id='563' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$</p>\n<p id='564' data-category='paragraph' style='font-size:18px'>A null matrix would lead to infinite sizes in the three directions (infinite sphere).</p>\n<p id='565' data-category='paragraph' style='font-size:16px'>The two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error<br>between the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the<br>HTML reference manual for more information on them.</p>\n<p id='566' data-category='paragraph' style='font-size:18px'>This first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric<br>surface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit<br>square [0 1] X [0 1].</p>\n<figure id='567'><img style='font-size:20px' alt=\"✓\n+ P(x,y,z)\nQ(u,v)\nu\" data-coord=\"top-left:(206,653); bottom-right:(1021,1013)\" /><figcaption id='568' style='font-size:14px'>Figure 28 - Mapping between the reference space and the surface.</figcaption></figure>\n\n<p id='569' data-category='paragraph' style='font-size:18px'>The source of this example is as follow:</p>\n<table id='570' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials</td></tr></tbody></table>\n<p id='571' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"</p>\n<p id='572' data-category='paragraph' style='font-size:18px'>/*The Surface class implements the functions needed by mesh_surface_param* /<br>struct surface</p>\n<br><p id='573' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='574' data-category='paragraph' style='font-size:18px'>11 Constructor (parameters to define the surface should be passed here) ·<br>surface (double Lx, double Ly, double a = 0.5)</p>\n<br><p id='575' data-category='paragraph' style='font-size:18px'>_Lx(Lx) , _Ly(Ly) , _a(a) {</p>\n<br><p id='576' data-category='paragraph' style='font-size:14px'>:</p>\n<br><p id='577' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='578' data-category='paragraph' style='font-size:18px'>11 Computes the 3D coordinates.<br>int get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const</p>\n<br><p id='579' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='580' data-category='paragraph' style='font-size:16px'>const size_t NODS(pos2D.cols()) ;<br>double u, ✓ , X , y , z;</p>\n<p id='581' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() != 2) return -1; 11 Error.</p>\n<p id='582' data-category='paragraph' style='font-size:18px'>if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))<br>pos3D.resize(3, NODS) ;</p>\n<p id='583' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='584' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='585' data-category='paragraph' style='font-size:14px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j) ;<br>X = u * _Lx;<br>y = ✓ * _Ly * (1. + _a * : :sin(x)) ;<br>Z = 0. ;<br>pos3D(0, j) = x;<br>pos3D(1, j) = y;<br>pos3D(2, j) = z;</p>\n<br><p id='586' data-category='paragraph' style='font-size:18px'>}</p>\n<br><p id='587' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>\n<br><p id='588' data-category='paragraph' style='font-size:20px'>}</p>\n<p id='589' data-category='paragraph' style='font-size:18px'>11 Computes the reference coordinates (UV) · nodeIDs not used.<br>int get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const</p>\n<br><p id='590' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='591' data-category='paragraph' style='font-size:16px'>const size_t NODS(pos3D.cols()) ;<br>double u, ✓ , X , y;</p>\n<p id='592' data-category='paragraph' style='font-size:18px'>if (pos3D.rows() != 3) return -1; 11 Error.</p>\n<p id='593' data-category='paragraph' style='font-size:18px'>if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))<br>pos2D.resize(2, NODS) ;</p>\n<p id='594' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='595' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='596' data-category='paragraph' style='font-size:16px'>X = pos3D(0, j) ;<br>y = pos3D(1, j);<br>u = X / Lx;<br>✓ = y / (_Ly * (1. + _a * : :sin(x))) ;<br>pos2D(0, j) = u;<br>pos2D(1, j) = V;</p>\n<br><p id='597' data-category='paragraph' style='font-size:18px'>}</p>\n<br><p id='598' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>\n<br><p id='599' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='600' data-category='paragraph' style='font-size:20px'>111 Computes the local tangents.<br>int get_tangents (const DoubleMat& pos2D, Doub leMat& T) const</p>\n<br><p id='601' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='602' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols());<br>double u, ✓ , x;</p>\n<p id='603' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>\n<p id='604' data-category='paragraph' style='font-size:18px'>if ((T.rows() != 6) 11 (T.cols() く NODS))<br>T.resize(6, NODS) ;</p>\n<p id='605' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='606' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='607' data-category='paragraph' style='font-size:14px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j);<br>X = u * _Lx;<br>T(0, j) = _Lx;<br>T(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;</p>\n<table id='608' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials</td></tr></tbody></table>\n<p id='609' data-category='paragraph' style='font-size:14px'>T(2, j) = ⊙ , ;<br>T(3, j) = 0. ;<br>T(4, j) = _Ly * (1. + _a * : :sin(x)) ;<br>T(5, j) = 0. ;</p>\n<br><p id='610' data-category='paragraph' style='font-size:18px'>}</p>\n<br><p id='611' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>\n<br><p id='612' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='613' data-category='paragraph' style='font-size:18px'>111 Computes the local curvatures.<br>int get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const</p>\n<br><p id='614' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='615' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols()) in</p>\n<p id='616' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>\n<p id='617' data-category='paragraph' style='font-size:18px'>if ((H. rows() != 3) 11 (H.cols() く NODS))<br>H. resize(3, NODS) ;</p>\n<p id='618' data-category='paragraph' style='font-size:14px'>H = ⊙ · ; 11 Null curvatures here (the surface is plane) ·<br>return 0;</p>\n<br><p id='619' data-category='paragraph' style='font-size:18px'>}</p>\n<p id='620' data-category='paragraph' style='font-size:18px'>111 Data members.<br>double _Lx, _Ly, _a;</p>\n<br><p id='621' data-category='paragraph' style='font-size:20px'>}; 11 surface</p>\n<p id='622' data-category='paragraph' style='font-size:20px'>111<br>int main()</p>\n<br><p id='623' data-category='paragraph' style='font-size:18px'>{</p>\n<br><table id='624' style='font-size:16px'><thead></thead><tbody><tr><td>const</td><td>DoubleVec2</td><td>PO(0. , -0.5)</td><td>;</td></tr><tr><td>const</td><td>DoubleVec2</td><td>P1(1 · , -0.5)</td><td>;</td></tr><tr><td>const</td><td>DoubleVec2</td><td>P2(1 . , +0.5) ;</td><td></td></tr><tr><td>const</td><td>DoubleVec2</td><td>P3(0 · , +0.5) ;</td><td></td></tr><tr><td>DoubleMat</td><td></td><td>pos;</td><td></td></tr><tr><td>UIntVec</td><td></td><td>indicesG, indices;</td><td></td></tr><tr><td>DoubleVec</td><td></td><td>Us;</td><td></td></tr><tr><td>UIntMat</td><td></td><td>connectE2, connectM;</td><td></td></tr><tr><td>DoubleVec</td><td></td><td>sizesG, sizes;</td><td></td></tr><tr><td>const</td><td>double</td><td>Lx (10.) ;</td><td></td></tr><tr><td>const</td><td>double</td><td>Ly(6.0) ;</td><td></td></tr><tr><td>const</td><td>double</td><td>h0 (0.25) ;</td><td></td></tr><tr><td>surface</td><td></td><td>S(Lx, Ly, 0.5) ; 11 The parametric surface to be</td><td></td></tr></tbody></table>\n<br><p id='625' data-category='paragraph' style='font-size:18px'>meshed.</p>\n<p id='626' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLLs.<br>triamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;<br>,<br>triamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>\n<p id='627' data-category='paragraph' style='font-size:14px'>pos . push_back(P0) ;<br>pos · push_back (P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;</p>\n<p id='628' data-category='paragraph' style='font-size:14px'>11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.<br>meshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;<br>S. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·</p>\n<p id='629' data-category='paragraph' style='font-size:18px'>11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.<br>sizesG. clear() ;<br>sizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.<br>meshtools1d: :mesh_line(pos, indicesG, sizesG, true,<br>1, UINT_MAX, O. , , indices, Us, sizes) ;<br>⊙ .<br>meshtools1d: : indices_to_connectE2(indices, connectE2) ;</p>\n<br><p id='630' data-category='paragraph' style='font-size:18px'>11 MESH THE SURFACE.</p>\n<br><p id='631' data-category='paragraph' style='font-size:18px'>triamesh_aniso: : mesher the_mesher, aux_mesher;<br>triamesh_aniso: : mesher: :data_type data(pos, connectE2) ;<br>meshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;<br>data.extract(pos, connectM) ;</p>\n<table id='632' style='font-size:22px'><thead></thead><tbody><tr><td>TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Ⓡ & Iso/Aniso - 48 tutorials</td></tr></tbody></table>\n<h1 id='633' style='font-size:18px'>data.print_info (&display_hdl) ;</h1>\n<p id='634' data-category='paragraph' style='font-size:14px'>/ / VISUALISATION.<br>meshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;</p>\n<p id='635' data-category='paragraph' style='font-size:16px'>return 0;<br>} / / main</p>\n<p id='636' data-category='paragraph' style='font-size:20px'>We present below the intermediate anisotropic meshes on the reference space (normally not shown) and the<br>final meshes on the parametric surface.</p>\n<table id='637' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials</td></tr></tbody></table>\n<figure id='638'><img alt=\"\" data-coord=\"top-left:(116,117); bottom-right:(594,591)\" /><figcaption id='640' style='font-size:14px'>Figure 29 - 2-D anisotropic meshes in the reference space (UV).</figcaption></figure>\n<br><figure id='639'><img alt=\"\" data-coord=\"top-left:(649,118); bottom-right:(1124,591)\" /><figcaption id='640' style='font-size:14px'>Figure 29 - 2-D anisotropic meshes in the reference space (UV).</figcaption></figure>\n\n<br><figure id='641'><img style='font-size:20px' alt=\"↓ ↓\" data-coord=\"top-left:(112,635); bottom-right:(1134,1238)\" /><br><figcaption id='642' style='font-size:14px'>Figure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space.</figcaption></figure>\n\n<p id='643' data-category='paragraph' style='font-size:18px'>The next example is a true 3-D parametric surface (only the source code for the surface class is shown).</p>\n<table id='644' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials</td></tr></tbody></table>\n<h1 id='645' style='font-size:20px'>#include \"stdafx.h\"</h1>\n<br><p id='646' data-category='paragraph' style='font-size:20px'>/*The Surface class implements the functions needed by mesh_surface_param* /<br>struct surface</p>\n<br><p id='647' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='648' data-category='paragraph' style='font-size:20px'>11 Constructor.<br>surface (double L, double H) : _L(L) , _H(H) { }</p>\n<br><p id='649' data-category='paragraph' style='font-size:20px'>11 Computes the 3D coordinates.<br>int get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const</p>\n<br><p id='650' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='651' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols());<br>double u, V, x, y , z;</p>\n<br><p id='652' data-category='paragraph' style='font-size:20px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>\n<br><p id='653' data-category='paragraph' style='font-size:20px'>if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))<br>pos3D.resize(3, NODS) ;</p>\n<p id='654' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='655' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='656' data-category='paragraph' style='font-size:16px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j) ;<br>X = L * u;<br>y = 人 L * ✓;<br>Z = _H * : : cos (x) * : :cos (y) ;<br>pos3D(0, 1) = x;<br>pos3D(1, j) = y ;<br>pos3D(2, j) = z;</p>\n<br><p id='657' data-category='paragraph' style='font-size:20px'>}</p>\n<br><p id='658' data-category='paragraph' style='font-size:20px'>return 0; 11 OK.</p>\n<br><p id='659' data-category='paragraph' style='font-size:20px'>}</p>\n<br><p id='660' data-category='paragraph' style='font-size:20px'>11 Computes the reference coordinates (UV) . nodeIDs not used.<br>int get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const</p>\n<br><p id='661' data-category='paragraph' style='font-size:20px'>{</p>\n<br><p id='662' data-category='paragraph' style='font-size:20px'>const size_t NODS(pos3D.cols());<br>double u, V, x, y;</p>\n<br><p id='663' data-category='paragraph' style='font-size:18px'>if (pos3D.rows() く 2) return -1; 11 Error.</p>\n<p id='664' data-category='paragraph' style='font-size:20px'>if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))<br>pos2D.resize(2, NODS) ;</p>\n<p id='665' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='666' data-category='paragraph' style='font-size:20px'>{</p>\n<br><p id='667' data-category='paragraph' style='font-size:18px'>X = pos3D(0, j) ;<br>y = pos3D(1, j) ;<br>u = X / _L;<br>✓ = y / _L :<br>pos2D(0, j) = u;<br>pos2D(1, j) = V;</p>\n<br><p id='668' data-category='paragraph' style='font-size:20px'>}</p>\n<br><p id='669' data-category='paragraph' style='font-size:20px'>return 0; 11 OK.</p>\n<br><p id='670' data-category='paragraph' style='font-size:20px'>}</p>\n<br><p id='671' data-category='paragraph' style='font-size:20px'>111 Computes the local tangents.<br>int get_tangents (const DoubleMat& pos2D, Doub leMat& T) const</p>\n<br><p id='672' data-category='paragraph' style='font-size:20px'>{</p>\n<br><p id='673' data-category='paragraph' style='font-size:18px'>const size_t</p>\n<br><p id='674' data-category='paragraph' style='font-size:22px'>NODS(pos2D.cols());</p>\n<br><p id='675' data-category='paragraph' style='font-size:20px'>double</p>\n<br><p id='676' data-category='paragraph' style='font-size:16px'>u, ✓ , X , y;</p>\n<br><p id='677' data-category='paragraph' style='font-size:20px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>\n<p id='678' data-category='paragraph' style='font-size:20px'>if ((T.rows() != 6) 11 (T.cols() く NODS))<br>T.resize(6, NODS) ;</p>\n<p id='679' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>\n<br><p id='680' data-category='paragraph' style='font-size:18px'>{</p>\n<br><p id='681' data-category='paragraph' style='font-size:18px'>u = pos2D(0, j) ;</p>\n<br><p id='682' data-category='paragraph' style='font-size:18px'>✓ = pos2D(1, j) ;</p>\n<br><p id='683' data-category='paragraph' style='font-size:14px'>X = L * u;</p>\n<br><p id='684' data-category='paragraph' style='font-size:16px'>L * V;</p>\n<br><p id='685' data-category='paragraph' style='font-size:14px'>y =</p>\n<br><p id='686' data-category='paragraph' style='font-size:18px'>T(O, j) =</p>\n<br><p id='687' data-category='paragraph' style='font-size:18px'>� ;</p>\n<br><p id='688' data-category='paragraph' style='font-size:18px'>T(1, ]</p>\n<br><p id='689' data-category='paragraph' style='font-size:16px'>= 0.</p>\n<br><p id='690' data-category='paragraph' style='font-size:20px'>T(2, ]</p>\n<br><p id='691' data-category='paragraph' style='font-size:16px'>= - H * _L * : :sin(x) * : :cos (y) ;</p>\n<br><p id='692' data-category='paragraph' style='font-size:14px'>,</p>\n<br><p id='693' data-category='paragraph' style='font-size:16px'>T(3, ] ) = 0. F</p>\n<br><p id='694' data-category='paragraph' style='font-size:14px'>= L ;</p>\n<br><p id='695' data-category='paragraph' style='font-size:20px'>T(4, J</p>\n<br><p id='696' data-category='paragraph' style='font-size:16px'>T(5, j) = - H * _L * : :cos (x) * : :sin(y) ;</p>\n<br><p id='697' data-category='paragraph' style='font-size:20px'>return 0;</p>\n<br><p id='698' data-category='paragraph' style='font-size:20px'>}</p>\n<br><p id='699' data-category='paragraph' style='font-size:20px'>11 OK.</p>\n<br><p id='700' data-category='paragraph' style='font-size:20px'>}</p>\n<table id='701' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials</td></tr></tbody></table>\n<figure id='702'><img style='font-size:14px' alt=\"111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface.\" data-coord=\"top-left:(94,109); bottom-right:(1108,738)\" /></figure>\n<table id='703' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials</td></tr></tbody></table>\n<figure id='704'><img alt=\"\" data-coord=\"top-left:(116,116); bottom-right:(593,593)\" /><figcaption id='706' style='font-size:14px'>Figure 31 - 2-D anisotropic meshes in the reference space (UV).</figcaption></figure>\n<br><figure id='705'><img alt=\"\" data-coord=\"top-left:(648,117); bottom-right:(1123,592)\" /><figcaption id='706' style='font-size:14px'>Figure 31 - 2-D anisotropic meshes in the reference space (UV).</figcaption></figure>\n\n<br><figure id='707'><img style='font-size:20px' alt=\"↓ ↓\" data-coord=\"top-left:(114,635); bottom-right:(1134,1242)\" /><br><figcaption id='708' style='font-size:14px'>Figure 32 - 3-D surface meshes (T3 and all Q4).</figcaption></figure>\n\n<p id='709' data-category='paragraph' style='font-size:16px'>Notes:</p>\n<p id='710' data-category='list' style='font-size:16px'>· This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface<br>is available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2<br>SurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).<br>For more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.<br>· When there is only a discrete representation of the surface available (such as a tessellated surface), a<br>different method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and<br>CM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.<br>For more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.<br>· A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing.</p>\n<table id='711' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>53</td></tr></tbody></table>\n<h1 id='712' style='font-size:14px'>COMPUTING<br>OBJECTS</h1>", "markdown": "# COMPUTING\nOBJECTS\n\n# CM2 TriaMeshⓇ Iso/Aniso\nCM2 QuadMesh � Iso/Aniso\n\n# Version 5.6\n\ntutorials\n\nRevision February 2025.\nhttps://www.computing-objects.com\nⒸ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France.\n\n# Forewords\n\nThis manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:\n\n- · The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,\n- · The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso.\n\n\nAll these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well\nas the internal hard edges and hard points (embedded) are kept unmodified in the final mesh.\n\nBased on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality\nelements with smooth grading sizes according to the length of the boundary edges or to the user-specified\nsizes. The speed is near independent of the number of the elements to be generated.\n\nSetting switches can be used to adapt the meshers to the various needs of the user concerning mesh\ngeneration, refinement and optimization (they can also be used as optimizer-only of some already existing\nmeshes).\n\nThe quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes.\n\nMany data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the\nneighbors, number of sub-domains, area...\n\nLike many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-\nthreaded (you can select in the settings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).\n\nData are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers.\n\nFor a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TriaMesh & CM2 QuadMesh - reference manual.\n\nThe source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.\nS.P.2001.000.20700 (23/05/2019) is regularly deposited since then.\n\nThe source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly\ndeposited since then.\n\nThe source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.\n\n| TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 2 tutorials |\n| --- | --- |\n\n\n# Table of contents\n\nForewords. ...... 2\n\n- 1. Getting started - a simple square .......... ········· 5\n- Some declarations 6\n- Authorization of the library........ 6\n- Contour mesh 7\n- 2. Square with an internal line.......... ...... 14\n- 3. Square with internal hole ....... 17\n- 4. Quadratic elements & high-order nodes ........ ........ 19\n- 5. Square with grading mesh size. ........ 21\n- 6. Square with an internal hard node ......... ....... 23\n- 7. Multiple meshes ........ ·········· 25\n- 8. Shared boundaries ......... ....... 28\n- 9. Background mesh ..... ······· 32\n- 10. Anisotropic meshes. ...... 38\n- 11. 3-D surface meshes (aniso meshers only) .... ...... 43\n\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials |\n| --- | --- |\n\n\nBefore meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter\nmostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One\nexample (Section 7) illustrates the case where the boundary mesh has been generated by other means and is\nsimply read from a file.\n\nEach example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).\n\nThe general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:\n: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.\n\nFile stdafx.h1:\n\nCM2 MESHTOOLS\n\n11\n#include \" meshtools. h\"\n#include \" meshtoo ls1d.h\"\n#include \" tri amesh_iso. h\"\n#include \" quadmesh_iso. h\"\n#include \" triamesh_aniso.h\"\n#include \"quadmesh_aniso.h\"\n\n| General purpose mesh routines |\n| --- |\n| To generate 1D meshes |\n| CM2 TriaMesh Iso |\n| CM2 QuadMesh Iso |\n| CM2 TriaMesh Aniso (Section 10 onlyly) |\n| CM2 QuadMesh Aniso (Section 10 |\n\n\nusing namespace cm2;\n\n/ Main cm2 namespace can now be omitted.\n\nRequired libraries2:\n\n- · cm2math1\n- · cm2misc\n- · cm2meshtools\n- · cm2meshtools1d\n- · cm2meshtools2d\n- · cm2triamesh_ iso\n- · cm2quadmesh_ iso\n- · cm2triamesh_aniso (Section 10 only)\n- · cm2quadmesh_aniso (Section 10 only)\n\n\n1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_\niso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.\n2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are\nlib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib).\n\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n\n\n# 1. Getting started - a simple square\n\nThis first example is a regular mesh of a square. The four boundary segments are equally discretized with 10\nelements.\n\n#include \"stdafx.h\"\n#include <iostream>\n\n11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }\n\nint main()\n\n{\n\n| const double | L(10.); |\n| --- | --- |\n| const unsublevec2 | N(10) ; |\n| const Doub | PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES AND LINE MESHES.\n\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\nmeshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectB) ;\n\n11 THE 2D MESH.\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;\n\n11 SOME OUTPUT INFO (OPTIONAL) .\ndata.print_info(&display_hdl) ;\n\n11 VISUALISATION (OPTIONAL) .\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\n# The resulting mesh is shown Figure 1.\n\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 1 - Triangle mesh of a square.\n\nLet us explain this program line by line.\n\n# Some declarations\n\nMatrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a\nUIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column\nnumber in matrix pos where the coordinates of this node can be found4.\n\nindices is a temporary vector.\n\nAuthorization of the library\n\nThe library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to\ntri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for\neach library: the name of your company or organization that has acquired the license and a secret code5. Note\nthat both strings are case sensitive and the registration call must be made each time the library is loaded into\nmemory and before the first run of the mesher.\n\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n- 3 See manual CM2 Math1 - overview.\n- 4 Recall that array indices are zero based (from 0 to N-1).\n- 5 Contact license@computing-objects.com for any licensing inquiry.\n\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials |\n| --- | --- |\n\n\nContour mesh\n\nThis is usually the heaviest part of the work for the user. In this example, we only use routines from the\nCM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it\nform a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos\ncontaining the points' coordinates and the connectivity matrix connectB of the boundary edges.\n\nFirst, the corners of the square are created as four pair of coordinates in the pos matrix:\n\npos · push_back(P0) ;\npos · push_back(P1) ;\npos . push_back(P2) ;\npos . push_back(P3) ;\n\nThe push_back function appends a new column at the end of a matrix. The size of the column must match the\ncurrent number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows.\n\nAfter these four push-backs, the dimensions of the pos matrix are 2 X 4.\n\n| meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ; |\n| --- |\n| meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ; |\n\n\nNow that the four corners are present, we can create the points in between and the associated edges:\n\nThe mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new\nappended columns in the pos matrix:\n\nmeshtoo ls1d : : mesh_straight\n(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;\n\nThe index of each point, i.e. the column in matrix pos, is also appended to the vector indices.\nWith i0 = 0 and i1 = 1, this vector contains upon exit of this function:\n\n[0 4 5 6 7 8 9 10 11 12 1]\n\nAnd the matrix pos is now of size 2 X 13:\n\n![image](/image/placeholder)\n- Chart Type: line\n|  | Four corners | New generated nodes |\n| --- | --- | --- |\n| item_01 | 12 | 12 |\n\n\n6 See Section 5, \"Square with Grading Mesh Size\".\n\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025 | 7 tutorials |\n| --- | --- |\n\n\nThe last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:\n\nindices · pop_back() ;\n\nThe second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:\n\n[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]\n\nAfter the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index\nequals to the first, here zero, to close the contour7.\n\nThe vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:\n\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\n\nThe connectB matrix has now dimensions 2 X 40:\n\n2x40 [0 4 5 6 7 · · · 39\n4 5 6 7 8 · · · 0]\n\nNow that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a\ndata structure holding this 1-D mesh and make the mesher run on it:\n\ntriamesh_iso : : mesher : :data_type data (pos, connectB) ;\nthe_mesher · run (data) ;\n\nThis constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos\nand data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated\ninside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40\npoints are left untouched in the first 40 columns.\n\nThe connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of\nthe nodes for an element8. connectM(i, j) is the ith local node of the jth element.\n\n7 The same result could have been achieved with:\n\nUIntVec hard_nodes (5) ;\nhard_nodes [0] = 日;\nhard_nodes[1] = 1;\nhard_nodes[2] = 2;\nhard_nodes[3] = 3;\nhard_nodes [4] = 日;\nmeshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;\nThis variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes).\n\n8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule).\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n\n\nPrinted information about the generated mesh and a MEDIT9 output file are obtained with:\n\ndata.print_info(&display_hdl) ;\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;\n\nHere is the output given by data.print_ info(&display_hdl) :\n\n![image](/image/placeholder)\n* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙\n\nFigure 2 - Output info for the square example.\n\nThe generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges\n(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,\noptimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.\nIn the second step new nodes are generated inside the domain to get elements with good shape and size.\nFinally, the last step is for geometrical and topological optimizations to improve the quality of the elements.\n\n9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront\nOBJ.\n\n10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270\nV2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh\nAniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso).\n\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials |\n| --- | --- |\n\n\nThe formula used to compute the shape quality of a triangle writes:\n\n| S | S | Area of the triangle. |\n| --- | --- | --- |\n| Qs = 4V3 L P | L with: max | Length of the longest edge of the triangle. |\n| max | P | Perimeter of the triangle. |\n\n\nThis quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.\nOn the square example, the worst shape quality is 0.83 and the average is 0.94.\n\nThe size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates\nthat the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,\nand a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as\nit should be (and should have been split).\n\nThe formula used to compute the length quality of an edge AB writes:\n\n$$Q_{h}^{4B}=L_{A B}\\,\\frac{\\left|\\displaystyle\\left(\\frac{h_{A}}{h_{B}}\\right)}{h_{A}-h_{B}}$$\n\nAB\n\nL\n\nwith:\n\nh\n\nActual length of edge AB.\n\nA\n\nTarget size at node A (expected edge length at A).\n\nh B Target size at node B (expected edge length at B).\n\nLet's introduce also at this point the h-shock measure of an edge:\n\n$$h s^{A B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{B}^{A B}}}-1$$\n\nThese two measures are dimensionless and positive.\n\nWhen hA = hB the h-shock is null and the length quality simply writes QAB\n\nAB\n\nL\n\nhA\n\nWhen QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB.\n\nTo optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.\n\nThe histogram of the size qualities can be computed either inside the mesher by raising the flag settings .\ncompute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :\n: edge_qualities.\n\n11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options.\n\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 10 tutorials |\n| --- | --- |\n\n\nOn the square example, the size qualities are well centered on the value 1 with a small variance:\n\n![image](/image/placeholder)\n* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙\n\nFigure 3 - Histogram of the size-qualities of all the edges in the square example.\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials |\n| --- | --- |\n\n\nTo mesh with quadrangles all is needed is to change the class of the mesher:\n\n#include \"stdafx.h\"\n#include <iostream>\n\n11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }\n\nint main()\n\n{\n\nconst\n\nconst\n\nconst\n\n| double | L(10.); |\n| --- | --- |\n| unsi gned | N(10) ; |\n| Doub leVec2 | PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; , |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso : :registration(\"Licensed to SMART Inc .\n,\n\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos · push_back(P2) ;\npos . push_back (P3) ;\nmeshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;\nmeshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n\n| 11 THE 2D MESH. |  |\n| --- | --- |\n| quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ; | the_mesher; data (pos, connectB) ; |\n\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;\n\nreturn 0;\n11 main\n\n}\n\nIn this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12.\n\n12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4.\n\n| QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials |\n| --- | --- |\n\n\nFigure 4 - Square meshed with quads.\n\nFor a plane quadrangle, we use the following measure of the shape quality:\n\n| S | S min | Minimum area of the four triangles. |\n| --- | --- | --- |\n| Qs = 8V2 min | with: L | Max length of the four sides and the two diagonals. |\n| L P max | max P | Perimeter of the quad. |\n\n\nThis measure gives the maximal value 1 only for a square.\n\nThe size quality is given by the same measure as for the triangles (because it is based on edges only).\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials |\n| --- | --- |\n\n\n# 2. Square with an internal line\n\nStarting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(10.), R(3.) ; |\n| --- | --- |\n| const Doubtevec2 | N1(10) , N2(20) ; |\n| const Doub | PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ; |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | pos ; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\ntriamesh_iso: : registration(\"Licensed to SMART Inc .\n,\n\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos · push_back (P1) ;\npos . push_back(P2) ;\npos · push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on\nmeshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d : : indices_ to_connectE2(indices, connectB) ;\n\nindices.clear();\n\nmeshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;\nindices.back() = indices. front();\nmeshtools1d::indices_ to_connectE2(indices, connectB) ;\n\n11 THE 2D MESH.\ntriamesh_iso: :mesher the_mesher;\ntriamesh_iso: : mesher::data_type data (pos, connectB) ;\nthe_mesher. run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n- Chart Type: line\n|  | Red | Blue | Green | Yellow | Purple | Orange |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 12 | 8 | 5 | 4 | 3 |\n\n\n![image](/image/placeholder)\n\n\nFigure 5 - Square with internal line (T3 and all-Q4).\n\nThe mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation\nis defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �.\n\nThe circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point\n#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to\nreplace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only\ncoincident17:\n\nindices. back() = indices. front() ;\n\nAs for the external contour, these indices are converted into edges with the indices_ to_connectE2\nfunction and appended to the connectB matrix.\n\nAgain, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,\nif we accept some triangles we can get a better mesh.\n\n13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.\n14 Note that the coordinates at column 24 in the pos matrix will remain unused.\n\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials |\n| --- | --- |\n\n\nHere with CM2 QuadMesh� Iso in quad-dominant mode:\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(10) , R(3.) · |\n| --- | --- |\n| const unsigned | N1(10), N2(20); |\n| DoubleMat | pos; |\n| const DoubleVec2 | 0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R; |\n| const DoubleVec2 | L/2); |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso: : registration(\"Licensed to SMART Inc .\n,\n\n11 VERTICES AND LINE MESHES.\npos. push_back (PO) ;\npos . push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d: :indices_to_connectE2(indices, connectB) ;\nindices.clear() ;\nmeshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;\nindices. back() = indices. front() ;\nmeshtools1d: :indices_to_connectE2 (indices, connectB) ;\n\n11 THE 2D MESH.\n\nquadmesh_iso: :mesher the_mesher;\nquadmesh_iso: :mesher: :data_type data(pos, connectB) ;\nthe_mesher.settings.all_quad_flag = false;\nthe_mesher run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;\n\nreturn 0;\n} 11 main\n\n![image](/image/placeholder)\n- Chart Type: pie\n|  | Purple | Orange | Red | Blue | Green |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 20% | 20% | 20% | 20% | 20% |\n\n\nFigure 6 - Square with internal line (quad-dominant mode).\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials |\n| --- | --- |\n\n\n# 3. Square with internal hole\n\nA hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that\nthis implies that all edges of the external contour should be oriented in a uniform way (either clockwise or\ncounter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert\nthe orientation of the internal edges and thus to remove the disk from the domain:\n\nmeshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;\n\nAnd the resulting meshes:\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 7 - Square with a circular hole (T3 and all-Q4).\n\n15 Without any closed internal hard line, the orientation of the external contour is irrelevant.\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials |\n| --- | --- |\n\n\nOne can nest alternatively positive and negative rotations:\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 8 - Concentric circles with alternate orientation (T3 and all-Q4).\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials |\n| --- | --- |\n\n\n# 4. Quadratic elements & high-order nodes\n\nLet us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we\nwould like also the edges along the circular hole to be curved.\n\nFor that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :\n: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic.\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(10.), R(3.) in |\n| --- | --- |\n| const unsigned | N1(10); N2(20) �.), |\n| const Doub [eVec2 | P2(L, L) , P3(0 * , L) ; P1(L, |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | indices; |\n| UIntVec |  |\n| UIntMat | connectB, connectE2; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES AND LINE MESHES.\npos · push_back (PO) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos · push_back (P3) ;\nmeshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;\n. push_back (P4) ;\nmeshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on\nmeshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;\nmeshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\nmeshtools1d: : convert_into_quadratic(pos, connectB);\nindi ces. clear () ;\nmeshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;\nindi ces. back() = indi ces. front() ;\nmeshtools1d: :indices_ to_connectE3(indices, connectB) ;\nconnectE2.copy (connectB) ;\nmeshtools1d: :convert_into_linear (connectE2) ;\n\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here.\n\nthe_mesher. run (data) ;\n\nmeshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;\n\nreturn 0;\n} 11 main\n\nTo keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter\n(this will create new high-order nodes, different from those in connectB):\n\nmeshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;\n\n16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_\norder · Refer to the HTML reference manual for detailed information.\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n\n\nThis would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity\nmatrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly\ninterpolated between the initial vertices, all the edges would remain straight.\n\nThis is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity\nmatrix of the boundary edges (or some of them) is usually required later to setup boundary conditions\n(Dirichlet, Neumann...)\n\nSo, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-\nnode edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):\n\nmeshtools1d : : convert_into_quadratic (pos, connectB) ;\n\nThe connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are\nunchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17).\n\n0\n\nlinear nodes\n\n1\n\n|  | 1 | 2 3 | 4 | 6 | 8 | 10 |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 2 | 3 | 4 | 5 7 | 9 | 11 |\n| 12 | 13 | 14 | 15 | 16 17 | 18 | 19 |\n\n\nFigure 9 - Example of connectivity matrix for quadratic edges and view to linear edges.\n\nFor the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence\nof node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).\nThis is possible because we have generated along the circle twice as much nodes as in the previous example\n(extrude_rotate with 2 N2).\n\nNow we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along\nthe circle.\n\nHowever, the mesh generators accept only linear edges upon entry and give only linear face elements upon\nexit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called\nconnectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear\nedges with convert_ into_ linear.\n\nAfter the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes\nalong the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity\nmatrix connectB created before:\n\nmeshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;\n\nThis forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match.\n\n17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them.\n\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 20 tutorials |\n| --- | --- |\n\n\n# 5. Square with grading mesh size\n\nThere are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along\nthe boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates\nthese values inside the domain and generates elements accordingly.\n\nTo illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of\nthe contour we specify different mesh sizes on each four vertices:\n\n#include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(10.); |\n| --- | --- |\n| const unsi gLevec2 | N(10).3, |\n| const Doub | P1(L, 0.) , P2(L, L), P3(0. , L) ; |\n| DoubleMat | indices |\n| UIntVec | , hard_nodes (5) ; |\n| DoubleVec | sizes(5); |\n| UIntMat | connectB; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES AND LINE MESHES.\n\npos · push_back (PO) ;\npos · push_back (P1) ;\npos . push_back (P2) ;\npos · push_back(P3) ;\nhard_nodes [0] = 0; sizes [0] = 0. 1*L/N;\nhard_nodes [1] 1; sizes [1] = 2. 0*L/N;\nhard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;\nhard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;\nhard_nodes [4] = 0; sizes [4] = 0. 1*L/N;\nmeshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\n\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\n\nreturn 0;\n11 main\n\n}\n\nThis variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal\nline) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best\nthe target values on the four corners.\n\nThese target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used\nto compute the 2-D size map.\n\n18 By averaging the lengths of the adjacent edges to each hard node.\n\n| TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 & CM2 - 21 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 10 - Meshes with grading size (T3 and all-Q4).\n\nThe second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some\nhard nodes. This is explained in the next section.\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials |\n| --- | --- |\n\n\n# 6. Square with an internal hard node\n\nSo far, we have seen only three fields of the structure used to exchange data with the mesher:\n\n- · The pos matrix for the coordinates of the points.\n- · The connectB matrix for the connectivity of the hard edges.\n- · The connectM matrix for the connectivity of the 2-D mesh.\n\n\nIn this example we add an isolated hard node at the center of the square and specify a target size on it. This will\nbe done using the two new fields isolated_nodes and metrics:\n\n![image](/image/placeholder)\n#include \"stdafx.h\"\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\n\nWe have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is\npushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be\nhonored in the final mesh.\n\nThe vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or\nnot present- a default value will be used instead19.\n\nIn our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10\ntimes finer mesh around it.\n\n19 For an isolated node, the default computed size is based on the size value of the nearest nodes.\n\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 23 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 11 - Mesh concentration near a hard node (T3 and all-Q4).\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials |\n| --- | --- |\n\n\n# 7. Multiple meshes\n\nThe matrix connectB can contain internal lines. It can also contain several external disconnected contours (to\nmesh several disconnected domains simultaneously). Some care must be taken however in the orientation of\nthese contours. For multiple domains, the edges of all external contours must be oriented the same way, for\ninstance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect\neach other.\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 12 - Multiple meshes (T3 and all-Q4).\nThe four sub-domains are meshed simultaneously.\n\nIn this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:\n\n![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm(\"cards.dat\") ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( \"out.mesh\" , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main\n\n20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines.\n\n| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 25 tutorials |\n| --- | --- |\n\n\nThe input boundary meshes are read from an ASCII file with cm2 : : matio: :read21\n\nThe format for the matrices is:\n\n| n X m | [ <table><thead></thead><tbody><tr><td>do,o</td><td>do,1</td><td>do,2</td><td>· · ·</td><td>do,m-1</td></tr><tr><td>d1,0</td><td>d1,1</td><td>d1,2</td><td>· · ·</td><td>d1,m-1</td></tr></tbody></table> |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n| dn-1, 0 |  | dn-1,1 | dn-1,2 · | · · | dn-1,m-1 | ] |\n\n\nThe format for each component of the matrix is free.\n\nFor instance a 2 X 4 Doub leMat can be stored as:\n\n2 X 4 [\n0 0.5 1 2.0\n0 1 1 2.E-1]\n\n# Notes:\n\n- · We can see in this example that the meshes may not always be symmetric even with a symmetric contour.\n- · We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-\n- domain to be meshed in a structured manner.\n\n\n21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.\nThis can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files.\n\n| CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 26 tutorials |\n| --- | --- |\n\n\nAs an exercise we can get the same result by making four successive meshes and concatenating the results:\n\n#include \"stdafx.h\"\n#include <fstream>\n\nint main()\n\n{\n\n| std: :ifstream | istrm |\n| --- | --- |\n| UIntMat | connectM; |\n| DoubleMat | pos; |\n\n\n\" \"F53EA108BCWX\") ;\ntriamesh_iso : : registration(\"Licensed to SMART Inc . ,\n\ntriamesh_ iso : : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data;\n\nistrm. open(\"heart.dat\") ;\nmatio : : read (istrm, data · pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\n\nistrm. open(\"spade.dat\") ;\nmatio: : read(istrm, data . pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher ・ run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\n\nistrm. open(\"diamond. dat\") ;\nmatio : : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run(data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\n\nistrm. open(\"club. dat\") ;\nmatio: : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; / / Shift indices.\npos. push_back(data.pos) ;\nconnectM.push_back(data.connectM) ;\n\nmeshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials |\n| --- | --- |\n\n\n# 8. Shared boundaries\n\nEdges can be shared between some contours and lines. In this case some edges are defined several times\n(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more\nconvenient for the user to generate the 1-D meshes of the contours independently from each other. That\nusually implies duplicated nodes on the shared contours.\n\nThe following example deals with such a case.\n\nConsider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared\nbetween sub-domains but with different orientation. We also want to mesh the contours of the sub-domains\nindependently from each other but without any duplicated nodes.\n\n![image](/image/placeholder)\n- Chart Type: line\n|  | P0 | P | P3 | P4 | P5 | P6 |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 1 | 1 | 1 | 1 | 1 | 1 |\n\n\nFigure 13 - Domain composed of three attached sub-domains.\n\nThe shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict\nmode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes\ncan be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,\nthe mesher may not be able to tell the sign of the inner square, and that can lead to a hole.\n\nThe solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials |\n| --- | --- |\n\n\n# #include \"stdafx.h\"\n\nstatic void mesh_segment\n\n(DoubleMat& pos, UIntMat& connectB,\nunsigned start_index, unsigned stop_index, unsigned num_edges)\n\n{\n\nUIntVec indices;\nmeshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\n\n}\n\nint main()\n\n{\n\n| const DoubleVec2 | PO (0., | 0.), | P1(10. , 0.), | P2(10. , 2.) , |  |  | P3(8. , 2.) ; |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| const DoubleVec2 |  | P4 (2. , 2.), |  | P5(0. , 2.) , | P6(10. , 10. ) , | P7(0. , | 10.) ; |\n| const DoubleVec2 |  | P8 (2., 8.) | , | P9 (8. , 8.) ; |  |  |  |\n| const unsi gned |  | N(4) ; |  |  |  |  |  |\n| DoubleMat |  | pos; |  |  |  |  |  |\n| UIntMat |  | connectB; |  |  |  |  |  |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES POINTS.\n\npos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;\npos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;\npos . push_back(P8) ; pos · push_back(P9) ;\n\n11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·\n\nmesh_segment (pos, connectB, 日, 1, N) ;\n\nmesh_segment(pos, connectB, 1, 2, N) ;\n\nmesh_segment (pos, connectB, 2, 3, N) ;\n\nmesh_segment (pos, connectB, 3, 4, N) ;\n\nmesh_segment(pos, connectB, 4, 5, N) ;\n\nmesh_segment(pos, connectB, 5, 日, N) ;\n\n11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\n\nmesh_segment (pos, connectB, 2, 6, N) ;\n\nmesh_segment(pos, connectB, 6, 7, N) ;\n\nmesh_segment (pos, connectB, 7, 5, N) ;\n\nmesh_segment (pos, connectB, 5, 4, N) ·\n\nmesh_segment (pos, connectB, 4, 8, N) ·\n\nmesh_segment (pos, connectB, 8, 9, N) ;\n\nmesh_segment(pos, connectB, 9, 3, N) ;\n\nmesh_segment(pos, connectB, 3, 2, N) ;\n\n11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 3, 9, N) ;\nmesh_segment(pos, connectB, 9, 8, N) ;\nmesh_segment(pos, connectB, 8, 4, N) ;\nmesh_segment(pos, connectB, 4, 3, N) ;\n\n11 MERGE TOGETHER DUPLICATED NODES.\nmeshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;\n\n11 THE 2D MESH.\n\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_ type data (pos, connectB) ;\nthe_mesher · run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\n\nreturn 0;\n11 main\n\n}\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials |\n| --- | --- |\n\n\nNote that this solution works because the shared edges are discretized similarly and the nodes are (almost)\ncoincident.\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n- Chart Type: bar\n|  | Red | Blue | Green | Purple | Cyan |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 10 | 10 | 10 | 20 |\n\n\nFigure 14 - Example with shared boundaries (T3 and all-Q4).\n\nNote that the contour of the inner square is oriented completely both ways (positive and negative). In such a\ncase, the mesher favors the positive orientation and keeps the inner sub-domain.\n\nA similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers\nthe inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external\ndomain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole).\n\n![image](/image/placeholder)\n\n\nFigure 15 - Example of ambiguous orientation of an inner contour.\n\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials |\n| --- | --- |\n\n\nHere is another example where a hole is adjacent to the external contour. In this case, the most external\ndomain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole).\n\n![image](/image/placeholder)\n\n\nFigure 16 - Hole adjacent to the external contour.\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n- Chart Type: bar\n|  | Dark Gray | Light Gray |\n| --- | --- | --- |\n| item_01 | 50 | 50 |\n\n\nFigure 17 - Example of ambiguous orientation of an inner contour.\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials |\n| --- | --- |\n\n\n# 9. Background mesh\n\nSometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.\n\nThe background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It's represented by the connectivity matrix background_mesh in the data of the mesher.\n\nAs always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or\nvectors (such as connectM or connectB).\n\nThe nodes of the background mesh can share nodes with connectB or can all be different. They must all have\na valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside\nthe background mesh.\n\nIn the following example, a regular structured background mesh is used to support a size map with a sinusoidal\nvariation in the two directions. The domain to be meshed is a simple square regularly discretized along its\nboundaries22.\n\n22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities.\n\n| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 32 tutorials |\n| --- | --- |\n\n\n# #include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(4.), h0 (0. 25) , h1 (0. 05) ; |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE2, connectT3, BGM; |\n| DoubleVec | sizes; |\n| unsigned | n; |\n| double | W, h; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES AND LINE MESHES.\npos · push_back (DoubleVec2(-L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, +L/2)) ;\npos · push_back(DoubleVec2 (-L/2, +L/2))\nmeshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;\nindices. pop_back() ;\nmeshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;\n\n11 THE BACKGROUND MESH.\n\nn = unsigned(L/h1) ;\n\nindices.clear () ;\nmeshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;\nindices.pop_ back() ;\nmeshtools1d: :mesh_ straight(pos, 1, 2, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_ straight(pos, 2, 3, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;\nmeshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;\n\n11 THE METRICS ON THE BACKGROUND MESH.\nindices.clear();\nmeshtools: :unique_ indices(indices, BGM) ;\nsizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.\nfor (size_t i = 0; i く indices.size(); ++i)\n\n{\n\nn = indices[i];\nn)));\nW = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;\nh = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +\nsizes[n] = h;\n\n}\n\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;\ndata.background_mesh = BGM;\ndata. metrics = sizes;\nthe_mesher · run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).\n\nThe background mesh is the same structured triangle mesh in both cases (here, covering all the domain):\n\n![image](/image/placeholder)\n\n\nFigure 19 - The background mesh used in the previous examples.\n\nThe background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it\nand/or be partially outside of the domain. In the areas not covered by the background mesh, the default size\nfield based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead.\n\nHere is an example where the domain is a disk and the background mesh is also a disk but with half the radius.\nWe have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area.\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\nFigure 20 - Background mesh covering only a fraction of the domain.\n\nWe can also consider the case where the boundary mesh of the domain must also be governed by a\nbackground mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to\nsupport the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"\nand the associated sizes. The discretization for this 1D background mesh must be fine enough to represent\naccurately the geometry of the line.\n\nAn overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full\ncircle with 200 nodes in indices0 starting from node #1 and centered on point CR:\n\nmeshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;\nindices0 . back() = indices0. front();\n\nSizes are specified on the nodes of this circle and a new set of adapted nodes are generated:\n\nvecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.\nmeshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,\nUINT_MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectE) ;\n\nThe parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,\nmaximum of UINT_MAX edges along the arc and no chordal control21.\n\nThe indices vector now contains the nodes of the circle mesh adapted to the metrics.\n\nnew_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these\nnodes but these vectors are not used in the rest of the example.\n\n23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library.\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).\n\nNote: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it\nto a changed metrics map.\n\n24 See HTML reference manual for more info on these parameters.\n\n| QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials |\n| --- | --- |\n\n\n# #include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | R(4.) ; |\n| --- | --- |\n| const double | h0(0.5) , h1(0.05) , sig(0. 40) ; |\n| const DoubleVec2 | CR(0 · 0.) , PO(R, 0.) ; , |\n| DoubleMat | pos; |\n| DoubleVec | new_U, sizes, sizes0, new_sizes; |\n| UIntVec | indices0, indices; |\n| UIntMat | connectE, connectM, BGM; |\n| double | x, y, W, wo, w1, w2; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;\n\"\n,\n\ntriamesh_iso : : mesher the_mesher;\n\npos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·\npos . push_back(P0) ; 11 Point #1 (start of the circle) ·\n\n11 THE 2D BACKGROUND MESH\nn = unsigned (2. *M_PI*R / h1) ;\nmeshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;\nindices. back() = indices · front() ; 11 Close the circle.\nmeshtools1d: : indices_ to_connectE2(indices, connectE) ;\ntriamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;\nthe_ mesher . run(BGMdata) ;\nBGMdata.extract(pos, BGM) ;\n\n11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·\nmeshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;\nindices0.back() = indices0.front();\n\n11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .\nindices.clear();\nmeshtools: :unique indices(indices, BGM) ;\nindices.push_back(indices0); 11 Also the nodes of the circle.\nsizes. resize(pos. cols() , 0.);\nfor (size_t i = 0; i く indices.size() ; ++i)\n\n{\n\nconst size_t n = indices[i] ;\nX = pos(0, n) ;\ny = pos(1, n) ;\nw⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;\nw1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;\nw2 = : : fabs (x + R/2) ;\nW = std : : min (wo, w1) ; sigil. Gaussian variations.\nW = std : : min (w, w2) /\nW = : :exp(-w*w) ;\nsizes[n] = = h0* (1. -w) + h1*w;\n\n}\n\n11 Pick-up the sizes along the circle.\nsizes0.clear();\nvecvec: :push_back(sizes, indices0, sizes0) ;\n\n11 MESH THE CIRCLE ACCORDING TO THE METRICS.\nindices.clear();\nconnectE.clear();\nmeshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,\nUINT MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d: :indices_to_connectE2(indices, connectE) ;\n\n11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.\ntriamesh_ iso: : mesher : : data_ type data(pos, connectE) ;\ndata.background_mesh = BGM;\ndata.metrics = sizes;\nthe_mesher run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials |\n| --- | --- |\n\n\n# 10. Anisotropic meshes\n\nCM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce\nequilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific\ndirections. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic\nunstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their\nisotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic\ncase we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined\nby a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array.\n\n![image](/image/placeholder)\nh1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right).\n\nMj = ab b\nc\n\nwith :\n\na > 0\nac - b2 > 0\ni.e. the two eigen values are > 0\n\ndata.metrics\n\na\n\n·\n\nb\n\n:\n\nc\n\ncolumn #j\n\nFigure 23 - Definition and storage of the 2-D anisotropic metrics.\n\nLet (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:\n\n[vo] = [v1] = 1\n<V0,V1>=0\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials |\n| --- | --- |\n\n\nThen the metrics Mj writes:\n\n$$\\begin{array}{c c}{{M_{j}=\\mathbf{B}}}&{{\\displaystyle\\left[\\frac{1}{h_{0}^{~2}}\\right.\\quad\\qquad}}&{{\\displaystyle\\left|\\begin{array}{c}{{}}\\\\ {{}}\\\\ {{}}&{{}}\\\\ {{\\displaystyle\\qquad\\displaystyle\\frac{1}{h_{1}^{~2}}\\end{array}\\right|}}}\\end{array}\\right.\\qquad}}\\end{array}$$\n\nwith :\n\nB = [vo v1]\nstored column - wise\n\nThe metric equivalent to an isotropic size of h writes:\n\n$$M_{_{j}}=\\left[\\frac{1}{h^{2}}\\quad\\begin{array}{c c c}{{0}}\\\\ {{}}&{{}}\\\\ {{0}}&{{\\frac{1}{h^{2}}\\right]$$\n\nA null matrix would lead to infinite sizes in both directions (infinite circle).\n\nWhen the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic\ndefault metrics we have seen before. For each hard node the default metric is based on the length of the\nadjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for\ninstance examples 1, 2, 3 or 4 and replace:\n\ntriamesh_ iso : : mesher the_mesher;\n\n# with:\n\ntriamesh_aniso : : mesher the_mesher;\n\nand you get the same meshes25.\n\n25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower).\n\n| CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 39 tutorials |\n| --- | --- |\n\n\nTo benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.\npositive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these\nmatrices as in the following example.\n\n![image](/image/placeholder)\n\n\nFigure 24 - Anisotropic meshes (T3 and Q4).\n\nHere a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the\nprevious section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We\nneed also specify that we want a different size along the normals than along the tangents of the boundary lines\n(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :\n: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and\ngenerates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node\nNi, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the\nhorizontal direction27:\n\nmeshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;\n\n26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4.\n\n27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in\nmetrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi\nis replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.\nNote also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.\nThis property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four\nsummits of the square.\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40 |\n| --- |\n\n\n# #include \"stdafx.h\"\n\nint main()\n\n{\n\n| const double | L(10.) ; |\n| --- | --- |\n| const double | hx(1.) ; |\n| const double | Y size at bottom line. h0y(hx) ;  |\n| const double | Y size at top line. h1y(hx / 20.) ; |\n| const DoubleVec2 | P0(0 . 0.) ; , |\n| const DoubleVec2 | P1(L, 0.) ; |\n| const DoubleVec2 | P2(L, L); |\n| const DoubleVec2 | P3(0 · , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connect1, connect2, connect3, connect4, connectE; |\n| UIntMat | connectM; |\n| DoubleMat | metrics; |\n\n\n11 UNLOCK THE DLL.\ntriamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\n11 VERTICES\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back(P2) ;\npos . push_back(P3) ;\n\n11 BOTTOM LINE\nindices. clear () ;\nmeshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect1) ;\nconnectE.push_back (connect1) ;\n\n11 RIGHT-SIDE LINE\n\nindices.clear() ;\nmeshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect2) ;\nconnectE.push_back (connect2) ;\n\n11 LEFT-SIDE LINE\n\nindices.clear() ;\nmeshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect3) ;\nconnectE.push_back (connect3) ;\n\n11 TOP LINE\nindices.clear() ··\nmeshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect4) ;\nconnectE.push_back(connect4) ;\n\n11 METRICS\n\n| meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ; |\n| --- |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ; |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics); |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ; |\n\n\n11 2D MESH\n\ntriamesh_aniso : : mesher the_mesher;\ntriamesh_aniso: : mesher: :data_type data (pos, connectE2) ;\ndata. metrics = metrics;\nthe_mesher · run(data) ;\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;\n\nreturn 0;\n} 11 main\n\nAs already stated, except for the metrics array, the anisotropic meshers have the very same options and\nparameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,\nshared boundaries, background meshes...\n\nThe following example illustrates the internal hard line feature.\nWe have specified a normal size along the inner circle much smaller than the default tangent size (using again\nmeshtools1d : : metrics_gen_aniso2d).\n\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials |\n| --- | --- |\n\n\nFor the external square, nothing was specified in the metrics array and the mesher used its default isotropic\nmetrics based on the length of the adjacent edges.\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 25 - 2-D anisotropic meshes (T3 and all-Q4).\n\nThe example below is mesh of Figure 21 revisited the anisotropic way.\nHere we specify a small size in the directions normal to the three lines but a uniform size along the tangents.\nThe normal sizes follow the same kind of Gaussian variation.\nAll these metrics are specified at the nodes of the same uniform background mesh.\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 26 - 2-D anisotropic meshes (T3 and all-Q4).\n\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials |\n| --- | --- |\n\n\n# 11. 3-D surface meshes (aniso meshers only)\n\nThe four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso\nand CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.\nTo generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a\ntemplate function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or\nCM2 QuadMesh Aniso):\n\ntemplate <class Surface, class AnisoMesher, class AuxMesher>\nint\nmeshtools2d : : mesh_surface_param\n\n(const Surface& S, AnisoMesher& mesher2D,\n\ntypename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,\ndouble max_ chordal_error, double min_h, unsi gned chordal_control_type,\nunsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,\ndoub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,\nunsi gned max_ bgm_remeshings = 4\nbool recompute_Qs_flag = true, bool compute_area_flag = true) ;\n\nThis function can be used as in the following code sample:\n\n| <table><thead></thead><tbody><tr><td>tri amesh_aniso: :mesher amesh_iso : :mesher</td><td>the_mesher; aux_mesher;</td></tr><tr><td>tri tri amesh_ani so: :mesher: :data_type surface_type</td><td>data (pos, connectE2) ; S(some parameters) ; 11 A parametric surface.</td></tr></tbody></table> |\n| --- |\n| meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ; |\n\n\nThe class Surface for parameter S is a concept of parametric surface with members:\n\nint get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;\nint get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const;\nint get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;\nint get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;\n\nThe Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points\nlocated on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in\ncolumn #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)\nwhen failed.\n\nThe Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give\nthe coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in\ncolumn #j of pos3D must be returned in column #j of pos2D. This function should return zero when\nsuccessful and a negative value (-1 for instance) when failed.\n\n28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear\nsearch. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is\nnot called for the new nodes generated inside the surface by the mesher.\n\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n\n\nnodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices\nof the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix\ndata3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.\nThis array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before.\n\naP aP\nThe Surface : : get_ tangents member should compute the two tangents Bu = and Bv =\nau av\non the surface at a set of points given by their reference coordinates.\n\nThese tangents must not be normalized. They are the mere derivatives of the surface with respect to two\nreference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T\n(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),\nthen the next three are for the second tangent29.\n\nThe Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given\nby their reference coordinates (optional).\n\nThe curvatures H are 2 X 2 symmetric matrices defined as:\n\na2P\n· Huu du2 N)\nDot product between the derivative of Bu (first local tangent) with respect to u,\nand the normal N to the surface.\n\nO2P\n· Huv = N\ndu av\nDot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv\n(second local tangent) with respect to u, and the normal N to the surface.\n\n�2P\n· Hw = N\nav2\nDot product between the derivative of Bv (second local tangent) with respect to V,\nand the normal N to the surface.\n\nThese three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.\nuu\n\nYou can leave the implementation of this member empty (returning -1 for instance). In this case approximate\ncurvatures computed from variations of the tangents will be used instead.\n\n29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some\nsingularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to\nthe true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute\nthe target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and\nreplace them with a default one.\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials |\n| --- | --- |\n\n\nThe template class AnisoMesher is a concept of triangle anisometric mesher with function:\n\nvoid run (typename AnisoMesher: :data_type& data) const;\n\nThe mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers\nCM2 TriaMesh Aniso or CM2 QuadMesh Aniso.\n\nThe data3D parameter is the structure gathering all the input and output data, just like for any other\nunstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:\n: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher\nused. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D\nanisotropic metrics (dimensions 6 X NODS).\n\n3D-anisotropic metrics are defined as below:\n\n$${\\cal M}_{j}=\\left[\\frac{a}{b}\\begin{array}{c c c}{{b}}&{{d}}\\\\ {{c}}&{{c}}&{{e}}\\\\ {{d}}&{{e}}&{{f}}\\end{array}\\right]$$\n\nwith:\n\na > 0\nac - b2 > 0\nDet (M ) >0\ni.e. the three eigen values are > 0\n\n![image](/image/placeholder)\na\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j\n\nFigure 27 - Definition and storage of the 3-D anisotropic metrics.\n\nLet (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:\n\n$$\\begin{array}{l}{\\left\\|\\mathbf{v}_{0}\\right\\|=\\left\\|\\mathbf{v}_{1}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=1}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{2}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1},\\mathbf{v}_{2}\\right)=1}\\end{array}$$\n\n# Then, the metrics Mi writes:\n\n$$M_{j}=\\mathbf{B}\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h_{0}^{~2}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\frac{1}{h_{1}^{~2}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h_{2}^{~2}}}}\\end{array}\\right]$$\n\nT B\n\nwith:\n\nB = [vo V1 v2]\nstored column - wise\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials |\n| --- | --- |\n\n\nThe 3-D metric equivalent to an isotropic size of h writes:\n\n$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$\n\nA null matrix would lead to infinite sizes in the three directions (infinite sphere).\n\nThe two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error\nbetween the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the\nHTML reference manual for more information on them.\n\nThis first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric\nsurface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit\nsquare [0 1] X [0 1].\n\n![image](/image/placeholder)\n✓\n+ P(x,y,z)\nQ(u,v)\nu\n\nFigure 28 - Mapping between the reference space and the surface.\n\nThe source of this example is as follow:\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials |\n| --- | --- |\n\n\n#include \"stdafx.h\"\n\n/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface\n\n{\n\n11 Constructor (parameters to define the surface should be passed here) ·\nsurface (double Lx, double Ly, double a = 0.5)\n\n_Lx(Lx) , _Ly(Ly) , _a(a) {\n\n:\n\n}\n\n11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const\n\n{\n\nconst size_t NODS(pos2D.cols()) ;\ndouble u, ✓ , X , y , z;\n\nif (pos2D.rows() != 2) return -1; 11 Error.\n\nif ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nu = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = u * _Lx;\ny = ✓ * _Ly * (1. + _a * : :sin(x)) ;\nZ = 0. ;\npos3D(0, j) = x;\npos3D(1, j) = y;\npos3D(2, j) = z;\n\n}\n\nreturn 0; 11 OK.\n\n}\n\n11 Computes the reference coordinates (UV) · nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const\n\n{\n\nconst size_t NODS(pos3D.cols()) ;\ndouble u, ✓ , X , y;\n\nif (pos3D.rows() != 3) return -1; 11 Error.\n\nif ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nX = pos3D(0, j) ;\ny = pos3D(1, j);\nu = X / Lx;\n✓ = y / (_Ly * (1. + _a * : :sin(x))) ;\npos2D(0, j) = u;\npos2D(1, j) = V;\n\n}\n\nreturn 0; 11 OK.\n\n}\n\n111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const\n\n{\n\nconst size_t NODS(pos2D.cols());\ndouble u, ✓ , x;\n\nif (pos2D.rows() く 2) return -1; 11 Error.\n\nif ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nu = pos2D(0, j) ;\n✓ = pos2D(1, j);\nX = u * _Lx;\nT(0, j) = _Lx;\nT(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials |\n| --- | --- |\n\n\nT(2, j) = ⊙ , ;\nT(3, j) = 0. ;\nT(4, j) = _Ly * (1. + _a * : :sin(x)) ;\nT(5, j) = 0. ;\n\n}\n\nreturn 0; 11 OK.\n\n}\n\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n\n{\n\nconst size_t NODS(pos2D.cols()) in\n\nif (pos2D.rows() く 2) return -1; 11 Error.\n\nif ((H. rows() != 3) 11 (H.cols() く NODS))\nH. resize(3, NODS) ;\n\nH = ⊙ · ; 11 Null curvatures here (the surface is plane) ·\nreturn 0;\n\n}\n\n111 Data members.\ndouble _Lx, _Ly, _a;\n\n}; 11 surface\n\n111\nint main()\n\n{\n\n| const | DoubleVec2 | PO(0. , -0.5) | ; |\n| --- | --- | --- | --- |\n| const | DoubleVec2 | P1(1 · , -0.5) | ; |\n| const | DoubleVec2 | P2(1 . , +0.5) ; |  |\n| const | DoubleVec2 | P3(0 · , +0.5) ; |  |\n| DoubleMat |  | pos; |  |\n| UIntVec |  | indicesG, indices; |  |\n| DoubleVec |  | Us; |  |\n| UIntMat |  | connectE2, connectM; |  |\n| DoubleVec |  | sizesG, sizes; |  |\n| const | double | Lx (10.) ; |  |\n| const | double | Ly(6.0) ; |  |\n| const | double | h0 (0.25) ; |  |\n| surface |  | S(Lx, Ly, 0.5) ; 11 The parametric surface to be |  |\n\n\nmeshed.\n\n11 UNLOCK THE DLLs.\ntriamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;\n,\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n\npos . push_back(P0) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\n\n11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.\nmeshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;\nS. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·\n\n11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.\nsizesG. clear() ;\nsizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.\nmeshtools1d: :mesh_line(pos, indicesG, sizesG, true,\n1, UINT_MAX, O. , , indices, Us, sizes) ;\n⊙ .\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;\n\n11 MESH THE SURFACE.\n\ntriamesh_aniso: : mesher the_mesher, aux_mesher;\ntriamesh_aniso: : mesher: :data_type data(pos, connectE2) ;\nmeshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;\ndata.extract(pos, connectM) ;\n\n| TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 Ⓡ & Iso/Aniso - 48 tutorials |\n| --- | --- |\n\n\n# data.print_info (&display_hdl) ;\n\n/ / VISUALISATION.\nmeshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;\n\nreturn 0;\n} / / main\n\nWe present below the intermediate anisotropic meshes on the reference space (normally not shown) and the\nfinal meshes on the parametric surface.\n\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 29 - 2-D anisotropic meshes in the reference space (UV).\n\n![image](/image/placeholder)\n↓ ↓\n\nFigure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space.\n\nThe next example is a true 3-D parametric surface (only the source code for the surface class is shown).\n\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials |\n| --- | --- |\n\n\n# #include \"stdafx.h\"\n\n/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface\n\n{\n\n11 Constructor.\nsurface (double L, double H) : _L(L) , _H(H) { }\n\n11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const\n\n{\n\nconst size_t NODS(pos2D.cols());\ndouble u, V, x, y , z;\n\nif (pos2D.rows() く 2) return -1; 11 Error.\n\nif ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nu = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = L * u;\ny = 人 L * ✓;\nZ = _H * : : cos (x) * : :cos (y) ;\npos3D(0, 1) = x;\npos3D(1, j) = y ;\npos3D(2, j) = z;\n\n}\n\nreturn 0; 11 OK.\n\n}\n\n11 Computes the reference coordinates (UV) . nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const\n\n{\n\nconst size_t NODS(pos3D.cols());\ndouble u, V, x, y;\n\nif (pos3D.rows() く 2) return -1; 11 Error.\n\nif ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nX = pos3D(0, j) ;\ny = pos3D(1, j) ;\nu = X / _L;\n✓ = y / _L :\npos2D(0, j) = u;\npos2D(1, j) = V;\n\n}\n\nreturn 0; 11 OK.\n\n}\n\n111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const\n\n{\n\nconst size_t\n\nNODS(pos2D.cols());\n\ndouble\n\nu, ✓ , X , y;\n\nif (pos2D.rows() く 2) return -1; 11 Error.\n\nif ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;\n\nfor (size_t j = 0; j く NODS; ++j)\n\n{\n\nu = pos2D(0, j) ;\n\n✓ = pos2D(1, j) ;\n\nX = L * u;\n\nL * V;\n\ny =\n\nT(O, j) =\n\n� ;\n\nT(1, ]\n\n= 0.\n\nT(2, ]\n\n= - H * _L * : :sin(x) * : :cos (y) ;\n\n,\n\nT(3, ] ) = 0. F\n\n= L ;\n\nT(4, J\n\nT(5, j) = - H * _L * : :cos (x) * : :sin(y) ;\n\nreturn 0;\n\n}\n\n11 OK.\n\n}\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface.\n\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials |\n| --- | --- |\n\n\n![image](/image/placeholder)\n\n\n![image](/image/placeholder)\n\n\nFigure 31 - 2-D anisotropic meshes in the reference space (UV).\n\n![image](/image/placeholder)\n↓ ↓\n\nFigure 32 - 3-D surface meshes (T3 and all Q4).\n\nNotes:\n\n- · This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface\n- is available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2\n- SurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).\n- For more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.\n- · When there is only a discrete representation of the surface available (such as a tessellated surface), a\n- different method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and\n- CM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.\n- For more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.\n- · A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing.\n\n\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 53 |\n| --- | --- | --- |\n\n\n# COMPUTING\nOBJECTS", "text": "COMPUTING\nOBJECTS\nCM2 TriaMeshⓇ Iso/Aniso\nCM2 QuadMesh � Iso/Aniso\nVersion 5.6\ntutorials\nRevision February 2025.\nhttps://www.computing-objects.com\nⒸ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France.\nForewords\nThis manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:\n· The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,\n· The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso.\nAll these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well\nas the internal hard edges and hard points (embedded) are kept unmodified in the final mesh.\nBased on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality\nelements with smooth grading sizes according to the length of the boundary edges or to the user-specified\nsizes. The speed is near independent of the number of the elements to be generated.\nSetting switches can be used to adapt the meshers to the various needs of the user concerning mesh\ngeneration, refinement and optimization (they can also be used as optimizer-only of some already existing\nmeshes).\nThe quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes.\nMany data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the\nneighbors, number of sub-domains, area...\nLike many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-\nthreaded (you can select in the settings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).\nData are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers.\nFor a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TriaMesh & CM2 QuadMesh - reference manual.\nThe source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.\nS.P.2001.000.20700 (23/05/2019) is regularly deposited since then.\nThe source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly\ndeposited since then.\nThe source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.\n| TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 2 tutorials |\n| --- | --- |\n\nTable of contents\nForewords. ...... 2\n1. Getting started - a simple square .......... ········· 5\nSome declarations 6\nAuthorization of the library........ 6\nContour mesh 7\n2. Square with an internal line.......... ...... 14\n3. Square with internal hole ....... 17\n4. Quadratic elements & high-order nodes ........ ........ 19\n5. Square with grading mesh size. ........ 21\n6. Square with an internal hard node ......... ....... 23\n7. Multiple meshes ........ ·········· 25\n8. Shared boundaries ......... ....... 28\n9. Background mesh ..... ······· 32\n10. Anisotropic meshes. ...... 38\n11. 3-D surface meshes (aniso meshers only) .... ...... 43\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials |\n| --- | --- |\n\nBefore meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter\nmostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One\nexample (Section 7) illustrates the case where the boundary mesh has been generated by other means and is\nsimply read from a file.\nEach example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).\nThe general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:\n: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.\nFile stdafx.h1:\nCM2 MESHTOOLS\n11\n#include \" meshtools. h\"\n#include \" meshtoo ls1d.h\"\n#include \" tri amesh_iso. h\"\n#include \" quadmesh_iso. h\"\n#include \" triamesh_aniso.h\"\n#include \"quadmesh_aniso.h\"\n| General purpose mesh routines |\n| --- |\n| To generate 1D meshes |\n| CM2 TriaMesh Iso |\n| CM2 QuadMesh Iso |\n| CM2 TriaMesh Aniso (Section 10 onlyly) |\n| CM2 QuadMesh Aniso (Section 10 |\n\nusing namespace cm2;\n/ Main cm2 namespace can now be omitted.\nRequired libraries2:\n· cm2math1\n· cm2misc\n· cm2meshtools\n· cm2meshtools1d\n· cm2meshtools2d\n· cm2triamesh_ iso\n· cm2quadmesh_ iso\n· cm2triamesh_aniso (Section 10 only)\n· cm2quadmesh_aniso (Section 10 only)\n1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_\niso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.\n2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are\nlib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib).\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n\n1. Getting started - a simple square\nThis first example is a regular mesh of a square. The four boundary segments are equally discretized with 10\nelements.\n#include \"stdafx.h\"\n#include <iostream>\n11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }\nint main()\n{\n| const double | L(10.); |\n| --- | --- |\n| const unsublevec2 | N(10) ; |\n| const Doub | PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\nmeshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;\n11 SOME OUTPUT INFO (OPTIONAL) .\ndata.print_info(&display_hdl) ;\n11 VISUALISATION (OPTIONAL) .\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\nThe resulting mesh is shown Figure 1.\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\nFigure 1 - Triangle mesh of a square.\nLet us explain this program line by line.\nSome declarations\nMatrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a\nUIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column\nnumber in matrix pos where the coordinates of this node can be found4.\nindices is a temporary vector.\nAuthorization of the library\nThe library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to\ntri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for\neach library: the name of your company or organization that has acquired the license and a secret code5. Note\nthat both strings are case sensitive and the registration call must be made each time the library is loaded into\nmemory and before the first run of the mesher.\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n3 See manual CM2 Math1 - overview.\n4 Recall that array indices are zero based (from 0 to N-1).\n5 Contact license@computing-objects.com for any licensing inquiry.\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials |\n| --- | --- |\n\nContour mesh\nThis is usually the heaviest part of the work for the user. In this example, we only use routines from the\nCM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it\nform a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos\ncontaining the points' coordinates and the connectivity matrix connectB of the boundary edges.\nFirst, the corners of the square are created as four pair of coordinates in the pos matrix:\npos · push_back(P0) ;\npos · push_back(P1) ;\npos . push_back(P2) ;\npos . push_back(P3) ;\nThe push_back function appends a new column at the end of a matrix. The size of the column must match the\ncurrent number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows.\nAfter these four push-backs, the dimensions of the pos matrix are 2 X 4.\n| meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ; |\n| --- |\n| meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ; |\n\nNow that the four corners are present, we can create the points in between and the associated edges:\nThe mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new\nappended columns in the pos matrix:\nmeshtoo ls1d : : mesh_straight\n(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;\nThe index of each point, i.e. the column in matrix pos, is also appended to the vector indices.\nWith i0 = 0 and i1 = 1, this vector contains upon exit of this function:\n[0 4 5 6 7 8 9 10 11 12 1]\nAnd the matrix pos is now of size 2 X 13:\n![image](/image/placeholder)\n- Chart Type: line\n|  | Four corners | New generated nodes |\n| --- | --- | --- |\n| item_01 | 12 | 12 |\n\n6 See Section 5, \"Square with Grading Mesh Size\".\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025 | 7 tutorials |\n| --- | --- |\n\nThe last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:\nindices · pop_back() ;\nThe second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:\n[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]\nAfter the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index\nequals to the first, here zero, to close the contour7.\nThe vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\nThe connectB matrix has now dimensions 2 X 40:\n2x40 [0 4 5 6 7 · · · 39\n4 5 6 7 8 · · · 0]\nNow that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a\ndata structure holding this 1-D mesh and make the mesher run on it:\ntriamesh_iso : : mesher : :data_type data (pos, connectB) ;\nthe_mesher · run (data) ;\nThis constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos\nand data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated\ninside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40\npoints are left untouched in the first 40 columns.\nThe connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of\nthe nodes for an element8. connectM(i, j) is the ith local node of the jth element.\n7 The same result could have been achieved with:\nUIntVec hard_nodes (5) ;\nhard_nodes [0] = 日;\nhard_nodes[1] = 1;\nhard_nodes[2] = 2;\nhard_nodes[3] = 3;\nhard_nodes [4] = 日;\nmeshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;\nThis variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes).\n8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule).\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n\nPrinted information about the generated mesh and a MEDIT9 output file are obtained with:\ndata.print_info(&display_hdl) ;\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;\nHere is the output given by data.print_ info(&display_hdl) :\n![image](/image/placeholder)\n* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙\nFigure 2 - Output info for the square example.\nThe generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges\n(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,\noptimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.\nIn the second step new nodes are generated inside the domain to get elements with good shape and size.\nFinally, the last step is for geometrical and topological optimizations to improve the quality of the elements.\n9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront\nOBJ.\n10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270\nV2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh\nAniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso).\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials |\n| --- | --- |\n\nThe formula used to compute the shape quality of a triangle writes:\n| S | S | Area of the triangle. |\n| --- | --- | --- |\n| Qs = 4V3 L P | L with: max | Length of the longest edge of the triangle. |\n| max | P | Perimeter of the triangle. |\n\nThis quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.\nOn the square example, the worst shape quality is 0.83 and the average is 0.94.\nThe size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates\nthat the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,\nand a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as\nit should be (and should have been split).\nThe formula used to compute the length quality of an edge AB writes:\nIn\n hB\n �AB = L\n AB\n hA -h�\nAB\nL\nwith:\nh\nActual length of edge AB.\nA\nTarget size at node A (expected edge length at A).\nh B Target size at node B (expected edge length at B).\nLet's introduce also at this point the h-shock measure of an edge:\n1\n hs AB h hB QAB\n = min -1\n hB hA\nThese two measures are dimensionless and positive.\nWhen hA = hB the h-shock is null and the length quality simply writes QAB\nAB\nL\nhA\nWhen QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB.\nTo optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.\nThe histogram of the size qualities can be computed either inside the mesher by raising the flag settings .\ncompute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :\n: edge_qualities.\n11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options.\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 10 tutorials |\n| --- | --- |\n\nOn the square example, the size qualities are well centered on the value 1 with a small variance:\n![image](/image/placeholder)\n* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙\nFigure 3 - Histogram of the size-qualities of all the edges in the square example.\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials |\n| --- | --- |\n\nTo mesh with quadrangles all is needed is to change the class of the mesher:\n#include \"stdafx.h\"\n#include <iostream>\n11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }\nint main()\n{\nconst\nconst\nconst\n| double | L(10.); |\n| --- | --- |\n| unsi gned | N(10) ; |\n| Doub leVec2 | PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; , |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso : :registration(\"Licensed to SMART Inc .\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos · push_back(P2) ;\npos . push_back (P3) ;\nmeshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;\nmeshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n| 11 THE 2D MESH. |  |\n| --- | --- |\n| quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ; | the_mesher; data (pos, connectB) ; |\n\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;\nreturn 0;\n11 main\n}\nIn this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12.\n12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4.\n| QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials |\n| --- | --- |\n\nFigure 4 - Square meshed with quads.\nFor a plane quadrangle, we use the following measure of the shape quality:\n| S | S min | Minimum area of the four triangles. |\n| --- | --- | --- |\n| Qs = 8V2 min | with: L | Max length of the four sides and the two diagonals. |\n| L P max | max P | Perimeter of the quad. |\n\nThis measure gives the maximal value 1 only for a square.\nThe size quality is given by the same measure as for the triangles (because it is based on edges only).\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials |\n| --- | --- |\n\n2. Square with an internal line\nStarting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(10.), R(3.) ; |\n| --- | --- |\n| const Doubtevec2 | N1(10) , N2(20) ; |\n| const Doub | PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ; |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | pos ; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\ntriamesh_iso: : registration(\"Licensed to SMART Inc .\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos · push_back (P1) ;\npos . push_back(P2) ;\npos · push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on\nmeshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d : : indices_ to_connectE2(indices, connectB) ;\nindices.clear();\nmeshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;\nindices.back() = indices. front();\nmeshtools1d::indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_iso: :mesher the_mesher;\ntriamesh_iso: : mesher::data_type data (pos, connectB) ;\nthe_mesher. run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n- Chart Type: line\n|  | Red | Blue | Green | Yellow | Purple | Orange |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 12 | 8 | 5 | 4 | 3 |\n\n![image](/image/placeholder)\n\nFigure 5 - Square with internal line (T3 and all-Q4).\nThe mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation\nis defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �.\nThe circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point\n#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to\nreplace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only\ncoincident17:\nindices. back() = indices. front() ;\nAs for the external contour, these indices are converted into edges with the indices_ to_connectE2\nfunction and appended to the connectB matrix.\nAgain, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,\nif we accept some triangles we can get a better mesh.\n13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.\n14 Note that the coordinates at column 24 in the pos matrix will remain unused.\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials |\n| --- | --- |\n\nHere with CM2 QuadMesh� Iso in quad-dominant mode:\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(10) , R(3.) · |\n| --- | --- |\n| const unsigned | N1(10), N2(20); |\n| DoubleMat | pos; |\n| const DoubleVec2 | 0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R; |\n| const DoubleVec2 | L/2); |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n\n11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso: : registration(\"Licensed to SMART Inc .\n,\n11 VERTICES AND LINE MESHES.\npos. push_back (PO) ;\npos . push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d: :indices_to_connectE2(indices, connectB) ;\nindices.clear() ;\nmeshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;\nindices. back() = indices. front() ;\nmeshtools1d: :indices_to_connectE2 (indices, connectB) ;\n11 THE 2D MESH.\nquadmesh_iso: :mesher the_mesher;\nquadmesh_iso: :mesher: :data_type data(pos, connectB) ;\nthe_mesher.settings.all_quad_flag = false;\nthe_mesher run(data) ;\n11 VISUALIZATION.\nmeshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;\nreturn 0;\n} 11 main\n![image](/image/placeholder)\n- Chart Type: pie\n|  | Purple | Orange | Red | Blue | Green |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 20% | 20% | 20% | 20% | 20% |\n\nFigure 6 - Square with internal line (quad-dominant mode).\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials |\n| --- | --- |\n\n3. Square with internal hole\nA hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that\nthis implies that all edges of the external contour should be oriented in a uniform way (either clockwise or\ncounter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert\nthe orientation of the internal edges and thus to remove the disk from the domain:\nmeshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;\nAnd the resulting meshes:\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 7 - Square with a circular hole (T3 and all-Q4).\n15 Without any closed internal hard line, the orientation of the external contour is irrelevant.\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials |\n| --- | --- |\n\nOne can nest alternatively positive and negative rotations:\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 8 - Concentric circles with alternate orientation (T3 and all-Q4).\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials |\n| --- | --- |\n\n4. Quadratic elements & high-order nodes\nLet us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we\nwould like also the edges along the circular hole to be curved.\nFor that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :\n: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic.\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(10.), R(3.) in |\n| --- | --- |\n| const unsigned | N1(10); N2(20) �.), |\n| const Doub [eVec2 | P2(L, L) , P3(0 * , L) ; P1(L, |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | indices; |\n| UIntVec |  |\n| UIntMat | connectB, connectE2; |\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos · push_back (PO) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos · push_back (P3) ;\nmeshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;\n. push_back (P4) ;\nmeshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on\nmeshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;\nmeshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\nmeshtools1d: : convert_into_quadratic(pos, connectB);\nindi ces. clear () ;\nmeshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;\nindi ces. back() = indi ces. front() ;\nmeshtools1d: :indices_ to_connectE3(indices, connectB) ;\nconnectE2.copy (connectB) ;\nmeshtools1d: :convert_into_linear (connectE2) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here.\nthe_mesher. run (data) ;\nmeshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;\nreturn 0;\n} 11 main\nTo keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter\n(this will create new high-order nodes, different from those in connectB):\nmeshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;\n16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_\norder · Refer to the HTML reference manual for detailed information.\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n\nThis would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity\nmatrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly\ninterpolated between the initial vertices, all the edges would remain straight.\nThis is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity\nmatrix of the boundary edges (or some of them) is usually required later to setup boundary conditions\n(Dirichlet, Neumann...)\nSo, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-\nnode edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):\nmeshtools1d : : convert_into_quadratic (pos, connectB) ;\nThe connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are\nunchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17).\n0\nlinear nodes\n1\n|  | 1 | 2 3 | 4 | 6 | 8 | 10 |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 2 | 3 | 4 | 5 7 | 9 | 11 |\n| 12 | 13 | 14 | 15 | 16 17 | 18 | 19 |\n\nFigure 9 - Example of connectivity matrix for quadratic edges and view to linear edges.\nFor the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence\nof node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).\nThis is possible because we have generated along the circle twice as much nodes as in the previous example\n(extrude_rotate with 2 N2).\nNow we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along\nthe circle.\nHowever, the mesh generators accept only linear edges upon entry and give only linear face elements upon\nexit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called\nconnectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear\nedges with convert_ into_ linear.\nAfter the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes\nalong the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity\nmatrix connectB created before:\nmeshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;\nThis forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match.\n17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them.\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 20 tutorials |\n| --- | --- |\n\n5. Square with grading mesh size\nThere are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along\nthe boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates\nthese values inside the domain and generates elements accordingly.\nTo illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of\nthe contour we specify different mesh sizes on each four vertices:\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(10.); |\n| --- | --- |\n| const unsi gLevec2 | N(10).3, |\n| const Doub | P1(L, 0.) , P2(L, L), P3(0. , L) ; |\n| DoubleMat | indices |\n| UIntVec | , hard_nodes (5) ; |\n| DoubleVec | sizes(5); |\n| UIntMat | connectB; |\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos · push_back (PO) ;\npos · push_back (P1) ;\npos . push_back (P2) ;\npos · push_back(P3) ;\nhard_nodes [0] = 0; sizes [0] = 0. 1*L/N;\nhard_nodes [1] 1; sizes [1] = 2. 0*L/N;\nhard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;\nhard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;\nhard_nodes [4] = 0; sizes [4] = 0. 1*L/N;\nmeshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n11 main\n}\nThis variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal\nline) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best\nthe target values on the four corners.\nThese target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used\nto compute the 2-D size map.\n18 By averaging the lengths of the adjacent edges to each hard node.\n| TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 & CM2 - 21 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 10 - Meshes with grading size (T3 and all-Q4).\nThe second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some\nhard nodes. This is explained in the next section.\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials |\n| --- | --- |\n\n6. Square with an internal hard node\nSo far, we have seen only three fields of the structure used to exchange data with the mesher:\n· The pos matrix for the coordinates of the points.\n· The connectB matrix for the connectivity of the hard edges.\n· The connectM matrix for the connectivity of the 2-D mesh.\nIn this example we add an isolated hard node at the center of the square and specify a target size on it. This will\nbe done using the two new fields isolated_nodes and metrics:\n![image](/image/placeholder)\n#include \"stdafx.h\"\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\nWe have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is\npushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be\nhonored in the final mesh.\nThe vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or\nnot present- a default value will be used instead19.\nIn our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10\ntimes finer mesh around it.\n19 For an isolated node, the default computed size is based on the size value of the nearest nodes.\n| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 23 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 11 - Mesh concentration near a hard node (T3 and all-Q4).\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials |\n| --- | --- |\n\n7. Multiple meshes\nThe matrix connectB can contain internal lines. It can also contain several external disconnected contours (to\nmesh several disconnected domains simultaneously). Some care must be taken however in the orientation of\nthese contours. For multiple domains, the edges of all external contours must be oriented the same way, for\ninstance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect\neach other.\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 12 - Multiple meshes (T3 and all-Q4).\nThe four sub-domains are meshed simultaneously.\nIn this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:\n![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm(\"cards.dat\") ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( \"out.mesh\" , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main\n20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines.\n| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 25 tutorials |\n| --- | --- |\n\nThe input boundary meshes are read from an ASCII file with cm2 : : matio: :read21\nThe format for the matrices is:\n| n X m | [ {LinL_0003} |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n| dn-1, 0 |  | dn-1,1 | dn-1,2 · | · · | dn-1,m-1 | ] |\n\nThe format for each component of the matrix is free.\nFor instance a 2 X 4 Doub leMat can be stored as:\n2 X 4 [\n0 0.5 1 2.0\n0 1 1 2.E-1]\nNotes:\n· We can see in this example that the meshes may not always be symmetric even with a symmetric contour.\n· We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-\ndomain to be meshed in a structured manner.\n21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.\nThis can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files.\n| CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 26 tutorials |\n| --- | --- |\n\nAs an exercise we can get the same result by making four successive meshes and concatenating the results:\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\n| std: :ifstream | istrm |\n| --- | --- |\n| UIntMat | connectM; |\n| DoubleMat | pos; |\n\n\" \"F53EA108BCWX\") ;\ntriamesh_iso : : registration(\"Licensed to SMART Inc . ,\ntriamesh_ iso : : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data;\nistrm. open(\"heart.dat\") ;\nmatio : : read (istrm, data · pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\nistrm. open(\"spade.dat\") ;\nmatio: : read(istrm, data . pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher ・ run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\nistrm. open(\"diamond. dat\") ;\nmatio : : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run(data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;\nistrm. open(\"club. dat\") ;\nmatio: : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; / / Shift indices.\npos. push_back(data.pos) ;\nconnectM.push_back(data.connectM) ;\nmeshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials |\n| --- | --- |\n\n8. Shared boundaries\nEdges can be shared between some contours and lines. In this case some edges are defined several times\n(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more\nconvenient for the user to generate the 1-D meshes of the contours independently from each other. That\nusually implies duplicated nodes on the shared contours.\nThe following example deals with such a case.\nConsider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared\nbetween sub-domains but with different orientation. We also want to mesh the contours of the sub-domains\nindependently from each other but without any duplicated nodes.\n![image](/image/placeholder)\n- Chart Type: line\n|  | P0 | P | P3 | P4 | P5 | P6 |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 1 | 1 | 1 | 1 | 1 | 1 |\n\nFigure 13 - Domain composed of three attached sub-domains.\nThe shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict\nmode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes\ncan be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,\nthe mesher may not be able to tell the sign of the inner square, and that can lead to a hole.\nThe solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials |\n| --- | --- |\n\n#include \"stdafx.h\"\nstatic void mesh_segment\n(DoubleMat& pos, UIntMat& connectB,\nunsigned start_index, unsigned stop_index, unsigned num_edges)\n{\nUIntVec indices;\nmeshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;\n}\nint main()\n{\n| const DoubleVec2 | PO (0., | 0.), | P1(10. , 0.), | P2(10. , 2.) , |  |  | P3(8. , 2.) ; |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| const DoubleVec2 |  | P4 (2. , 2.), |  | P5(0. , 2.) , | P6(10. , 10. ) , | P7(0. , | 10.) ; |\n| const DoubleVec2 |  | P8 (2., 8.) | , | P9 (8. , 8.) ; |  |  |  |\n| const unsi gned |  | N(4) ; |  |  |  |  |  |\n| DoubleMat |  | pos; |  |  |  |  |  |\n| UIntMat |  | connectB; |  |  |  |  |  |\n\n11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES POINTS.\npos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;\npos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;\npos . push_back(P8) ; pos · push_back(P9) ;\n11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 日, 1, N) ;\nmesh_segment(pos, connectB, 1, 2, N) ;\nmesh_segment (pos, connectB, 2, 3, N) ;\nmesh_segment (pos, connectB, 3, 4, N) ;\nmesh_segment(pos, connectB, 4, 5, N) ;\nmesh_segment(pos, connectB, 5, 日, N) ;\n11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 2, 6, N) ;\nmesh_segment(pos, connectB, 6, 7, N) ;\nmesh_segment (pos, connectB, 7, 5, N) ;\nmesh_segment (pos, connectB, 5, 4, N) ·\nmesh_segment (pos, connectB, 4, 8, N) ·\nmesh_segment (pos, connectB, 8, 9, N) ;\nmesh_segment(pos, connectB, 9, 3, N) ;\nmesh_segment(pos, connectB, 3, 2, N) ;\n11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 3, 9, N) ;\nmesh_segment(pos, connectB, 9, 8, N) ;\nmesh_segment(pos, connectB, 8, 4, N) ;\nmesh_segment(pos, connectB, 4, 3, N) ;\n11 MERGE TOGETHER DUPLICATED NODES.\nmeshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;\n11 THE 2D MESH.\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_ type data (pos, connectB) ;\nthe_mesher · run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n11 main\n}\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials |\n| --- | --- |\n\nNote that this solution works because the shared edges are discretized similarly and the nodes are (almost)\ncoincident.\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n- Chart Type: bar\n|  | Red | Blue | Green | Purple | Cyan |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 10 | 10 | 10 | 20 |\n\nFigure 14 - Example with shared boundaries (T3 and all-Q4).\nNote that the contour of the inner square is oriented completely both ways (positive and negative). In such a\ncase, the mesher favors the positive orientation and keeps the inner sub-domain.\nA similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers\nthe inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external\ndomain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole).\n![image](/image/placeholder)\n\nFigure 15 - Example of ambiguous orientation of an inner contour.\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials |\n| --- | --- |\n\nHere is another example where a hole is adjacent to the external contour. In this case, the most external\ndomain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole).\n![image](/image/placeholder)\n\nFigure 16 - Hole adjacent to the external contour.\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n- Chart Type: bar\n|  | Dark Gray | Light Gray |\n| --- | --- | --- |\n| item_01 | 50 | 50 |\n\nFigure 17 - Example of ambiguous orientation of an inner contour.\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials |\n| --- | --- |\n\n9. Background mesh\nSometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.\nThe background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It's represented by the connectivity matrix background_mesh in the data of the mesher.\nAs always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or\nvectors (such as connectM or connectB).\nThe nodes of the background mesh can share nodes with connectB or can all be different. They must all have\na valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside\nthe background mesh.\nIn the following example, a regular structured background mesh is used to support a size map with a sinusoidal\nvariation in the two directions. The domain to be meshed is a simple square regularly discretized along its\nboundaries22.\n22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities.\n| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 32 tutorials |\n| --- | --- |\n\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(4.), h0 (0. 25) , h1 (0. 05) ; |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE2, connectT3, BGM; |\n| DoubleVec | sizes; |\n| unsigned | n; |\n| double | W, h; |\n\n11 UNLOCK THE DLL.\ntriamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos · push_back (DoubleVec2(-L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, +L/2)) ;\npos · push_back(DoubleVec2 (-L/2, +L/2))\nmeshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;\nindices. pop_back() ;\nmeshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;\n11 THE BACKGROUND MESH.\nn = unsigned(L/h1) ;\nindices.clear () ;\nmeshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;\nindices.pop_ back() ;\nmeshtools1d: :mesh_ straight(pos, 1, 2, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_ straight(pos, 2, 3, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;\nmeshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;\n11 THE METRICS ON THE BACKGROUND MESH.\nindices.clear();\nmeshtools: :unique_ indices(indices, BGM) ;\nsizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.\nfor (size_t i = 0; i く indices.size(); ++i)\n{\nn = indices[i];\nn)));\nW = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;\nh = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +\nsizes[n] = h;\n}\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;\ndata.background_mesh = BGM;\ndata. metrics = sizes;\nthe_mesher · run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).\nThe background mesh is the same structured triangle mesh in both cases (here, covering all the domain):\n![image](/image/placeholder)\n\nFigure 19 - The background mesh used in the previous examples.\nThe background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it\nand/or be partially outside of the domain. In the areas not covered by the background mesh, the default size\nfield based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead.\nHere is an example where the domain is a disk and the background mesh is also a disk but with half the radius.\nWe have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area.\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\nFigure 20 - Background mesh covering only a fraction of the domain.\nWe can also consider the case where the boundary mesh of the domain must also be governed by a\nbackground mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to\nsupport the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"\nand the associated sizes. The discretization for this 1D background mesh must be fine enough to represent\naccurately the geometry of the line.\nAn overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full\ncircle with 200 nodes in indices0 starting from node #1 and centered on point CR:\nmeshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;\nindices0 . back() = indices0. front();\nSizes are specified on the nodes of this circle and a new set of adapted nodes are generated:\nvecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.\nmeshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,\nUINT_MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectE) ;\nThe parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,\nmaximum of UINT_MAX edges along the arc and no chordal control21.\nThe indices vector now contains the nodes of the circle mesh adapted to the metrics.\nnew_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these\nnodes but these vectors are not used in the rest of the example.\n23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library.\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).\nNote: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it\nto a changed metrics map.\n24 See HTML reference manual for more info on these parameters.\n| QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials |\n| --- | --- |\n\n#include \"stdafx.h\"\nint main()\n{\n| const double | R(4.) ; |\n| --- | --- |\n| const double | h0(0.5) , h1(0.05) , sig(0. 40) ; |\n| const DoubleVec2 | CR(0 · 0.) , PO(R, 0.) ; , |\n| DoubleMat | pos; |\n| DoubleVec | new_U, sizes, sizes0, new_sizes; |\n| UIntVec | indices0, indices; |\n| UIntMat | connectE, connectM, BGM; |\n| double | x, y, W, wo, w1, w2; |\n\n11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;\n\"\n,\ntriamesh_iso : : mesher the_mesher;\npos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·\npos . push_back(P0) ; 11 Point #1 (start of the circle) ·\n11 THE 2D BACKGROUND MESH\nn = unsigned (2. *M_PI*R / h1) ;\nmeshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;\nindices. back() = indices · front() ; 11 Close the circle.\nmeshtools1d: : indices_ to_connectE2(indices, connectE) ;\ntriamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;\nthe_ mesher . run(BGMdata) ;\nBGMdata.extract(pos, BGM) ;\n11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·\nmeshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;\nindices0.back() = indices0.front();\n11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .\nindices.clear();\nmeshtools: :unique indices(indices, BGM) ;\nindices.push_back(indices0); 11 Also the nodes of the circle.\nsizes. resize(pos. cols() , 0.);\nfor (size_t i = 0; i く indices.size() ; ++i)\n{\nconst size_t n = indices[i] ;\nX = pos(0, n) ;\ny = pos(1, n) ;\nw⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;\nw1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;\nw2 = : : fabs (x + R/2) ;\nW = std : : min (wo, w1) ; sigil. Gaussian variations.\nW = std : : min (w, w2) /\nW = : :exp(-w*w) ;\nsizes[n] = = h0* (1. -w) + h1*w;\n}\n11 Pick-up the sizes along the circle.\nsizes0.clear();\nvecvec: :push_back(sizes, indices0, sizes0) ;\n11 MESH THE CIRCLE ACCORDING TO THE METRICS.\nindices.clear();\nconnectE.clear();\nmeshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,\nUINT MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d: :indices_to_connectE2(indices, connectE) ;\n11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.\ntriamesh_ iso: : mesher : : data_ type data(pos, connectE) ;\ndata.background_mesh = BGM;\ndata.metrics = sizes;\nthe_mesher run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials |\n| --- | --- |\n\n10. Anisotropic meshes\nCM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce\nequilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific\ndirections. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic\nunstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their\nisotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic\ncase we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined\nby a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array.\n![image](/image/placeholder)\nh1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right).\nMj = ab b\nc\nwith :\na > 0\nac - b2 > 0\ni.e. the two eigen values are > 0\ndata.metrics\na\n·\nb\n:\nc\ncolumn #j\nFigure 23 - Definition and storage of the 2-D anisotropic metrics.\nLet (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:\n[vo] = [v1] = 1\n<V0,V1>=0\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials |\n| --- | --- |\n\nThen the metrics Mj writes:\n1\n 0\n 2\n ho T\n M = B\n B\n j 1\n 0\n 2\n h\nwith :\nB = [vo v1]\nstored column - wise\nThe metric equivalent to an isotropic size of h writes:\n1\n 0\n h2\n M =\n i 1\n 0\n h2\nA null matrix would lead to infinite sizes in both directions (infinite circle).\nWhen the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic\ndefault metrics we have seen before. For each hard node the default metric is based on the length of the\nadjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for\ninstance examples 1, 2, 3 or 4 and replace:\ntriamesh_ iso : : mesher the_mesher;\nwith:\ntriamesh_aniso : : mesher the_mesher;\nand you get the same meshes25.\n25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower).\n| CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 39 tutorials |\n| --- | --- |\n\nTo benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.\npositive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these\nmatrices as in the following example.\n![image](/image/placeholder)\n\nFigure 24 - Anisotropic meshes (T3 and Q4).\nHere a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the\nprevious section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We\nneed also specify that we want a different size along the normals than along the tangents of the boundary lines\n(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :\n: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and\ngenerates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node\nNi, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the\nhorizontal direction27:\nmeshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;\n26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4.\n27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in\nmetrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi\nis replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.\nNote also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.\nThis property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four\nsummits of the square.\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40 |\n| --- |\n\n#include \"stdafx.h\"\nint main()\n{\n| const double | L(10.) ; |\n| --- | --- |\n| const double | hx(1.) ; |\n| const double | Y size at bottom line. h0y(hx) ;  |\n| const double | Y size at top line. h1y(hx / 20.) ; |\n| const DoubleVec2 | P0(0 . 0.) ; , |\n| const DoubleVec2 | P1(L, 0.) ; |\n| const DoubleVec2 | P2(L, L); |\n| const DoubleVec2 | P3(0 · , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connect1, connect2, connect3, connect4, connectE; |\n| UIntMat | connectM; |\n| DoubleMat | metrics; |\n\n11 UNLOCK THE DLL.\ntriamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back(P2) ;\npos . push_back(P3) ;\n11 BOTTOM LINE\nindices. clear () ;\nmeshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect1) ;\nconnectE.push_back (connect1) ;\n11 RIGHT-SIDE LINE\nindices.clear() ;\nmeshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect2) ;\nconnectE.push_back (connect2) ;\n11 LEFT-SIDE LINE\nindices.clear() ;\nmeshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect3) ;\nconnectE.push_back (connect3) ;\n11 TOP LINE\nindices.clear() ··\nmeshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect4) ;\nconnectE.push_back(connect4) ;\n11 METRICS\n| meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ; |\n| --- |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ; |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics); |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ; |\n\n11 2D MESH\ntriamesh_aniso : : mesher the_mesher;\ntriamesh_aniso: : mesher: :data_type data (pos, connectE2) ;\ndata. metrics = metrics;\nthe_mesher · run(data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\nAs already stated, except for the metrics array, the anisotropic meshers have the very same options and\nparameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,\nshared boundaries, background meshes...\nThe following example illustrates the internal hard line feature.\nWe have specified a normal size along the inner circle much smaller than the default tangent size (using again\nmeshtools1d : : metrics_gen_aniso2d).\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials |\n| --- | --- |\n\nFor the external square, nothing was specified in the metrics array and the mesher used its default isotropic\nmetrics based on the length of the adjacent edges.\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 25 - 2-D anisotropic meshes (T3 and all-Q4).\nThe example below is mesh of Figure 21 revisited the anisotropic way.\nHere we specify a small size in the directions normal to the three lines but a uniform size along the tangents.\nThe normal sizes follow the same kind of Gaussian variation.\nAll these metrics are specified at the nodes of the same uniform background mesh.\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 26 - 2-D anisotropic meshes (T3 and all-Q4).\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials |\n| --- | --- |\n\n11. 3-D surface meshes (aniso meshers only)\nThe four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso\nand CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.\nTo generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a\ntemplate function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or\nCM2 QuadMesh Aniso):\ntemplate <class Surface, class AnisoMesher, class AuxMesher>\nint\nmeshtools2d : : mesh_surface_param\n(const Surface& S, AnisoMesher& mesher2D,\ntypename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,\ndouble max_ chordal_error, double min_h, unsi gned chordal_control_type,\nunsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,\ndoub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,\nunsi gned max_ bgm_remeshings = 4\nbool recompute_Qs_flag = true, bool compute_area_flag = true) ;\nThis function can be used as in the following code sample:\n| {LinL_0007} |\n| --- |\n| meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ; |\n\nThe class Surface for parameter S is a concept of parametric surface with members:\nint get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;\nint get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const;\nint get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;\nint get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;\nThe Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points\nlocated on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in\ncolumn #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)\nwhen failed.\nThe Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give\nthe coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in\ncolumn #j of pos3D must be returned in column #j of pos2D. This function should return zero when\nsuccessful and a negative value (-1 for instance) when failed.\n28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear\nsearch. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is\nnot called for the new nodes generated inside the surface by the mesher.\n| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n\nnodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices\nof the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix\ndata3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.\nThis array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before.\naP aP\nThe Surface : : get_ tangents member should compute the two tangents Bu = and Bv =\nau av\non the surface at a set of points given by their reference coordinates.\nThese tangents must not be normalized. They are the mere derivatives of the surface with respect to two\nreference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T\n(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),\nthen the next three are for the second tangent29.\nThe Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given\nby their reference coordinates (optional).\nThe curvatures H are 2 X 2 symmetric matrices defined as:\na2P\n· Huu du2 N)\nDot product between the derivative of Bu (first local tangent) with respect to u,\nand the normal N to the surface.\nO2P\n· Huv = N\ndu av\nDot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv\n(second local tangent) with respect to u, and the normal N to the surface.\n�2P\n· Hw = N\nav2\nDot product between the derivative of Bv (second local tangent) with respect to V,\nand the normal N to the surface.\nThese three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.\nuu\nYou can leave the implementation of this member empty (returning -1 for instance). In this case approximate\ncurvatures computed from variations of the tangents will be used instead.\n29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some\nsingularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to\nthe true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute\nthe target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and\nreplace them with a default one.\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials |\n| --- | --- |\n\nThe template class AnisoMesher is a concept of triangle anisometric mesher with function:\nvoid run (typename AnisoMesher: :data_type& data) const;\nThe mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers\nCM2 TriaMesh Aniso or CM2 QuadMesh Aniso.\nThe data3D parameter is the structure gathering all the input and output data, just like for any other\nunstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:\n: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher\nused. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D\nanisotropic metrics (dimensions 6 X NODS).\n3D-anisotropic metrics are defined as below:\na b d\n M / = b c e\n d e f\nwith:\na > 0\nac - b2 > 0\nDet (M ) >0\ni.e. the three eigen values are > 0\n![image](/image/placeholder)\na\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j\nFigure 27 - Definition and storage of the 3-D anisotropic metrics.\nLet (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:\n|vo|=|va||v2|=1\n <V0,V1> =0\n <V0,V2> =0\n <V1,V2>=0\n <V0xV1,V2>=1\nThen, the metrics Mi writes:\n1\n 0 0\n 2\n ho\n 1\n M = B 0 0\n j 2\n h1\n 1\n 0 0\n 2\n h2\nT B\nwith:\nB = [vo V1 v2]\nstored column - wise\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials |\n| --- | --- |\n\nThe 3-D metric equivalent to an isotropic size of h writes:\n1\n 0 0\n h2\n 1\n M = 0 0\n i h2\n 1\n 0 0\n h2\nA null matrix would lead to infinite sizes in the three directions (infinite sphere).\nThe two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error\nbetween the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the\nHTML reference manual for more information on them.\nThis first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric\nsurface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit\nsquare [0 1] X [0 1].\n![image](/image/placeholder)\n✓\n+ P(x,y,z)\nQ(u,v)\nu\nFigure 28 - Mapping between the reference space and the surface.\nThe source of this example is as follow:\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials |\n| --- | --- |\n\n#include \"stdafx.h\"\n/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface\n{\n11 Constructor (parameters to define the surface should be passed here) ·\nsurface (double Lx, double Ly, double a = 0.5)\n_Lx(Lx) , _Ly(Ly) , _a(a) {\n:\n}\n11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const\n{\nconst size_t NODS(pos2D.cols()) ;\ndouble u, ✓ , X , y , z;\nif (pos2D.rows() != 2) return -1; 11 Error.\nif ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nu = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = u * _Lx;\ny = ✓ * _Ly * (1. + _a * : :sin(x)) ;\nZ = 0. ;\npos3D(0, j) = x;\npos3D(1, j) = y;\npos3D(2, j) = z;\n}\nreturn 0; 11 OK.\n}\n11 Computes the reference coordinates (UV) · nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const\n{\nconst size_t NODS(pos3D.cols()) ;\ndouble u, ✓ , X , y;\nif (pos3D.rows() != 3) return -1; 11 Error.\nif ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nX = pos3D(0, j) ;\ny = pos3D(1, j);\nu = X / Lx;\n✓ = y / (_Ly * (1. + _a * : :sin(x))) ;\npos2D(0, j) = u;\npos2D(1, j) = V;\n}\nreturn 0; 11 OK.\n}\n111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const\n{\nconst size_t NODS(pos2D.cols());\ndouble u, ✓ , x;\nif (pos2D.rows() く 2) return -1; 11 Error.\nif ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nu = pos2D(0, j) ;\n✓ = pos2D(1, j);\nX = u * _Lx;\nT(0, j) = _Lx;\nT(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials |\n| --- | --- |\n\nT(2, j) = ⊙ , ;\nT(3, j) = 0. ;\nT(4, j) = _Ly * (1. + _a * : :sin(x)) ;\nT(5, j) = 0. ;\n}\nreturn 0; 11 OK.\n}\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols()) in\nif (pos2D.rows() く 2) return -1; 11 Error.\nif ((H. rows() != 3) 11 (H.cols() く NODS))\nH. resize(3, NODS) ;\nH = ⊙ · ; 11 Null curvatures here (the surface is plane) ·\nreturn 0;\n}\n111 Data members.\ndouble _Lx, _Ly, _a;\n}; 11 surface\n111\nint main()\n{\n| const | DoubleVec2 | PO(0. , -0.5) | ; |\n| --- | --- | --- | --- |\n| const | DoubleVec2 | P1(1 · , -0.5) | ; |\n| const | DoubleVec2 | P2(1 . , +0.5) ; |  |\n| const | DoubleVec2 | P3(0 · , +0.5) ; |  |\n| DoubleMat |  | pos; |  |\n| UIntVec |  | indicesG, indices; |  |\n| DoubleVec |  | Us; |  |\n| UIntMat |  | connectE2, connectM; |  |\n| DoubleVec |  | sizesG, sizes; |  |\n| const | double | Lx (10.) ; |  |\n| const | double | Ly(6.0) ; |  |\n| const | double | h0 (0.25) ; |  |\n| surface |  | S(Lx, Ly, 0.5) ; 11 The parametric surface to be |  |\n\nmeshed.\n11 UNLOCK THE DLLs.\ntriamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;\n,\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\npos . push_back(P0) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\n11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.\nmeshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;\nS. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·\n11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.\nsizesG. clear() ;\nsizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.\nmeshtools1d: :mesh_line(pos, indicesG, sizesG, true,\n1, UINT_MAX, O. , , indices, Us, sizes) ;\n⊙ .\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;\n11 MESH THE SURFACE.\ntriamesh_aniso: : mesher the_mesher, aux_mesher;\ntriamesh_aniso: : mesher: :data_type data(pos, connectE2) ;\nmeshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;\ndata.extract(pos, connectM) ;\n| TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 Ⓡ & Iso/Aniso - 48 tutorials |\n| --- | --- |\n\ndata.print_info (&display_hdl) ;\n/ / VISUALISATION.\nmeshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;\nreturn 0;\n} / / main\nWe present below the intermediate anisotropic meshes on the reference space (normally not shown) and the\nfinal meshes on the parametric surface.\n| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 29 - 2-D anisotropic meshes in the reference space (UV).\n![image](/image/placeholder)\n↓ ↓\nFigure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space.\nThe next example is a true 3-D parametric surface (only the source code for the surface class is shown).\n| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials |\n| --- | --- |\n\n#include \"stdafx.h\"\n/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface\n{\n11 Constructor.\nsurface (double L, double H) : _L(L) , _H(H) { }\n11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const\n{\nconst size_t NODS(pos2D.cols());\ndouble u, V, x, y , z;\nif (pos2D.rows() く 2) return -1; 11 Error.\nif ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nu = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = L * u;\ny = 人 L * ✓;\nZ = _H * : : cos (x) * : :cos (y) ;\npos3D(0, 1) = x;\npos3D(1, j) = y ;\npos3D(2, j) = z;\n}\nreturn 0; 11 OK.\n}\n11 Computes the reference coordinates (UV) . nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const\n{\nconst size_t NODS(pos3D.cols());\ndouble u, V, x, y;\nif (pos3D.rows() く 2) return -1; 11 Error.\nif ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nX = pos3D(0, j) ;\ny = pos3D(1, j) ;\nu = X / _L;\n✓ = y / _L :\npos2D(0, j) = u;\npos2D(1, j) = V;\n}\nreturn 0; 11 OK.\n}\n111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const\n{\nconst size_t\nNODS(pos2D.cols());\ndouble\nu, ✓ , X , y;\nif (pos2D.rows() く 2) return -1; 11 Error.\nif ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;\nfor (size_t j = 0; j く NODS; ++j)\n{\nu = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = L * u;\nL * V;\ny =\nT(O, j) =\n� ;\nT(1, ]\n= 0.\nT(2, ]\n= - H * _L * : :sin(x) * : :cos (y) ;\n,\nT(3, ] ) = 0. F\n= L ;\nT(4, J\nT(5, j) = - H * _L * : :cos (x) * : :sin(y) ;\nreturn 0;\n}\n11 OK.\n}\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface.\n| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials |\n| --- | --- |\n\n![image](/image/placeholder)\n\n![image](/image/placeholder)\n\nFigure 31 - 2-D anisotropic meshes in the reference space (UV).\n![image](/image/placeholder)\n↓ ↓\nFigure 32 - 3-D surface meshes (T3 and all Q4).\nNotes:\n· This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface\nis available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2\nSurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).\nFor more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.\n· When there is only a discrete representation of the surface available (such as a tessellated surface), a\ndifferent method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and\nCM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.\nFor more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.\n· A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing.\n| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 53 |\n| --- | --- | --- |\n\nCOMPUTING\nOBJECTS"}, "elements": [{"category": "heading1", "content": {"html": "<h1 id='0' style='font-size:20px'>COMPUTING<br>OBJECTS</h1>", "markdown": "# COMPUTING\nOBJECTS", "text": "COMPUTING\nOBJECTS"}, "coordinates": [{"x": 0.1554, "y": 0.0523}, {"x": 0.4199, "y": 0.0523}, {"x": 0.4199, "y": 0.1145}, {"x": 0.1554, "y": 0.1145}], "id": 0, "page": 1}, {"category": "heading1", "content": {"html": "<h1 id='1' style='font-size:22px'>CM2 TriaMeshⓇ Iso/Aniso<br>CM2 QuadMesh � Iso/Aniso</h1>", "markdown": "# CM2 TriaMeshⓇ Iso/Aniso\nCM2 QuadMesh � Iso/Aniso", "text": "CM2 TriaMeshⓇ Iso/Aniso\nCM2 QuadMesh � Iso/Aniso"}, "coordinates": [{"x": 0.0948, "y": 0.6606}, {"x": 0.7743, "y": 0.6606}, {"x": 0.7743, "y": 0.7385}, {"x": 0.0948, "y": 0.7385}], "id": 1, "page": 1}, {"category": "heading1", "content": {"html": "<br><h1 id='2' style='font-size:16px'>Version 5.6</h1>", "markdown": "# Version 5.6", "text": "Version 5.6"}, "coordinates": [{"x": 0.0998, "y": 0.7413}, {"x": 0.2297, "y": 0.7413}, {"x": 0.2297, "y": 0.7615}, {"x": 0.0998, "y": 0.7615}], "id": 2, "page": 1}, {"category": "paragraph", "content": {"html": "<p id='3' data-category='paragraph' style='font-size:18px'>tutorials</p>", "markdown": "tutorials", "text": "tutorials"}, "coordinates": [{"x": 0.0998, "y": 0.7941}, {"x": 0.2597, "y": 0.7941}, {"x": 0.2597, "y": 0.8214}, {"x": 0.0998, "y": 0.8214}], "id": 3, "page": 1}, {"category": "paragraph", "content": {"html": "<p id='4' data-category='paragraph' style='font-size:14px'>Revision February 2025.<br>https://www.computing-objects.com<br>Ⓒ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France.</p>", "markdown": "Revision February 2025.\nhttps://www.computing-objects.com\nⒸ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France.", "text": "Revision February 2025.\nhttps://www.computing-objects.com\nⒸ Computing Objects SARL - 25 rue du Marechal Foch, 78000 Versailles, France."}, "coordinates": [{"x": 0.1002, "y": 0.9231}, {"x": 0.5966, "y": 0.9231}, {"x": 0.5966, "y": 0.9768}, {"x": 0.1002, "y": 0.9768}], "id": 4, "page": 1}, {"category": "heading1", "content": {"html": "<h1 id='5' style='font-size:20px'>Forewords</h1>", "markdown": "# Forewords", "text": "Forewords"}, "coordinates": [{"x": 0.0783, "y": 0.0646}, {"x": 0.2316, "y": 0.0646}, {"x": 0.2316, "y": 0.0865}, {"x": 0.0783, "y": 0.0865}], "id": 5, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='6' data-category='paragraph' style='font-size:16px'>This manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:</p>", "markdown": "This manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:", "text": "This manual is a tutorial for the 2-D mesh generators of the CM2 MeshToolsⓇ SDK:"}, "coordinates": [{"x": 0.0746, "y": 0.1249}, {"x": 0.7019, "y": 0.1249}, {"x": 0.7019, "y": 0.1411}, {"x": 0.0746, "y": 0.1411}], "id": 6, "page": 2}, {"category": "list", "content": {"html": "<p id='7' data-category='list' style='font-size:14px'>· The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,<br>· The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso.</p>", "markdown": "- · The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,\n- · The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso.\n", "text": "· The isotropic meshers CM2 TriaMeshⓇ Iso and CM2 QuadMesh� Iso,\n· The anisotropic meshers CM2 TriaMeshⓇ Aniso and CM2 QuadMesh� Aniso."}, "coordinates": [{"x": 0.0854, "y": 0.151}, {"x": 0.6758, "y": 0.151}, {"x": 0.6758, "y": 0.184}, {"x": 0.0854, "y": 0.184}], "id": 7, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='8' data-category='paragraph' style='font-size:16px'>All these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well<br>as the internal hard edges and hard points (embedded) are kept unmodified in the final mesh.</p>", "markdown": "All these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well\nas the internal hard edges and hard points (embedded) are kept unmodified in the final mesh.", "text": "All these mesh generators are constrained unstructured meshers: the boundary mesh (contour mesh) as well\nas the internal hard edges and hard points (embedded) are kept unmodified in the final mesh."}, "coordinates": [{"x": 0.0761, "y": 0.1945}, {"x": 0.9086, "y": 0.1945}, {"x": 0.9086, "y": 0.2243}, {"x": 0.0761, "y": 0.2243}], "id": 8, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='9' data-category='paragraph' style='font-size:16px'>Based on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality<br>elements with smooth grading sizes according to the length of the boundary edges or to the user-specified<br>sizes. The speed is near independent of the number of the elements to be generated.</p>", "markdown": "Based on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality\nelements with smooth grading sizes according to the length of the boundary edges or to the user-specified\nsizes. The speed is near independent of the number of the elements to be generated.", "text": "Based on a fast and robust hybrid \"Advancing-Front and Delaunay\" algorithm, they generate high quality\nelements with smooth grading sizes according to the length of the boundary edges or to the user-specified\nsizes. The speed is near independent of the number of the elements to be generated."}, "coordinates": [{"x": 0.0772, "y": 0.2346}, {"x": 0.8873, "y": 0.2346}, {"x": 0.8873, "y": 0.279}, {"x": 0.0772, "y": 0.279}], "id": 9, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='10' data-category='paragraph' style='font-size:16px'>Setting switches can be used to adapt the meshers to the various needs of the user concerning mesh<br>generation, refinement and optimization (they can also be used as optimizer-only of some already existing<br>meshes).</p>", "markdown": "Setting switches can be used to adapt the meshers to the various needs of the user concerning mesh\ngeneration, refinement and optimization (they can also be used as optimizer-only of some already existing\nmeshes).", "text": "Setting switches can be used to adapt the meshers to the various needs of the user concerning mesh\ngeneration, refinement and optimization (they can also be used as optimizer-only of some already existing\nmeshes)."}, "coordinates": [{"x": 0.0778, "y": 0.2892}, {"x": 0.881, "y": 0.2892}, {"x": 0.881, "y": 0.3332}, {"x": 0.0778, "y": 0.3332}], "id": 10, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='11' data-category='paragraph' style='font-size:16px'>The quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes.</p>", "markdown": "The quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes.", "text": "The quad meshers can generate all-quad meshes (the default) or mixed quad-dominant meshes."}, "coordinates": [{"x": 0.076, "y": 0.3437}, {"x": 0.8094, "y": 0.3437}, {"x": 0.8094, "y": 0.3605}, {"x": 0.076, "y": 0.3605}], "id": 11, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='12' data-category='paragraph' style='font-size:16px'>Many data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the<br>neighbors, number of sub-domains, area...</p>", "markdown": "Many data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the\nneighbors, number of sub-domains, area...", "text": "Many data concerning the mesh are available upon exit: shape and size qualities histograms, matrix of the\nneighbors, number of sub-domains, area..."}, "coordinates": [{"x": 0.0769, "y": 0.3704}, {"x": 0.8799, "y": 0.3704}, {"x": 0.8799, "y": 0.3995}, {"x": 0.0769, "y": 0.3995}], "id": 12, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='13' data-category='paragraph' style='font-size:16px'>Like many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-<br>threaded (you can select in the settings the maximum number of threads the generator can use).<br>The generated meshes are reproducible (same mesh with same input data and same mesh with any number of<br>threads).</p>", "markdown": "Like many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-\nthreaded (you can select in the settings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads).", "text": "Like many other meshers of the library, CM2 TriaMeshⓇ Iso/Aniso and CM2 QuadMesh� Iso/Aniso are multi-\nthreaded (you can select in the settings the maximum number of threads the generator can use).\nThe generated meshes are reproducible (same mesh with same input data and same mesh with any number of\nthreads)."}, "coordinates": [{"x": 0.0778, "y": 0.4105}, {"x": 0.9215, "y": 0.4105}, {"x": 0.9215, "y": 0.4672}, {"x": 0.0778, "y": 0.4672}], "id": 13, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='14' data-category='paragraph' style='font-size:16px'>Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners<br>should start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers.</p>", "markdown": "Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers.", "text": "Data are exchanged with the CM2 mesh generators through vector and matrix objects (no file). Beginners\nshould start by reading the CM2 Math1Ⓡ - overview manual to get first views on these mathematical containers."}, "coordinates": [{"x": 0.0769, "y": 0.4793}, {"x": 0.9187, "y": 0.4793}, {"x": 0.9187, "y": 0.5099}, {"x": 0.0769, "y": 0.5099}], "id": 14, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='15' data-category='paragraph' style='font-size:14px'>For a complete description of the data and settings structures used with these meshers please refer to the<br>CM2 TriaMesh & CM2 QuadMesh - reference manual.</p>", "markdown": "For a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TriaMesh & CM2 QuadMesh - reference manual.", "text": "For a complete description of the data and settings structures used with these meshers please refer to the\nCM2 TriaMesh & CM2 QuadMesh - reference manual."}, "coordinates": [{"x": 0.0783, "y": 0.5199}, {"x": 0.8871, "y": 0.5199}, {"x": 0.8871, "y": 0.55}, {"x": 0.0783, "y": 0.55}], "id": 15, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='16' data-category='paragraph' style='font-size:18px'>The source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit<br>number IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.<br>S.P.2001.000.20700 (23/05/2019) is regularly deposited since then.</p>", "markdown": "The source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.\nS.P.2001.000.20700 (23/05/2019) is regularly deposited since then.", "text": "The source code of the CM2 MeshToolsⓇ SDK (full library) has been registered with the APP under Inter Deposit\nnumber IDDN.FR.001 .260002.00.R.P.1998.000.20700 (22/06/1998) and IDDN.FR.001.480030.006.\nS.P.2001.000.20700 (23/05/2019) is regularly deposited since then."}, "coordinates": [{"x": 0.076, "y": 0.7485}, {"x": 0.919, "y": 0.7485}, {"x": 0.919, "y": 0.7937}, {"x": 0.076, "y": 0.7937}], "id": 16, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='17' data-category='paragraph' style='font-size:16px'>The source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly<br>deposited since then.</p>", "markdown": "The source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly\ndeposited since then.", "text": "The source code specific to CM2 TriaMeshⓇ Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440021.000.R.P.2008.000.20700 (31/1 0/2008) and is regularly\ndeposited since then."}, "coordinates": [{"x": 0.077, "y": 0.804}, {"x": 0.9106, "y": 0.804}, {"x": 0.9106, "y": 0.8482}, {"x": 0.077, "y": 0.8482}], "id": 17, "page": 2}, {"category": "paragraph", "content": {"html": "<p id='18' data-category='paragraph' style='font-size:16px'>The source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the<br>APP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly<br>deposited since then.</p>", "markdown": "The source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then.", "text": "The source code specific to CM2 QuadMesh� Iso/Aniso, together with this manual, has been registered with the\nAPP under Inter Deposit number IDDN.FR.001.440020.000.R.P.2008.000.20700 (31/10/2008) and is regularly\ndeposited since then."}, "coordinates": [{"x": 0.077, "y": 0.8586}, {"x": 0.9228, "y": 0.8586}, {"x": 0.9228, "y": 0.9035}, {"x": 0.077, "y": 0.9035}], "id": 18, "page": 2}, {"category": "table", "content": {"html": "<table id='19' style='font-size:16px'><thead></thead><tbody><tr><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 2 tutorials</td></tr></tbody></table>", "markdown": "| TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 2 tutorials |\n| --- | --- |\n", "text": "| TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 2 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0087, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0087, "y": 1}], "id": 19, "page": 2}, {"category": "heading1", "content": {"html": "<h1 id='20' style='font-size:20px'>Table of contents</h1>", "markdown": "# Table of contents", "text": "Table of contents"}, "coordinates": [{"x": 0.076, "y": 0.0619}, {"x": 0.3226, "y": 0.0619}, {"x": 0.3226, "y": 0.0886}, {"x": 0.076, "y": 0.0886}], "id": 20, "page": 3}, {"category": "paragraph", "content": {"html": "<p id='21' data-category='paragraph' style='font-size:14px'>Forewords. ...... 2</p>", "markdown": "Forewords. ...... 2", "text": "Forewords. ...... 2"}, "coordinates": [{"x": 0.076, "y": 0.1989}, {"x": 0.9215, "y": 0.1989}, {"x": 0.9215, "y": 0.2174}, {"x": 0.076, "y": 0.2174}], "id": 21, "page": 3}, {"category": "list", "content": {"html": "<br><p id='22' data-category='list' style='font-size:18px'>1. Getting started - a simple square .......... ········· 5<br>Some declarations 6<br>Authorization of the library........ 6<br>Contour mesh 7<br>2. Square with an internal line.......... ...... 14<br>3. Square with internal hole ....... 17<br>4. Quadratic elements & high-order nodes ........ ........ 19<br>5. Square with grading mesh size. ........ 21<br>6. Square with an internal hard node ......... ....... 23<br>7. Multiple meshes ........ ·········· 25<br>8. Shared boundaries ......... ....... 28<br>9. Background mesh ..... ······· 32<br>10. Anisotropic meshes. ...... 38<br>11. 3-D surface meshes (aniso meshers only) .... ...... 43</p>", "markdown": "- 1. Getting started - a simple square .......... ········· 5\n- Some declarations 6\n- Authorization of the library........ 6\n- Contour mesh 7\n- 2. Square with an internal line.......... ...... 14\n- 3. Square with internal hole ....... 17\n- 4. Quadratic elements & high-order nodes ........ ........ 19\n- 5. Square with grading mesh size. ........ 21\n- 6. Square with an internal hard node ......... ....... 23\n- 7. Multiple meshes ........ ·········· 25\n- 8. Shared boundaries ......... ....... 28\n- 9. Background mesh ..... ······· 32\n- 10. Anisotropic meshes. ...... 38\n- 11. 3-D surface meshes (aniso meshers only) .... ...... 43\n", "text": "1. Getting started - a simple square .......... ········· 5\nSome declarations 6\nAuthorization of the library........ 6\nContour mesh 7\n2. Square with an internal line.......... ...... 14\n3. Square with internal hole ....... 17\n4. Quadratic elements & high-order nodes ........ ........ 19\n5. Square with grading mesh size. ........ 21\n6. Square with an internal hard node ......... ....... 23\n7. Multiple meshes ........ ·········· 25\n8. Shared boundaries ......... ....... 28\n9. Background mesh ..... ······· 32\n10. Anisotropic meshes. ...... 38\n11. 3-D surface meshes (aniso meshers only) .... ...... 43"}, "coordinates": [{"x": 0.0708, "y": 0.2204}, {"x": 0.9293, "y": 0.2204}, {"x": 0.9293, "y": 0.5702}, {"x": 0.0708, "y": 0.5702}], "id": 22, "page": 3}, {"category": "table", "content": {"html": "<table id='23' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh� & CM2 QuadMesh� Iso/Aniso - 3 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0045, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0045, "y": 1}], "id": 23, "page": 3}, {"category": "paragraph", "content": {"html": "<p id='24' data-category='paragraph' style='font-size:20px'>Before meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter<br>mostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One<br>example (Section 7) illustrates the case where the boundary mesh has been generated by other means and is<br>simply read from a file.</p>", "markdown": "Before meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter\nmostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One\nexample (Section 7) illustrates the case where the boundary mesh has been generated by other means and is\nsimply read from a file.", "text": "Before meshing a 2-D domain, the first step is to generate a 1-D mesh of the external contour. This chapter\nmostly details cases where the boundary mesh is obtained using some simple CM2 MeshTools functions. One\nexample (Section 7) illustrates the case where the boundary mesh has been generated by other means and is\nsimply read from a file."}, "coordinates": [{"x": 0.0764, "y": 0.0644}, {"x": 0.9076, "y": 0.0644}, {"x": 0.9076, "y": 0.1235}, {"x": 0.0764, "y": 0.1235}], "id": 24, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='25' data-category='paragraph' style='font-size:20px'>Each example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the<br>classes and the functions of the library (API).</p>", "markdown": "Each example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API).", "text": "Each example starts with including the file stdafx. h (can be a pre-compiled header) giving access to the\nclasses and the functions of the library (API)."}, "coordinates": [{"x": 0.077, "y": 0.1339}, {"x": 0.8735, "y": 0.1339}, {"x": 0.8735, "y": 0.1638}, {"x": 0.077, "y": 0.1638}], "id": 25, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='26' data-category='paragraph' style='font-size:18px'>The general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:<br>: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.<br>h file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to<br>avoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.</p>", "markdown": "The general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:\n: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive.", "text": "The general namespace cm2 has nested namespaces such as cm2 : : vecscal, cm2 : : vecvec, cm2:\n: meshtools or cm2 : : tri amesh_ iso. The user can add a using namespace cm2 directive in this stdafx.\nh file. Keeping namespaces in the user's source code can however be useful to improve the legibility and to\navoid name conflicts. In the rest of this document we assume such a using namespace cm2 directive."}, "coordinates": [{"x": 0.0773, "y": 0.1757}, {"x": 0.9173, "y": 0.1757}, {"x": 0.9173, "y": 0.2327}, {"x": 0.0773, "y": 0.2327}], "id": 26, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='27' data-category='paragraph' style='font-size:18px'>File stdafx.h1:</p>", "markdown": "File stdafx.h1:", "text": "File stdafx.h1:"}, "coordinates": [{"x": 0.0786, "y": 0.243}, {"x": 0.203, "y": 0.243}, {"x": 0.203, "y": 0.258}, {"x": 0.0786, "y": 0.258}], "id": 27, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='28' data-category='paragraph' style='font-size:14px'>CM2 MESHTOOLS</p>", "markdown": "CM2 MESHTOOLS", "text": "CM2 MESHTOOLS"}, "coordinates": [{"x": 0.1204, "y": 0.2965}, {"x": 0.2388, "y": 0.2965}, {"x": 0.2388, "y": 0.3075}, {"x": 0.1204, "y": 0.3075}], "id": 28, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='29' data-category='paragraph' style='font-size:14px'>11<br>#include \" meshtools. h\"<br>#include \" meshtoo ls1d.h\"<br>#include \" tri amesh_iso. h\"<br>#include \" quadmesh_iso. h\"<br>#include \" triamesh_aniso.h\"<br>#include \"quadmesh_aniso.h\"</p>", "markdown": "11\n#include \" meshtools. h\"\n#include \" meshtoo ls1d.h\"\n#include \" tri amesh_iso. h\"\n#include \" quadmesh_iso. h\"\n#include \" triamesh_aniso.h\"\n#include \"quadmesh_aniso.h\"", "text": "11\n#include \" meshtools. h\"\n#include \" meshtoo ls1d.h\"\n#include \" tri amesh_iso. h\"\n#include \" quadmesh_iso. h\"\n#include \" triamesh_aniso.h\"\n#include \"quadmesh_aniso.h\""}, "coordinates": [{"x": 0.1067, "y": 0.2998}, {"x": 0.3293, "y": 0.2998}, {"x": 0.3293, "y": 0.3656}, {"x": 0.1067, "y": 0.3656}], "id": 29, "page": 4}, {"category": "table", "content": {"html": "<br><table id='30' style='font-size:16px'><thead></thead><tbody><tr><td>General purpose mesh routines</td></tr><tr><td>To generate 1D meshes</td></tr><tr><td>CM2 TriaMesh Iso</td></tr><tr><td>CM2 QuadMesh Iso</td></tr><tr><td>CM2 TriaMesh Aniso (Section 10 onlyly)</td></tr><tr><td>CM2 QuadMesh Aniso (Section 10</td></tr></tbody></table>", "markdown": "| General purpose mesh routines |\n| --- |\n| To generate 1D meshes |\n| CM2 TriaMesh Iso |\n| CM2 QuadMesh Iso |\n| CM2 TriaMesh Aniso (Section 10 onlyly) |\n| CM2 QuadMesh Aniso (Section 10 |\n", "text": "| General purpose mesh routines |\n| --- |\n| To generate 1D meshes |\n| CM2 TriaMesh Iso |\n| CM2 QuadMesh Iso |\n| CM2 TriaMesh Aniso (Section 10 onlyly) |\n| CM2 QuadMesh Aniso (Section 10 |\n"}, "coordinates": [{"x": 0.3584, "y": 0.3063}, {"x": 0.6781, "y": 0.3063}, {"x": 0.6781, "y": 0.3651}, {"x": 0.3584, "y": 0.3651}], "id": 30, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='31' data-category='paragraph' style='font-size:18px'>using namespace cm2;</p>", "markdown": "using namespace cm2;", "text": "using namespace cm2;"}, "coordinates": [{"x": 0.106, "y": 0.3734}, {"x": 0.2714, "y": 0.3734}, {"x": 0.2714, "y": 0.3848}, {"x": 0.106, "y": 0.3848}], "id": 31, "page": 4}, {"category": "paragraph", "content": {"html": "<br><p id='32' data-category='paragraph' style='font-size:14px'>/ Main cm2 namespace can now be omitted.</p>", "markdown": "/ Main cm2 namespace can now be omitted.", "text": "/ Main cm2 namespace can now be omitted."}, "coordinates": [{"x": 0.3527, "y": 0.3729}, {"x": 0.682, "y": 0.3729}, {"x": 0.682, "y": 0.3851}, {"x": 0.3527, "y": 0.3851}], "id": 32, "page": 4}, {"category": "paragraph", "content": {"html": "<p id='33' data-category='paragraph' style='font-size:22px'>Required libraries2:</p>", "markdown": "Required libraries2:", "text": "Required libraries2:"}, "coordinates": [{"x": 0.0776, "y": 0.4283}, {"x": 0.2263, "y": 0.4283}, {"x": 0.2263, "y": 0.4432}, {"x": 0.0776, "y": 0.4432}], "id": 33, "page": 4}, {"category": "list", "content": {"html": "<p id='34' data-category='list' style='font-size:14px'>· cm2math1<br>· cm2misc<br>· cm2meshtools<br>· cm2meshtools1d<br>· cm2meshtools2d<br>· cm2triamesh_ iso<br>· cm2quadmesh_ iso<br>· cm2triamesh_aniso (Section 10 only)<br>· cm2quadmesh_aniso (Section 10 only)</p>", "markdown": "- · cm2math1\n- · cm2misc\n- · cm2meshtools\n- · cm2meshtools1d\n- · cm2meshtools2d\n- · cm2triamesh_ iso\n- · cm2quadmesh_ iso\n- · cm2triamesh_aniso (Section 10 only)\n- · cm2quadmesh_aniso (Section 10 only)\n", "text": "· cm2math1\n· cm2misc\n· cm2meshtools\n· cm2meshtools1d\n· cm2meshtools2d\n· cm2triamesh_ iso\n· cm2quadmesh_ iso\n· cm2triamesh_aniso (Section 10 only)\n· cm2quadmesh_aniso (Section 10 only)"}, "coordinates": [{"x": 0.0878, "y": 0.4556}, {"x": 0.4099, "y": 0.4556}, {"x": 0.4099, "y": 0.6042}, {"x": 0.0878, "y": 0.6042}], "id": 34, "page": 4}, {"category": "footnote", "content": {"html": "<p id='35' data-category='footnote' style='font-size:16px'>1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_<br>iso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.<br>2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are<br>lib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib).</p>", "markdown": "1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_\niso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.\n2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are\nlib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib).", "text": "1 If neither meshtools nor CM2 QuadMesh Iso nor the aniso meshers is used, the file stdafx.h can reduce to:#inc lude \"triamesh_\niso. h\" and link only with cm2math1, cm2misc, cm2meshtools, cm2meshtools2d and cm2triamesh_ iso.\n2 The lib names end with ($platform) 」 ($ver). For instance cm2math1_x64_56. dll. On Windows, file extensions for the libraries are\nlib and dll. On Linux/Unix/macOS platforms, file extensions are usually .a (static archive), .SO or .dylib (dynamic lib)."}, "coordinates": [{"x": 0.0669, "y": 0.8582}, {"x": 0.9107, "y": 0.8582}, {"x": 0.9107, "y": 0.9129}, {"x": 0.0669, "y": 0.9129}], "id": 35, "page": 4}, {"category": "table", "content": {"html": "<table id='36' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>4</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 4 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0098, "y": 0.9478}, {"x": 1, "y": 0.9478}, {"x": 1, "y": 1}, {"x": 0.0098, "y": 1}], "id": 36, "page": 4}, {"category": "heading1", "content": {"html": "<h1 id='37' style='font-size:22px'>1. Getting started - a simple square</h1>", "markdown": "# 1. Getting started - a simple square", "text": "1. Getting started - a simple square"}, "coordinates": [{"x": 0.0769, "y": 0.0637}, {"x": 0.5649, "y": 0.0637}, {"x": 0.5649, "y": 0.0887}, {"x": 0.0769, "y": 0.0887}], "id": 37, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='38' data-category='paragraph' style='font-size:18px'>This first example is a regular mesh of a square. The four boundary segments are equally discretized with 10<br>elements.</p>", "markdown": "This first example is a regular mesh of a square. The four boundary segments are equally discretized with 10\nelements.", "text": "This first example is a regular mesh of a square. The four boundary segments are equally discretized with 10\nelements."}, "coordinates": [{"x": 0.0757, "y": 0.0987}, {"x": 0.8997, "y": 0.0987}, {"x": 0.8997, "y": 0.1292}, {"x": 0.0757, "y": 0.1292}], "id": 38, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='39' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"<br>#include <iostream></p>", "markdown": "#include \"stdafx.h\"\n#include <iostream>", "text": "#include \"stdafx.h\"\n#include <iostream>"}, "coordinates": [{"x": 0.1047, "y": 0.1667}, {"x": 0.2644, "y": 0.1667}, {"x": 0.2644, "y": 0.1876}, {"x": 0.1047, "y": 0.1876}], "id": 39, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='40' data-category='paragraph' style='font-size:14px'>11 Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }</p>", "markdown": "11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }", "text": "11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }"}, "coordinates": [{"x": 0.1037, "y": 0.1944}, {"x": 0.7565, "y": 0.1944}, {"x": 0.7565, "y": 0.2191}, {"x": 0.1037, "y": 0.2191}], "id": 40, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='41' data-category='paragraph' style='font-size:14px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1081, "y": 0.2335}, {"x": 0.1906, "y": 0.2335}, {"x": 0.1906, "y": 0.2457}, {"x": 0.1081, "y": 0.2457}], "id": 41, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='42' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1095, "y": 0.2448}, {"x": 0.1181, "y": 0.2448}, {"x": 0.1181, "y": 0.254}, {"x": 0.1095, "y": 0.254}], "id": 42, "page": 5}, {"category": "table", "content": {"html": "<br><table id='43' style='font-size:14px'><thead></thead><tbody><tr><td>const double</td><td>L(10.);</td></tr><tr><td>const unsublevec2</td><td>N(10) ;</td></tr><tr><td>const Doub</td><td>PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>", "markdown": "| const double | L(10.); |\n| --- | --- |\n| const unsublevec2 | N(10) ; |\n| const Doub | PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n", "text": "| const double | L(10.); |\n| --- | --- |\n| const unsublevec2 | N(10) ; |\n| const Doub | PO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0 . , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n"}, "coordinates": [{"x": 0.1437, "y": 0.2522}, {"x": 0.6416, "y": 0.2522}, {"x": 0.6416, "y": 0.3127}, {"x": 0.1437, "y": 0.3127}], "id": 43, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='44' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1326, "y": 0.319}, {"x": 0.6898, "y": 0.319}, {"x": 0.6898, "y": 0.3415}, {"x": 0.1326, "y": 0.3415}], "id": 44, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='45' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.</p>", "markdown": "11 VERTICES AND LINE MESHES.", "text": "11 VERTICES AND LINE MESHES."}, "coordinates": [{"x": 0.1349, "y": 0.3473}, {"x": 0.3571, "y": 0.3473}, {"x": 0.3571, "y": 0.3588}, {"x": 0.1349, "y": 0.3588}], "id": 45, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='46' data-category='paragraph' style='font-size:14px'>pos . push_back (PO) ;<br>pos · push_back(P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;<br>meshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;<br>meshtools1d: : indices_to_connectE2(indices, connectB) ;</p>", "markdown": "pos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\nmeshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectB) ;", "text": "pos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\nmeshtools1d: : mesh_straight (pos, 日, 1, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, N, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectB) ;"}, "coordinates": [{"x": 0.1317, "y": 0.3523}, {"x": 0.6969, "y": 0.3523}, {"x": 0.6969, "y": 0.4458}, {"x": 0.1317, "y": 0.4458}], "id": 46, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='47' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_iso: : mesher the_mesher;<br>triamesh_iso: : mesher: :data_type data (pos, connectB) ;<br>the_mesher . run(data) ;</p>", "markdown": "11 THE 2D MESH.\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;", "text": "11 THE 2D MESH.\ntriamesh_iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;"}, "coordinates": [{"x": 0.1319, "y": 0.4523}, {"x": 0.5795, "y": 0.4523}, {"x": 0.5795, "y": 0.4911}, {"x": 0.1319, "y": 0.4911}], "id": 47, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='48' data-category='paragraph' style='font-size:14px'>11 SOME OUTPUT INFO (OPTIONAL) .<br>data.print_info(&display_hdl) ;</p>", "markdown": "11 SOME OUTPUT INFO (OPTIONAL) .\ndata.print_info(&display_hdl) ;", "text": "11 SOME OUTPUT INFO (OPTIONAL) .\ndata.print_info(&display_hdl) ;"}, "coordinates": [{"x": 0.1324, "y": 0.4994}, {"x": 0.3801, "y": 0.4994}, {"x": 0.3801, "y": 0.5213}, {"x": 0.1324, "y": 0.5213}], "id": 48, "page": 5}, {"category": "paragraph", "content": {"html": "<p id='49' data-category='paragraph' style='font-size:14px'>11 VISUALISATION (OPTIONAL) .<br>meshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALISATION (OPTIONAL) .\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;", "text": "11 VISUALISATION (OPTIONAL) .\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1305, "y": 0.5278}, {"x": 0.7234, "y": 0.5278}, {"x": 0.7234, "y": 0.5502}, {"x": 0.1305, "y": 0.5502}], "id": 49, "page": 5}, {"category": "paragraph", "content": {"html": "<br><p id='50' data-category='paragraph' style='font-size:14px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1052, "y": 0.5575}, {"x": 0.2074, "y": 0.5575}, {"x": 0.2074, "y": 0.5788}, {"x": 0.1052, "y": 0.5788}], "id": 50, "page": 5}, {"category": "heading1", "content": {"html": "<h1 id='51' style='font-size:20px'>The resulting mesh is shown Figure 1.</h1>", "markdown": "# The resulting mesh is shown Figure 1.", "text": "The resulting mesh is shown Figure 1."}, "coordinates": [{"x": 0.0765, "y": 0.6212}, {"x": 0.3664, "y": 0.6212}, {"x": 0.3664, "y": 0.6383}, {"x": 0.0765, "y": 0.6383}], "id": 51, "page": 5}, {"category": "table", "content": {"html": "<table id='52' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 5 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0042, "y": 0.9481}, {"x": 1, "y": 0.9481}, {"x": 1, "y": 1}, {"x": 0.0042, "y": 1}], "id": 52, "page": 5}, {"category": "figure", "content": {"html": "<figure id='53'><img alt=\"\" data-coord=\"top-left:(380,118); bottom-right:(859,592)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3068, "y": 0.0674}, {"x": 0.6927, "y": 0.0674}, {"x": 0.6927, "y": 0.3377}, {"x": 0.3068, "y": 0.3377}], "id": 53, "page": 6}, {"category": "caption", "content": {"html": "<caption id='54' style='font-size:14px'>Figure 1 - Triangle mesh of a square.</caption>", "markdown": "Figure 1 - Triangle mesh of a square.", "text": "Figure 1 - Triangle mesh of a square."}, "coordinates": [{"x": 0.3844, "y": 0.3471}, {"x": 0.6132, "y": 0.3471}, {"x": 0.6132, "y": 0.362}, {"x": 0.3844, "y": 0.362}], "id": 54, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='55' data-category='paragraph' style='font-size:18px'>Let us explain this program line by line.</p>", "markdown": "Let us explain this program line by line.", "text": "Let us explain this program line by line."}, "coordinates": [{"x": 0.0776, "y": 0.3976}, {"x": 0.3759, "y": 0.3976}, {"x": 0.3759, "y": 0.4132}, {"x": 0.0776, "y": 0.4132}], "id": 55, "page": 6}, {"category": "heading1", "content": {"html": "<h1 id='56' style='font-size:20px'>Some declarations</h1>", "markdown": "# Some declarations", "text": "Some declarations"}, "coordinates": [{"x": 0.077, "y": 0.4303}, {"x": 0.2825, "y": 0.4303}, {"x": 0.2825, "y": 0.4483}, {"x": 0.077, "y": 0.4483}], "id": 56, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='57' data-category='paragraph' style='font-size:16px'>Matrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a<br>UIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column<br>number in matrix pos where the coordinates of this node can be found4.</p>", "markdown": "Matrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a\nUIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column\nnumber in matrix pos where the coordinates of this node can be found4.", "text": "Matrix pos is a DoubleMat (variable-sized matrix of doubles)3 and the connectivity matrix connectB is a\nUIntMat. connectB (i, j) shall store the ith local node of the jth element. This integer refers to the column\nnumber in matrix pos where the coordinates of this node can be found4."}, "coordinates": [{"x": 0.0768, "y": 0.4617}, {"x": 0.9139, "y": 0.4617}, {"x": 0.9139, "y": 0.5056}, {"x": 0.0768, "y": 0.5056}], "id": 57, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='58' data-category='paragraph' style='font-size:18px'>indices is a temporary vector.</p>", "markdown": "indices is a temporary vector.", "text": "indices is a temporary vector."}, "coordinates": [{"x": 0.0799, "y": 0.5158}, {"x": 0.3218, "y": 0.5158}, {"x": 0.3218, "y": 0.5321}, {"x": 0.0799, "y": 0.5321}], "id": 58, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='59' data-category='paragraph' style='font-size:22px'>Authorization of the library</p>", "markdown": "Authorization of the library", "text": "Authorization of the library"}, "coordinates": [{"x": 0.0774, "y": 0.5489}, {"x": 0.3735, "y": 0.5489}, {"x": 0.3735, "y": 0.5682}, {"x": 0.0774, "y": 0.5682}], "id": 59, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='60' data-category='paragraph' style='font-size:16px'>The library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to<br>tri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for<br>each library: the name of your company or organization that has acquired the license and a secret code5. Note<br>that both strings are case sensitive and the registration call must be made each time the library is loaded into<br>memory and before the first run of the mesher.</p>", "markdown": "The library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to\ntri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for\neach library: the name of your company or organization that has acquired the license and a secret code5. Note\nthat both strings are case sensitive and the registration call must be made each time the library is loaded into\nmemory and before the first run of the mesher.", "text": "The library triamesh_ iso (resp. quadmesh_iso) is protected and need to be unlocked with a call to\ntri amesh_ iso : : registration (resp. quadmesh_ iso: : registration). Two strings must be provided for\neach library: the name of your company or organization that has acquired the license and a secret code5. Note\nthat both strings are case sensitive and the registration call must be made each time the library is loaded into\nmemory and before the first run of the mesher."}, "coordinates": [{"x": 0.0778, "y": 0.5806}, {"x": 0.9207, "y": 0.5806}, {"x": 0.9207, "y": 0.6527}, {"x": 0.0778, "y": 0.6527}], "id": 60, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='61' data-category='paragraph' style='font-size:14px'>triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.106, "y": 0.6899}, {"x": 0.6677, "y": 0.6899}, {"x": 0.6677, "y": 0.7039}, {"x": 0.106, "y": 0.7039}], "id": 61, "page": 6}, {"category": "list", "content": {"html": "<p id='62' data-category='list' style='font-size:14px'>3 See manual CM2 Math1 - overview.<br>4 Recall that array indices are zero based (from 0 to N-1).<br>5 Contact license@computing-objects.com for any licensing inquiry.</p>", "markdown": "- 3 See manual CM2 Math1 - overview.\n- 4 Recall that array indices are zero based (from 0 to N-1).\n- 5 Contact license@computing-objects.com for any licensing inquiry.\n", "text": "3 See manual CM2 Math1 - overview.\n4 Recall that array indices are zero based (from 0 to N-1).\n5 Contact license@computing-objects.com for any licensing inquiry."}, "coordinates": [{"x": 0.0662, "y": 0.8611}, {"x": 0.5173, "y": 0.8611}, {"x": 0.5173, "y": 0.9149}, {"x": 0.0662, "y": 0.9149}], "id": 62, "page": 6}, {"category": "table", "content": {"html": "<table id='63' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials |\n| --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 6 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0089, "y": 0.9486}, {"x": 1, "y": 0.9486}, {"x": 1, "y": 1}, {"x": 0.0089, "y": 1}], "id": 63, "page": 6}, {"category": "paragraph", "content": {"html": "<p id='64' data-category='paragraph' style='font-size:22px'>Contour mesh</p>", "markdown": "Contour mesh", "text": "Contour mesh"}, "coordinates": [{"x": 0.078, "y": 0.0648}, {"x": 0.2333, "y": 0.0648}, {"x": 0.2333, "y": 0.0831}, {"x": 0.078, "y": 0.0831}], "id": 64, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='65' data-category='paragraph' style='font-size:20px'>This is usually the heaviest part of the work for the user. In this example, we only use routines from the<br>CM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it<br>form a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos<br>containing the points' coordinates and the connectivity matrix connectB of the boundary edges.</p>", "markdown": "This is usually the heaviest part of the work for the user. In this example, we only use routines from the\nCM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it\nform a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos\ncontaining the points' coordinates and the connectivity matrix connectB of the boundary edges.", "text": "This is usually the heaviest part of the work for the user. In this example, we only use routines from the\nCM2 MeshTools SDK, but the user is free to generate the contour mesh with any other tool or even to read it\nform a file6. Anyway, the 2-D meshers need this contour mesh as a couple of matrices: the matrix pos\ncontaining the points' coordinates and the connectivity matrix connectB of the boundary edges."}, "coordinates": [{"x": 0.0773, "y": 0.0958}, {"x": 0.8979, "y": 0.0958}, {"x": 0.8979, "y": 0.155}, {"x": 0.0773, "y": 0.155}], "id": 65, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='66' data-category='paragraph' style='font-size:20px'>First, the corners of the square are created as four pair of coordinates in the pos matrix:</p>", "markdown": "First, the corners of the square are created as four pair of coordinates in the pos matrix:", "text": "First, the corners of the square are created as four pair of coordinates in the pos matrix:"}, "coordinates": [{"x": 0.0767, "y": 0.1644}, {"x": 0.7474, "y": 0.1644}, {"x": 0.7474, "y": 0.1814}, {"x": 0.0767, "y": 0.1814}], "id": 66, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='67' data-category='paragraph' style='font-size:14px'>pos · push_back(P0) ;<br>pos · push_back(P1) ;<br>pos . push_back(P2) ;<br>pos . push_back(P3) ;</p>", "markdown": "pos · push_back(P0) ;\npos · push_back(P1) ;\npos . push_back(P2) ;\npos . push_back(P3) ;", "text": "pos · push_back(P0) ;\npos · push_back(P1) ;\npos . push_back(P2) ;\npos . push_back(P3) ;"}, "coordinates": [{"x": 0.106, "y": 0.219}, {"x": 0.2527, "y": 0.219}, {"x": 0.2527, "y": 0.2592}, {"x": 0.106, "y": 0.2592}], "id": 67, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='68' data-category='paragraph' style='font-size:20px'>The push_back function appends a new column at the end of a matrix. The size of the column must match the<br>current number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows.</p>", "markdown": "The push_back function appends a new column at the end of a matrix. The size of the column must match the\ncurrent number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows.", "text": "The push_back function appends a new column at the end of a matrix. The size of the column must match the\ncurrent number of rows of the matrix. If the matrix is empty, the first vector sets this number of rows."}, "coordinates": [{"x": 0.0762, "y": 0.3024}, {"x": 0.9222, "y": 0.3024}, {"x": 0.9222, "y": 0.3324}, {"x": 0.0762, "y": 0.3324}], "id": 68, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='69' data-category='paragraph' style='font-size:20px'>After these four push-backs, the dimensions of the pos matrix are 2 X 4.</p>", "markdown": "After these four push-backs, the dimensions of the pos matrix are 2 X 4.", "text": "After these four push-backs, the dimensions of the pos matrix are 2 X 4."}, "coordinates": [{"x": 0.0774, "y": 0.3425}, {"x": 0.6253, "y": 0.3425}, {"x": 0.6253, "y": 0.3591}, {"x": 0.0774, "y": 0.3591}], "id": 69, "page": 7}, {"category": "table", "content": {"html": "<table id='70' style='font-size:16px'><thead></thead><tbody><tr><td>meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ;</td></tr><tr><td>meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ;</td></tr></tbody></table>", "markdown": "| meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ; |\n| --- |\n| meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ; |\n", "text": "| meshtools1d : : mesh_straight (pos, 日, 1, N, indices) ; indices . pop_ back() ; |\n| --- |\n| meshtools1d : : mesh_straight(pos , 1, 2, N, indices) ; indices - pop_back() ; meshtools1d : : mesh_straight(pos , 2, 3 , N, indices) ; indices · pop_back() ; meshtoo ls1d : : mesh_straight(pos, 3, ⊙ , N, indices) ; |\n"}, "coordinates": [{"x": 0.1035, "y": 0.3958}, {"x": 0.6774, "y": 0.3958}, {"x": 0.6774, "y": 0.4368}, {"x": 0.1035, "y": 0.4368}], "id": 70, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='71' data-category='paragraph' style='font-size:20px'>Now that the four corners are present, we can create the points in between and the associated edges:</p>", "markdown": "Now that the four corners are present, we can create the points in between and the associated edges:", "text": "Now that the four corners are present, we can create the points in between and the associated edges:"}, "coordinates": [{"x": 0.077, "y": 0.4799}, {"x": 0.8521, "y": 0.4799}, {"x": 0.8521, "y": 0.4967}, {"x": 0.077, "y": 0.4967}], "id": 71, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='72' data-category='paragraph' style='font-size:20px'>The mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new<br>appended columns in the pos matrix:</p>", "markdown": "The mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new\nappended columns in the pos matrix:", "text": "The mesh_straight routine of the meshtools1d library generates N - 1 new points equally spaced into new\nappended columns in the pos matrix:"}, "coordinates": [{"x": 0.0765, "y": 0.5061}, {"x": 0.9158, "y": 0.5061}, {"x": 0.9158, "y": 0.537}, {"x": 0.0765, "y": 0.537}], "id": 72, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='73' data-category='paragraph' style='font-size:18px'>meshtoo ls1d : : mesh_straight<br>(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;</p>", "markdown": "meshtoo ls1d : : mesh_straight\n(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;", "text": "meshtoo ls1d : : mesh_straight\n(DoubleMat& pos, unsi gned 10, unsi gned i1, unsi gned N, UIntVec& indices) ;"}, "coordinates": [{"x": 0.1066, "y": 0.5738}, {"x": 0.7241, "y": 0.5738}, {"x": 0.7241, "y": 0.5971}, {"x": 0.1066, "y": 0.5971}], "id": 73, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='74' data-category='paragraph' style='font-size:20px'>The index of each point, i.e. the column in matrix pos, is also appended to the vector indices.<br>With i0 = 0 and i1 = 1, this vector contains upon exit of this function:</p>", "markdown": "The index of each point, i.e. the column in matrix pos, is also appended to the vector indices.\nWith i0 = 0 and i1 = 1, this vector contains upon exit of this function:", "text": "The index of each point, i.e. the column in matrix pos, is also appended to the vector indices.\nWith i0 = 0 and i1 = 1, this vector contains upon exit of this function:"}, "coordinates": [{"x": 0.0754, "y": 0.6385}, {"x": 0.7984, "y": 0.6385}, {"x": 0.7984, "y": 0.6693}, {"x": 0.0754, "y": 0.6693}], "id": 74, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='75' data-category='paragraph' style='font-size:18px'>[0 4 5 6 7 8 9 10 11 12 1]</p>", "markdown": "[0 4 5 6 7 8 9 10 11 12 1]", "text": "[0 4 5 6 7 8 9 10 11 12 1]"}, "coordinates": [{"x": 0.0805, "y": 0.6769}, {"x": 0.3436, "y": 0.6769}, {"x": 0.3436, "y": 0.6933}, {"x": 0.0805, "y": 0.6933}], "id": 75, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='76' data-category='paragraph' style='font-size:20px'>And the matrix pos is now of size 2 X 13:</p>", "markdown": "And the matrix pos is now of size 2 X 13:", "text": "And the matrix pos is now of size 2 X 13:"}, "coordinates": [{"x": 0.0771, "y": 0.7036}, {"x": 0.3881, "y": 0.7036}, {"x": 0.3881, "y": 0.7191}, {"x": 0.0771, "y": 0.7191}], "id": 76, "page": 7}, {"category": "chart", "content": {"html": "<figure id='77' data-category='chart'><img data-coord=\"top-left:(377,1294); bottom-right:(866,1482)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>Four corners</td><td>New generated nodes</td></tr></thead><tbody><tr><td>item_01</td><td>12</td><td>12</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: line\n|  | Four corners | New generated nodes |\n| --- | --- | --- |\n| item_01 | 12 | 12 |\n", "text": "![image](/image/placeholder)\n- Chart Type: line\n|  | Four corners | New generated nodes |\n| --- | --- | --- |\n| item_01 | 12 | 12 |\n"}, "coordinates": [{"x": 0.3038, "y": 0.7381}, {"x": 0.6979, "y": 0.7381}, {"x": 0.6979, "y": 0.8452}, {"x": 0.3038, "y": 0.8452}], "id": 77, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='78' data-category='paragraph' style='font-size:18px'>6 See Section 5, \"Square with Grading Mesh Size\".</p>", "markdown": "6 See Section 5, \"Square with Grading Mesh Size\".", "text": "6 See Section 5, \"Square with Grading Mesh Size\"."}, "coordinates": [{"x": 0.0676, "y": 0.8992}, {"x": 0.3686, "y": 0.8992}, {"x": 0.3686, "y": 0.9127}, {"x": 0.0676, "y": 0.9127}], "id": 78, "page": 7}, {"category": "table", "content": {"html": "<table id='79' style='font-size:20px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>7 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025 | 7 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5. .6 rev. February 2025 | 7 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0073, "y": 0.9475}, {"x": 1, "y": 0.9475}, {"x": 1, "y": 1}, {"x": 0.0073, "y": 1}], "id": 79, "page": 7}, {"category": "paragraph", "content": {"html": "<p id='80' data-category='paragraph' style='font-size:20px'>The last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:</p>", "markdown": "The last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:", "text": "The last value in the indices vector, i.e. value 1, must be suppressed to avoid having it twice:"}, "coordinates": [{"x": 0.0751, "y": 0.0641}, {"x": 0.7894, "y": 0.0641}, {"x": 0.7894, "y": 0.0814}, {"x": 0.0751, "y": 0.0814}], "id": 80, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='81' data-category='paragraph' style='font-size:14px'>indices · pop_back() ;</p>", "markdown": "indices · pop_back() ;", "text": "indices · pop_back() ;"}, "coordinates": [{"x": 0.1054, "y": 0.1173}, {"x": 0.2647, "y": 0.1173}, {"x": 0.2647, "y": 0.1327}, {"x": 0.1054, "y": 0.1327}], "id": 81, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='82' data-category='paragraph' style='font-size:18px'>The second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:</p>", "markdown": "The second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:", "text": "The second call to mesh_straight with i0 = 1 and i1 = 2 sets the indices vector to:"}, "coordinates": [{"x": 0.0751, "y": 0.1737}, {"x": 0.7289, "y": 0.1737}, {"x": 0.7289, "y": 0.1896}, {"x": 0.0751, "y": 0.1896}], "id": 82, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='83' data-category='paragraph' style='font-size:18px'>[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]</p>", "markdown": "[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]", "text": "[0 4 5 6 7 8 9 10 11 12 1 13 14 15 16 17 18 19 20 21 2]"}, "coordinates": [{"x": 0.0818, "y": 0.1977}, {"x": 0.6368, "y": 0.1977}, {"x": 0.6368, "y": 0.2133}, {"x": 0.0818, "y": 0.2133}], "id": 83, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='84' data-category='paragraph' style='font-size:18px'>After the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index<br>equals to the first, here zero, to close the contour7.</p>", "markdown": "After the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index\nequals to the first, here zero, to close the contour7.", "text": "After the four line meshes, the matrix pos is of size 2 X 40 and the indices vector has 41 values - the last index\nequals to the first, here zero, to close the contour7."}, "coordinates": [{"x": 0.0758, "y": 0.2238}, {"x": 0.9108, "y": 0.2238}, {"x": 0.9108, "y": 0.2537}, {"x": 0.0758, "y": 0.2537}], "id": 84, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='85' data-category='paragraph' style='font-size:22px'>The vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:</p>", "markdown": "The vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:", "text": "The vector of indices is used to create the connectivity matrix (2-node edges) of the boundary mesh:"}, "coordinates": [{"x": 0.0748, "y": 0.2637}, {"x": 0.8531, "y": 0.2637}, {"x": 0.8531, "y": 0.2815}, {"x": 0.0748, "y": 0.2815}], "id": 85, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='86' data-category='paragraph' style='font-size:14px'>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>", "markdown": "meshtools1d : : indices_to_connectE2 (indices, connectB) ;", "text": "meshtools1d : : indices_to_connectE2 (indices, connectB) ;"}, "coordinates": [{"x": 0.1049, "y": 0.3169}, {"x": 0.538, "y": 0.3169}, {"x": 0.538, "y": 0.3316}, {"x": 0.1049, "y": 0.3316}], "id": 86, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='87' data-category='paragraph' style='font-size:18px'>The connectB matrix has now dimensions 2 X 40:</p>", "markdown": "The connectB matrix has now dimensions 2 X 40:", "text": "The connectB matrix has now dimensions 2 X 40:"}, "coordinates": [{"x": 0.0768, "y": 0.3731}, {"x": 0.4625, "y": 0.3731}, {"x": 0.4625, "y": 0.3891}, {"x": 0.0768, "y": 0.3891}], "id": 87, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='88' data-category='paragraph' style='font-size:14px'>2x40 [0 4 5 6 7 · · · 39<br>4 5 6 7 8 · · · 0]</p>", "markdown": "2x40 [0 4 5 6 7 · · · 39\n4 5 6 7 8 · · · 0]", "text": "2x40 [0 4 5 6 7 · · · 39\n4 5 6 7 8 · · · 0]"}, "coordinates": [{"x": 0.0765, "y": 0.3968}, {"x": 0.3141, "y": 0.3968}, {"x": 0.3141, "y": 0.4249}, {"x": 0.0765, "y": 0.4249}], "id": 88, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='89' data-category='paragraph' style='font-size:18px'>Now that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a<br>data structure holding this 1-D mesh and make the mesher run on it:</p>", "markdown": "Now that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a\ndata structure holding this 1-D mesh and make the mesher run on it:", "text": "Now that we have done the boundary mesh, all we have to do is to call the 2-D mesher. This done by creating a\ndata structure holding this 1-D mesh and make the mesher run on it:"}, "coordinates": [{"x": 0.0757, "y": 0.4352}, {"x": 0.9178, "y": 0.4352}, {"x": 0.9178, "y": 0.4661}, {"x": 0.0757, "y": 0.4661}], "id": 89, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='90' data-category='paragraph' style='font-size:14px'>triamesh_iso : : mesher : :data_type data (pos, connectB) ;<br>the_mesher · run (data) ;</p>", "markdown": "triamesh_iso : : mesher : :data_type data (pos, connectB) ;\nthe_mesher · run (data) ;", "text": "triamesh_iso : : mesher : :data_type data (pos, connectB) ;\nthe_mesher · run (data) ;"}, "coordinates": [{"x": 0.1053, "y": 0.5032}, {"x": 0.5544, "y": 0.5032}, {"x": 0.5544, "y": 0.525}, {"x": 0.1053, "y": 0.525}], "id": 90, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='91' data-category='paragraph' style='font-size:18px'>This constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos<br>and data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated<br>inside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40<br>points are left untouched in the first 40 columns.</p>", "markdown": "This constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos\nand data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated\ninside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40\npoints are left untouched in the first 40 columns.", "text": "This constructs the data structure with shallow-copies of the matrices pos and of connectB into data · pos\nand data . connectB. Upon exit, the matrix data.pos is bigger and contains all the new points generated\ninside the square by the 2-D mesher. These new points are appended to the original matrix. The initial 40\npoints are left untouched in the first 40 columns."}, "coordinates": [{"x": 0.0761, "y": 0.5684}, {"x": 0.9025, "y": 0.5684}, {"x": 0.9025, "y": 0.6261}, {"x": 0.0761, "y": 0.6261}], "id": 91, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='92' data-category='paragraph' style='font-size:20px'>The connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of<br>the nodes for an element8. connectM(i, j) is the ith local node of the jth element.</p>", "markdown": "The connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of\nthe nodes for an element8. connectM(i, j) is the ith local node of the jth element.", "text": "The connectivity of the final mesh is stored in the matrix data · connectM, each column storing the indices of\nthe nodes for an element8. connectM(i, j) is the ith local node of the jth element."}, "coordinates": [{"x": 0.0762, "y": 0.6373}, {"x": 0.908, "y": 0.6373}, {"x": 0.908, "y": 0.6678}, {"x": 0.0762, "y": 0.6678}], "id": 92, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='93' data-category='paragraph' style='font-size:14px'>7 The same result could have been achieved with:</p>", "markdown": "7 The same result could have been achieved with:", "text": "7 The same result could have been achieved with:"}, "coordinates": [{"x": 0.0707, "y": 0.7905}, {"x": 0.3716, "y": 0.7905}, {"x": 0.3716, "y": 0.8019}, {"x": 0.0707, "y": 0.8019}], "id": 93, "page": 8}, {"category": "paragraph", "content": {"html": "<br><p id='94' data-category='paragraph' style='font-size:16px'>UIntVec hard_nodes (5) ;<br>hard_nodes [0] = 日;<br>hard_nodes[1] = 1;<br>hard_nodes[2] = 2;<br>hard_nodes[3] = 3;<br>hard_nodes [4] = 日;<br>meshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;<br>This variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes).</p>", "markdown": "UIntVec hard_nodes (5) ;\nhard_nodes [0] = 日;\nhard_nodes[1] = 1;\nhard_nodes[2] = 2;\nhard_nodes[3] = 3;\nhard_nodes [4] = 日;\nmeshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;\nThis variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes).", "text": "UIntVec hard_nodes (5) ;\nhard_nodes [0] = 日;\nhard_nodes[1] = 1;\nhard_nodes[2] = 2;\nhard_nodes[3] = 3;\nhard_nodes [4] = 日;\nmeshtools1d : : mesh_straight (pos, hard_nodes, 4*N, indices) ;\nThis variant of mesh_straight meshes a polyline going through some constrained points (hard_nodes)."}, "coordinates": [{"x": 0.0751, "y": 0.8059}, {"x": 0.7239, "y": 0.8059}, {"x": 0.7239, "y": 0.8917}, {"x": 0.0751, "y": 0.8917}], "id": 94, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='95' data-category='paragraph' style='font-size:16px'>8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule).</p>", "markdown": "8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule).", "text": "8 The elements are always oriented counter-clock wise (normal up with the right-hand thumb rule)."}, "coordinates": [{"x": 0.0687, "y": 0.8993}, {"x": 0.6658, "y": 0.8993}, {"x": 0.6658, "y": 0.9125}, {"x": 0.0687, "y": 0.9125}], "id": 95, "page": 8}, {"category": "table", "content": {"html": "<table id='96' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials</td><td>8</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - tutorials | 8 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0138, "y": 0.9485}, {"x": 1, "y": 0.9485}, {"x": 1, "y": 1}, {"x": 0.0138, "y": 1}], "id": 96, "page": 8}, {"category": "paragraph", "content": {"html": "<p id='97' data-category='paragraph' style='font-size:18px'>Printed information about the generated mesh and a MEDIT9 output file are obtained with:</p>", "markdown": "Printed information about the generated mesh and a MEDIT9 output file are obtained with:", "text": "Printed information about the generated mesh and a MEDIT9 output file are obtained with:"}, "coordinates": [{"x": 0.0763, "y": 0.0641}, {"x": 0.7643, "y": 0.0641}, {"x": 0.7643, "y": 0.0813}, {"x": 0.0763, "y": 0.0813}], "id": 97, "page": 9}, {"category": "paragraph", "content": {"html": "<p id='98' data-category='paragraph' style='font-size:14px'>data.print_info(&display_hdl) ;<br>meshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;</p>", "markdown": "data.print_info(&display_hdl) ;\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;", "text": "data.print_info(&display_hdl) ;\nmeshtools : : medit_output(\"out.mesh\" , data. pos, data. connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1038, "y": 0.117}, {"x": 0.7013, "y": 0.117}, {"x": 0.7013, "y": 0.1417}, {"x": 0.1038, "y": 0.1417}], "id": 98, "page": 9}, {"category": "paragraph", "content": {"html": "<p id='99' data-category='paragraph' style='font-size:22px'>Here is the output given by data.print_ info(&display_hdl) :</p>", "markdown": "Here is the output given by data.print_ info(&display_hdl) :", "text": "Here is the output given by data.print_ info(&display_hdl) :"}, "coordinates": [{"x": 0.0777, "y": 0.1831}, {"x": 0.5871, "y": 0.1831}, {"x": 0.5871, "y": 0.2009}, {"x": 0.0777, "y": 0.2009}], "id": 99, "page": 9}, {"category": "figure", "content": {"html": "<figure id='100'><img style='font-size:14px' alt=\"* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙\" data-coord=\"top-left:(106,386); bottom-right:(1141,987)\" /></figure>", "markdown": "![image](/image/placeholder)\n* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙", "text": "![image](/image/placeholder)\n* ** * * * *\n* CM2 TriaMesh (R) Iso ① ) *\n* **** * * **** ***** * * ******* k * * * * * * *\nHard nodes : 40/40\nHard edges : 40/40\nNodes : 136\nTriangles : 230\nSubdomains : 1\nArea : 1. 600000E+01\nFrint time : 0.00 S.\n: 8. 348321E-01\nRefine time : 0.00 s.\nOptim time : 0.00 s.\nTotal time : 0.00 s. (114994.63 t/s.)\n* **** ******* HISTOGRAM QS ************\nTotal number of bins : 11\nTotal number of counts : 230\nNumber of smaller' values : ⊙\nNumber of sma va lues : ⊙\n✓ max : 1. 000000E+00\n✓ mean : 9. 466349E-01\n✓ min : 8.348321E-01\nBin number -- Bin boundaries -- Hits\n10 0.90 1.00 177\n9 0.80 0.90 53\n8 0.70 0.80 ⊙\n7 0.60 0.70 ⊙\n6 0.50 0.60 ⊙\n5 0.40 0.50 ⊙\n4 0.30 0.40 ⊙\n3 0.20 0.30 ⊙\n2 0.10 0.20 ⊙\n1 0.01 0.10 ⊙\n⊙ ⊙  ⊙⊙ 0.01 ⊙"}, "coordinates": [{"x": 0.0861, "y": 0.2203}, {"x": 0.9199, "y": 0.2203}, {"x": 0.9199, "y": 0.5631}, {"x": 0.0861, "y": 0.5631}], "id": 100, "page": 9}, {"category": "caption", "content": {"html": "<caption id='101' style='font-size:16px'>Figure 2 - Output info for the square example.</caption>", "markdown": "Figure 2 - Output info for the square example.", "text": "Figure 2 - Output info for the square example."}, "coordinates": [{"x": 0.3552, "y": 0.5753}, {"x": 0.6422, "y": 0.5753}, {"x": 0.6422, "y": 0.5892}, {"x": 0.3552, "y": 0.5892}], "id": 101, "page": 9}, {"category": "paragraph", "content": {"html": "<p id='102' data-category='paragraph' style='font-size:20px'>The generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges<br>(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,<br>optimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.<br>In the second step new nodes are generated inside the domain to get elements with good shape and size.<br>Finally, the last step is for geometrical and topological optimizations to improve the quality of the elements.</p>", "markdown": "The generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges\n(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,\noptimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.\nIn the second step new nodes are generated inside the domain to get elements with good shape and size.\nFinally, the last step is for geometrical and topological optimizations to improve the quality of the elements.", "text": "The generated mesh has 136 nodes and 230 triangles for an initial contour mesh of 40 nodes and 40 edges\n(hard nodes and hard edges). The times spent in the three steps of the meshing process (front, refine,\noptimize) are given in seconds10. The front mesh is the triangulation mesh with only the boundary hard nodes.\nIn the second step new nodes are generated inside the domain to get elements with good shape and size.\nFinally, the last step is for geometrical and topological optimizations to improve the quality of the elements."}, "coordinates": [{"x": 0.0766, "y": 0.6237}, {"x": 0.91, "y": 0.6237}, {"x": 0.91, "y": 0.6987}, {"x": 0.0766, "y": 0.6987}], "id": 102, "page": 9}, {"category": "paragraph", "content": {"html": "<p id='103' data-category='paragraph' style='font-size:16px'>9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront<br>OBJ.</p>", "markdown": "9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront\nOBJ.", "text": "9 MEDIT is a free visualization program. Other output formats are: Ensight, FEMAP (neutral), Nastran, STL (ASCII or binary), VTK and Wavefront\nOBJ."}, "coordinates": [{"x": 0.0681, "y": 0.8463}, {"x": 0.9211, "y": 0.8463}, {"x": 0.9211, "y": 0.8709}, {"x": 0.0681, "y": 0.8709}], "id": 103, "page": 9}, {"category": "footnote", "content": {"html": "<p id='104' data-category='footnote' style='font-size:14px'>10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270<br>V2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh<br>Aniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso).</p>", "markdown": "10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270\nV2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh\nAniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso).", "text": "10 Here the times are below 0.01 S. All runs are done with x64 CM2 libs (VS 2010 MD build) on Windows� 8.1 x64 with Intel� XeonⓇ E3-1270\nV2 3.5 GHz (turbo boost disabled). The typical speed with default settings on such a platform ranges from 5 000 quads / S. (CM2 QuadMesh\nAniso) to more than 100 000 triangles / S. (CM2 TriaMesh Iso)."}, "coordinates": [{"x": 0.0651, "y": 0.8762}, {"x": 0.9202, "y": 0.8762}, {"x": 0.9202, "y": 0.9133}, {"x": 0.0651, "y": 0.9133}], "id": 104, "page": 9}, {"category": "table", "content": {"html": "<table id='105' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials |\n| --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 9 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0103, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0103, "y": 1}], "id": 105, "page": 9}, {"category": "paragraph", "content": {"html": "<p id='106' data-category='paragraph' style='font-size:18px'>The formula used to compute the shape quality of a triangle writes:</p>", "markdown": "The formula used to compute the shape quality of a triangle writes:", "text": "The formula used to compute the shape quality of a triangle writes:"}, "coordinates": [{"x": 0.0758, "y": 0.064}, {"x": 0.5886, "y": 0.064}, {"x": 0.5886, "y": 0.0812}, {"x": 0.0758, "y": 0.0812}], "id": 106, "page": 10}, {"category": "table", "content": {"html": "<table id='107' style='font-size:18px'><thead></thead><tbody><tr><td>S</td><td>S</td><td>Area of the triangle.</td></tr><tr><td>Qs = 4V3 L P</td><td>L with: max</td><td>Length of the longest edge of the triangle.</td></tr><tr><td>max</td><td>P</td><td>Perimeter of the triangle.</td></tr></tbody></table>", "markdown": "| S | S | Area of the triangle. |\n| --- | --- | --- |\n| Qs = 4V3 L P | L with: max | Length of the longest edge of the triangle. |\n| max | P | Perimeter of the triangle. |\n", "text": "| S | S | Area of the triangle. |\n| --- | --- | --- |\n| Qs = 4V3 L P | L with: max | Length of the longest edge of the triangle. |\n| max | P | Perimeter of the triangle. |\n"}, "coordinates": [{"x": 0.1107, "y": 0.0906}, {"x": 0.8143, "y": 0.0906}, {"x": 0.8143, "y": 0.1505}, {"x": 0.1107, "y": 0.1505}], "id": 107, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='108' data-category='paragraph' style='font-size:18px'>This quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.<br>On the square example, the worst shape quality is 0.83 and the average is 0.94.</p>", "markdown": "This quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.\nOn the square example, the worst shape quality is 0.83 and the average is 0.94.", "text": "This quality measure ranges from 0 for a degenerated triangle, to 1 for an equilateral triangle.\nOn the square example, the worst shape quality is 0.83 and the average is 0.94."}, "coordinates": [{"x": 0.0748, "y": 0.1664}, {"x": 0.7861, "y": 0.1664}, {"x": 0.7861, "y": 0.1969}, {"x": 0.0748, "y": 0.1969}], "id": 108, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='109' data-category='paragraph' style='font-size:16px'>The size quality is also an important parameter to take into account. The size quality of an edge is a measure<br>based upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates<br>that the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,<br>and a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as<br>it should be (and should have been split).</p>", "markdown": "The size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates\nthat the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,\nand a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as\nit should be (and should have been split).", "text": "The size quality is also an important parameter to take into account. The size quality of an edge is a measure\nbased upon its actual length and the target size values defined at its two vertices. A size quality of 1 indicates\nthat the edge has the optimal length. A too short edge has a size quality lesser than 1 - but always positive 一,\nand a too long edge has a size quality greater than 1. For instance an edge with a quality of 2 is twice as long as\nit should be (and should have been split)."}, "coordinates": [{"x": 0.0757, "y": 0.207}, {"x": 0.9184, "y": 0.207}, {"x": 0.9184, "y": 0.2798}, {"x": 0.0757, "y": 0.2798}], "id": 109, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='110' data-category='paragraph' style='font-size:18px'>The formula used to compute the length quality of an edge AB writes:</p>", "markdown": "The formula used to compute the length quality of an edge AB writes:", "text": "The formula used to compute the length quality of an edge AB writes:"}, "coordinates": [{"x": 0.076, "y": 0.29}, {"x": 0.6066, "y": 0.29}, {"x": 0.6066, "y": 0.307}, {"x": 0.076, "y": 0.307}], "id": 110, "page": 10}, {"category": "equation", "content": {"html": "<p id='111' data-category='equation'>$$Q_{h}^{4B}=L_{A B}\\,\\frac{\\left|\\displaystyle\\left(\\frac{h_{A}}{h_{B}}\\right)}{h_{A}-h_{B}}$$</p>", "markdown": "$$Q_{h}^{4B}=L_{A B}\\,\\frac{\\left|\\displaystyle\\left(\\frac{h_{A}}{h_{B}}\\right)}{h_{A}-h_{B}}$$", "text": "In\n hB\n �AB = L\n AB\n hA -h�"}, "coordinates": [{"x": 0.1216, "y": 0.3144}, {"x": 0.2871, "y": 0.3144}, {"x": 0.2871, "y": 0.3879}, {"x": 0.1216, "y": 0.3879}], "id": 111, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='112' data-category='paragraph' style='font-size:14px'>AB</p>", "markdown": "AB", "text": "AB"}, "coordinates": [{"x": 0.489, "y": 0.3352}, {"x": 0.5116, "y": 0.3352}, {"x": 0.5116, "y": 0.3445}, {"x": 0.489, "y": 0.3445}], "id": 112, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='113' data-category='paragraph' style='font-size:20px'>L</p>", "markdown": "L", "text": "L"}, "coordinates": [{"x": 0.4733, "y": 0.3257}, {"x": 0.4924, "y": 0.3257}, {"x": 0.4924, "y": 0.34}, {"x": 0.4733, "y": 0.34}], "id": 113, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='114' data-category='paragraph' style='font-size:18px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.4013, "y": 0.3456}, {"x": 0.4421, "y": 0.3456}, {"x": 0.4421, "y": 0.3614}, {"x": 0.4013, "y": 0.3614}], "id": 114, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='115' data-category='paragraph' style='font-size:18px'>h</p>", "markdown": "h", "text": "h"}, "coordinates": [{"x": 0.4744, "y": 0.3452}, {"x": 0.4892, "y": 0.3452}, {"x": 0.4892, "y": 0.358}, {"x": 0.4744, "y": 0.358}], "id": 115, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='116' data-category='paragraph' style='font-size:18px'>Actual length of edge AB.</p>", "markdown": "Actual length of edge AB.", "text": "Actual length of edge AB."}, "coordinates": [{"x": 0.5203, "y": 0.3273}, {"x": 0.6944, "y": 0.3273}, {"x": 0.6944, "y": 0.3422}, {"x": 0.5203, "y": 0.3422}], "id": 116, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='117' data-category='paragraph' style='font-size:14px'>A</p>", "markdown": "A", "text": "A"}, "coordinates": [{"x": 0.4849, "y": 0.3542}, {"x": 0.4973, "y": 0.3542}, {"x": 0.4973, "y": 0.3634}, {"x": 0.4849, "y": 0.3634}], "id": 117, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='118' data-category='paragraph' style='font-size:18px'>Target size at node A (expected edge length at A).</p>", "markdown": "Target size at node A (expected edge length at A).", "text": "Target size at node A (expected edge length at A)."}, "coordinates": [{"x": 0.5197, "y": 0.346}, {"x": 0.8597, "y": 0.346}, {"x": 0.8597, "y": 0.3613}, {"x": 0.5197, "y": 0.3613}], "id": 118, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='119' data-category='paragraph' style='font-size:18px'>h B Target size at node B (expected edge length at B).</p>", "markdown": "h B Target size at node B (expected edge length at B).", "text": "h B Target size at node B (expected edge length at B)."}, "coordinates": [{"x": 0.4736, "y": 0.3637}, {"x": 0.8611, "y": 0.3637}, {"x": 0.8611, "y": 0.382}, {"x": 0.4736, "y": 0.382}], "id": 119, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='120' data-category='paragraph' style='font-size:16px'>Let's introduce also at this point the h-shock measure of an edge:</p>", "markdown": "Let's introduce also at this point the h-shock measure of an edge:", "text": "Let's introduce also at this point the h-shock measure of an edge:"}, "coordinates": [{"x": 0.0775, "y": 0.4031}, {"x": 0.5735, "y": 0.4031}, {"x": 0.5735, "y": 0.421}, {"x": 0.0775, "y": 0.421}], "id": 120, "page": 10}, {"category": "equation", "content": {"html": "<p id='121' data-category='equation'>$$h s^{A B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{B}^{A B}}}-1$$</p>", "markdown": "$$h s^{A B}=\\operatorname*{min}\\biggl(\\frac{h_{A}}{h_{B}},\\frac{h_{B}}{h_{A}}\\biggr)^{\\frac{1}{Q_{B}^{A B}}}-1$$", "text": "1\n hs AB h hB QAB\n = min -1\n hB hA"}, "coordinates": [{"x": 0.1207, "y": 0.4331}, {"x": 0.3592, "y": 0.4331}, {"x": 0.3592, "y": 0.4845}, {"x": 0.1207, "y": 0.4845}], "id": 121, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='122' data-category='paragraph' style='font-size:16px'>These two measures are dimensionless and positive.</p>", "markdown": "These two measures are dimensionless and positive.", "text": "These two measures are dimensionless and positive."}, "coordinates": [{"x": 0.0756, "y": 0.505}, {"x": 0.48, "y": 0.505}, {"x": 0.48, "y": 0.5222}, {"x": 0.0756, "y": 0.5222}], "id": 122, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='123' data-category='paragraph' style='font-size:18px'>When hA = hB the h-shock is null and the length quality simply writes QAB</p>", "markdown": "When hA = hB the h-shock is null and the length quality simply writes QAB", "text": "When hA = hB the h-shock is null and the length quality simply writes QAB"}, "coordinates": [{"x": 0.0783, "y": 0.5486}, {"x": 0.6529, "y": 0.5486}, {"x": 0.6529, "y": 0.5712}, {"x": 0.0783, "y": 0.5712}], "id": 123, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='124' data-category='paragraph' style='font-size:14px'>AB</p>", "markdown": "AB", "text": "AB"}, "coordinates": [{"x": 0.6855, "y": 0.5508}, {"x": 0.7043, "y": 0.5508}, {"x": 0.7043, "y": 0.5601}, {"x": 0.6855, "y": 0.5601}], "id": 124, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='125' data-category='paragraph' style='font-size:20px'>L</p>", "markdown": "L", "text": "L"}, "coordinates": [{"x": 0.6732, "y": 0.5437}, {"x": 0.6878, "y": 0.5437}, {"x": 0.6878, "y": 0.5575}, {"x": 0.6732, "y": 0.5575}], "id": 125, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='126' data-category='paragraph' style='font-size:22px'>hA</p>", "markdown": "hA", "text": "hA"}, "coordinates": [{"x": 0.6756, "y": 0.5641}, {"x": 0.6998, "y": 0.5641}, {"x": 0.6998, "y": 0.5824}, {"x": 0.6756, "y": 0.5824}], "id": 126, "page": 10}, {"category": "paragraph", "content": {"html": "<br><p id='127' data-category='paragraph' style='font-size:18px'>When QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB.</p>", "markdown": "When QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB.", "text": "When QAB = 1 edge AB is considered having optimal length with respect to its target mesh sizes h A and hB."}, "coordinates": [{"x": 0.0746, "y": 0.5796}, {"x": 0.8885, "y": 0.5796}, {"x": 0.8885, "y": 0.6001}, {"x": 0.0746, "y": 0.6001}], "id": 127, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='128' data-category='paragraph' style='font-size:18px'>To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size<br>quality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure<br>smooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this<br>makes the job of the optimizer difficult and heuristics must be used.</p>", "markdown": "To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used.", "text": "To optimize a mesh we need to improve simultaneously both the shape quality of the elements and the size\nquality of the edges. On top of these, the h-shock should be kept lower than a maximum threshold to ensure\nsmooth gradations and all the prescribed entities (hard edges and hard nodes) must be honored. All this\nmakes the job of the optimizer difficult and heuristics must be used."}, "coordinates": [{"x": 0.0761, "y": 0.6086}, {"x": 0.9015, "y": 0.6086}, {"x": 0.9015, "y": 0.6671}, {"x": 0.0761, "y": 0.6671}], "id": 128, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='129' data-category='paragraph' style='font-size:18px'>The histogram of the size qualities can be computed either inside the mesher by raising the flag settings .<br>compute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :<br>: edge_qualities.</p>", "markdown": "The histogram of the size qualities can be computed either inside the mesher by raising the flag settings .\ncompute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :\n: edge_qualities.", "text": "The histogram of the size qualities can be computed either inside the mesher by raising the flag settings .\ncompute_Qh_ flag11 before meshing or with a posteriori call to the auxiliary function cm2 : : meshtools :\n: edge_qualities."}, "coordinates": [{"x": 0.0774, "y": 0.6769}, {"x": 0.8937, "y": 0.6769}, {"x": 0.8937, "y": 0.7212}, {"x": 0.0774, "y": 0.7212}], "id": 129, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='130' data-category='paragraph' style='font-size:14px'>11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options.</p>", "markdown": "11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options.", "text": "11 See CM2 TriaMesh Iso/Aniso & CM2 QuadMesh Iso/Aniso - reference manual for full description of the meshers options."}, "coordinates": [{"x": 0.0641, "y": 0.8984}, {"x": 0.8085, "y": 0.8984}, {"x": 0.8085, "y": 0.9131}, {"x": 0.0641, "y": 0.9131}], "id": 130, "page": 10}, {"category": "table", "content": {"html": "<table id='131' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>10 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 10 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 10 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0081, "y": 0.9471}, {"x": 1, "y": 0.9471}, {"x": 1, "y": 1}, {"x": 0.0081, "y": 1}], "id": 131, "page": 10}, {"category": "paragraph", "content": {"html": "<p id='132' data-category='paragraph' style='font-size:20px'>On the square example, the size qualities are well centered on the value 1 with a small variance:</p>", "markdown": "On the square example, the size qualities are well centered on the value 1 with a small variance:", "text": "On the square example, the size qualities are well centered on the value 1 with a small variance:"}, "coordinates": [{"x": 0.0753, "y": 0.064}, {"x": 0.805, "y": 0.064}, {"x": 0.805, "y": 0.0812}, {"x": 0.0753, "y": 0.0812}], "id": 132, "page": 11}, {"category": "figure", "content": {"html": "<figure id='133'><img style='font-size:14px' alt=\"* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙\" data-coord=\"top-left:(100,176); bottom-right:(1142,693)\" /></figure>", "markdown": "![image](/image/placeholder)\n* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙", "text": "![image](/image/placeholder)\n* * * 大 * ******* HISTOGRAM QH ************\nTotal number of bins : 20\nTotal number of counts : 365\nNumber of larger values : ⊙\nNumber of sma ller values : ⊙\nV max : 1. 362359E+00\n✓ mean : 1. 004864E+00\n✓ min : 7.529856E-01\nBin number -- Bin boundaries Hits\n19 10.00 +INF ⊙\n18 5.00 10.00 ⊙\n17 3.33 5.00 ⊙\n16 2.50 3.33 ⊙\n15 2.00 2.50 ⊙\n14 1.67 2.00 ⊙\n13 1.43 1.67 ⊙\n12 1. 25 1.43 1\n11 1. 11 1.25 37\n10 1. ⊙⊙ 1. 11 156\n9 0.90 1.00 140\n8 0.80 0.90 23\n7 0.70 0.80 8\n6 0.60 0.70 ⊙\n5 0.50 0.60 ⊙\n4 0.40 0.50 ⊙\n3 0.30 0.40 ⊙\n2 0.20 0.30 ⊙\n1 0.10 0.20 ⊙\n⊙ 0.00 0.10 ⊙"}, "coordinates": [{"x": 0.0807, "y": 0.1005}, {"x": 0.9206, "y": 0.1005}, {"x": 0.9206, "y": 0.3956}, {"x": 0.0807, "y": 0.3956}], "id": 133, "page": 11}, {"category": "caption", "content": {"html": "<caption id='134' style='font-size:16px'>Figure 3 - Histogram of the size-qualities of all the edges in the square example.</caption>", "markdown": "Figure 3 - Histogram of the size-qualities of all the edges in the square example.", "text": "Figure 3 - Histogram of the size-qualities of all the edges in the square example."}, "coordinates": [{"x": 0.2561, "y": 0.4072}, {"x": 0.7419, "y": 0.4072}, {"x": 0.7419, "y": 0.4212}, {"x": 0.2561, "y": 0.4212}], "id": 134, "page": 11}, {"category": "table", "content": {"html": "<table id='135' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 11 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0049, "y": 0.9483}, {"x": 1, "y": 0.9483}, {"x": 1, "y": 1}, {"x": 0.0049, "y": 1}], "id": 135, "page": 11}, {"category": "paragraph", "content": {"html": "<p id='136' data-category='paragraph' style='font-size:22px'>To mesh with quadrangles all is needed is to change the class of the mesher:</p>", "markdown": "To mesh with quadrangles all is needed is to change the class of the mesher:", "text": "To mesh with quadrangles all is needed is to change the class of the mesher:"}, "coordinates": [{"x": 0.0771, "y": 0.0642}, {"x": 0.6604, "y": 0.0642}, {"x": 0.6604, "y": 0.081}, {"x": 0.0771, "y": 0.081}], "id": 136, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='137' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"<br>#include <iostream></p>", "markdown": "#include \"stdafx.h\"\n#include <iostream>", "text": "#include \"stdafx.h\"\n#include <iostream>"}, "coordinates": [{"x": 0.1061, "y": 0.1063}, {"x": 0.2647, "y": 0.1063}, {"x": 0.2647, "y": 0.127}, {"x": 0.1061, "y": 0.127}], "id": 137, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='138' data-category='paragraph' style='font-size:18px'>11 Simple optional display handler.<br>static void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }</p>", "markdown": "11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }", "text": "11 Simple optional display handler.\nstatic void display_hdl (void*, unsigned, const char* msg) { std : : cout << msg; }"}, "coordinates": [{"x": 0.105, "y": 0.1339}, {"x": 0.7571, "y": 0.1339}, {"x": 0.7571, "y": 0.1581}, {"x": 0.105, "y": 0.1581}], "id": 138, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='139' data-category='paragraph' style='font-size:18px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1088, "y": 0.1728}, {"x": 0.1911, "y": 0.1728}, {"x": 0.1911, "y": 0.1851}, {"x": 0.1088, "y": 0.1851}], "id": 139, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='140' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1842}, {"x": 0.1187, "y": 0.1842}, {"x": 0.1187, "y": 0.1939}, {"x": 0.1094, "y": 0.1939}], "id": 140, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='141' data-category='paragraph' style='font-size:14px'>const</p>", "markdown": "const", "text": "const"}, "coordinates": [{"x": 0.1321, "y": 0.193}, {"x": 0.1761, "y": 0.193}, {"x": 0.1761, "y": 0.2032}, {"x": 0.1321, "y": 0.2032}], "id": 141, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='142' data-category='paragraph' style='font-size:16px'>const</p>", "markdown": "const", "text": "const"}, "coordinates": [{"x": 0.1322, "y": 0.2027}, {"x": 0.176, "y": 0.2027}, {"x": 0.176, "y": 0.2125}, {"x": 0.1322, "y": 0.2125}], "id": 142, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='143' data-category='paragraph' style='font-size:14px'>const</p>", "markdown": "const", "text": "const"}, "coordinates": [{"x": 0.132, "y": 0.2122}, {"x": 0.1762, "y": 0.2122}, {"x": 0.1762, "y": 0.223}, {"x": 0.132, "y": 0.223}], "id": 143, "page": 12}, {"category": "table", "content": {"html": "<br><table id='144' style='font-size:18px'><thead></thead><tbody><tr><td>double</td><td>L(10.);</td></tr><tr><td>unsi gned</td><td>N(10) ;</td></tr><tr><td>Doub leVec2</td><td>PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; ,</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>", "markdown": "| double | L(10.); |\n| --- | --- |\n| unsi gned | N(10) ; |\n| Doub leVec2 | PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; , |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n", "text": "| double | L(10.); |\n| --- | --- |\n| unsi gned | N(10) ; |\n| Doub leVec2 | PO(0. , 0.), P1(L, ⊙. ) , P2(L, L), P3(0 . L) ; , |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n"}, "coordinates": [{"x": 0.1568, "y": 0.1922}, {"x": 0.6377, "y": 0.1922}, {"x": 0.6377, "y": 0.2522}, {"x": 0.1568, "y": 0.2522}], "id": 144, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='145' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>quadmesh_iso : :registration(\"Licensed to SMART Inc .<br>,</p>", "markdown": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso : :registration(\"Licensed to SMART Inc .\n,", "text": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso : :registration(\"Licensed to SMART Inc .\n,"}, "coordinates": [{"x": 0.133, "y": 0.2584}, {"x": 0.6911, "y": 0.2584}, {"x": 0.6911, "y": 0.2811}, {"x": 0.133, "y": 0.2811}], "id": 145, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='146' data-category='paragraph' style='font-size:16px'>11 VERTICES AND LINE MESHES.<br>pos . push_back (PO) ;<br>pos . push_back (P1) ;<br>pos · push_back(P2) ;<br>pos . push_back (P3) ;<br>meshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;<br>meshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;<br>meshtools1d: : indices_ to_connectE2(indices, connectB) ;</p>", "markdown": "11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos · push_back(P2) ;\npos . push_back (P3) ;\nmeshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;\nmeshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;", "text": "11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos · push_back(P2) ;\npos . push_back (P3) ;\nmeshtools1d : : mesh_strai ght(pos, ⊙, 1, N, indices) ; indices.pop_back() ;\nmeshtools1d : : mesh_straight (pos, 1, 2, N, indices) ; indices · pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2, 3, N, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight (pos, 3, 日, N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;"}, "coordinates": [{"x": 0.1327, "y": 0.2888}, {"x": 0.6979, "y": 0.2888}, {"x": 0.6979, "y": 0.3847}, {"x": 0.1327, "y": 0.3847}], "id": 146, "page": 12}, {"category": "table", "content": {"html": "<table id='147' style='font-size:18px'><thead></thead><tbody><tr><td>11 THE 2D MESH.</td><td></td></tr><tr><td>quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ;</td><td>the_mesher; data (pos, connectB) ;</td></tr></tbody></table>", "markdown": "| 11 THE 2D MESH. |  |\n| --- | --- |\n| quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ; | the_mesher; data (pos, connectB) ; |\n", "text": "| 11 THE 2D MESH. |  |\n| --- | --- |\n| quadmesh_iso: : mesher quadmesh_ iso: : mesher::data_type the_mesher . run (data) ; data.print_info (&display_hdl) ; | the_mesher; data (pos, connectB) ; |\n"}, "coordinates": [{"x": 0.1301, "y": 0.392}, {"x": 0.5825, "y": 0.392}, {"x": 0.5825, "y": 0.4418}, {"x": 0.1301, "y": 0.4418}], "id": 147, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='148' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACEQ4) ;"}, "coordinates": [{"x": 0.131, "y": 0.4487}, {"x": 0.7234, "y": 0.4487}, {"x": 0.7234, "y": 0.4714}, {"x": 0.131, "y": 0.4714}], "id": 148, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='149' data-category='paragraph' style='font-size:18px'>return 0;<br>11 main</p>", "markdown": "return 0;\n11 main", "text": "return 0;\n11 main"}, "coordinates": [{"x": 0.1277, "y": 0.4783}, {"x": 0.2073, "y": 0.4783}, {"x": 0.2073, "y": 0.4983}, {"x": 0.1277, "y": 0.4983}], "id": 149, "page": 12}, {"category": "paragraph", "content": {"html": "<br><p id='150' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1084, "y": 0.4881}, {"x": 0.1176, "y": 0.4881}, {"x": 0.1176, "y": 0.4978}, {"x": 0.1084, "y": 0.4978}], "id": 150, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='151' data-category='paragraph' style='font-size:22px'>In this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12.</p>", "markdown": "In this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12.", "text": "In this particular case, the generated mesh is a perfectly structured quad mesh with all qualities equal to one12."}, "coordinates": [{"x": 0.0766, "y": 0.5295}, {"x": 0.9163, "y": 0.5295}, {"x": 0.9163, "y": 0.547}, {"x": 0.0766, "y": 0.547}], "id": 151, "page": 12}, {"category": "paragraph", "content": {"html": "<p id='152' data-category='paragraph' style='font-size:16px'>12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4.</p>", "markdown": "12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4.", "text": "12 We could get the same structured Q4 mesh with cm2 : : meshtools2d : :mesh_struct_Q4."}, "coordinates": [{"x": 0.0641, "y": 0.8986}, {"x": 0.6385, "y": 0.8986}, {"x": 0.6385, "y": 0.9134}, {"x": 0.0641, "y": 0.9134}], "id": 152, "page": 12}, {"category": "table", "content": {"html": "<table id='153' style='font-size:20px'><thead></thead><tbody><tr><td>QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials</td></tr></tbody></table>", "markdown": "| QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials |\n| --- | --- |\n", "text": "| QuadMesh� Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 Iso/Aniso - 12 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0073, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0073, "y": 1}], "id": 153, "page": 12}, {"category": "caption", "content": {"html": "<caption id='154' style='font-size:14px'>Figure 4 - Square meshed with quads.</caption>", "markdown": "Figure 4 - Square meshed with quads.", "text": "Figure 4 - Square meshed with quads."}, "coordinates": [{"x": 0.3787, "y": 0.347}, {"x": 0.6188, "y": 0.347}, {"x": 0.6188, "y": 0.362}, {"x": 0.3787, "y": 0.362}], "id": 154, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='155' data-category='paragraph' style='font-size:22px'>For a plane quadrangle, we use the following measure of the shape quality:</p>", "markdown": "For a plane quadrangle, we use the following measure of the shape quality:", "text": "For a plane quadrangle, we use the following measure of the shape quality:"}, "coordinates": [{"x": 0.075, "y": 0.3964}, {"x": 0.6475, "y": 0.3964}, {"x": 0.6475, "y": 0.4138}, {"x": 0.075, "y": 0.4138}], "id": 155, "page": 13}, {"category": "table", "content": {"html": "<table id='156' style='font-size:18px'><thead></thead><tbody><tr><td>S</td><td>S min</td><td>Minimum area of the four triangles.</td></tr><tr><td>Qs = 8V2 min</td><td>with: L</td><td>Max length of the four sides and the two diagonals.</td></tr><tr><td>L P max</td><td>max P</td><td>Perimeter of the quad.</td></tr></tbody></table>", "markdown": "| S | S min | Minimum area of the four triangles. |\n| --- | --- | --- |\n| Qs = 8V2 min | with: L | Max length of the four sides and the two diagonals. |\n| L P max | max P | Perimeter of the quad. |\n", "text": "| S | S min | Minimum area of the four triangles. |\n| --- | --- | --- |\n| Qs = 8V2 min | with: L | Max length of the four sides and the two diagonals. |\n| L P max | max P | Perimeter of the quad. |\n"}, "coordinates": [{"x": 0.1031, "y": 0.4235}, {"x": 0.8757, "y": 0.4235}, {"x": 0.8757, "y": 0.4818}, {"x": 0.1031, "y": 0.4818}], "id": 156, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='157' data-category='paragraph' style='font-size:18px'>This measure gives the maximal value 1 only for a square.</p>", "markdown": "This measure gives the maximal value 1 only for a square.", "text": "This measure gives the maximal value 1 only for a square."}, "coordinates": [{"x": 0.0748, "y": 0.497}, {"x": 0.5163, "y": 0.497}, {"x": 0.5163, "y": 0.514}, {"x": 0.0748, "y": 0.514}], "id": 157, "page": 13}, {"category": "paragraph", "content": {"html": "<p id='158' data-category='paragraph' style='font-size:20px'>The size quality is given by the same measure as for the triangles (because it is based on edges only).</p>", "markdown": "The size quality is given by the same measure as for the triangles (because it is based on edges only).", "text": "The size quality is given by the same measure as for the triangles (because it is based on edges only)."}, "coordinates": [{"x": 0.0748, "y": 0.5233}, {"x": 0.84, "y": 0.5233}, {"x": 0.84, "y": 0.5409}, {"x": 0.0748, "y": 0.5409}], "id": 158, "page": 13}, {"category": "table", "content": {"html": "<table id='159' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 13 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0049, "y": 0.9481}, {"x": 1, "y": 0.9481}, {"x": 1, "y": 1}, {"x": 0.0049, "y": 1}], "id": 159, "page": 13}, {"category": "heading1", "content": {"html": "<h1 id='160' style='font-size:22px'>2. Square with an internal line</h1>", "markdown": "# 2. Square with an internal line", "text": "2. Square with an internal line"}, "coordinates": [{"x": 0.077, "y": 0.0637}, {"x": 0.4901, "y": 0.0637}, {"x": 0.4901, "y": 0.0878}, {"x": 0.077, "y": 0.0878}], "id": 160, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='161' data-category='paragraph' style='font-size:20px'>Starting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:</p>", "markdown": "Starting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:", "text": "Starting from the previous example, we add a circle inside the square. Here is the program for a triangle mesh:"}, "coordinates": [{"x": 0.076, "y": 0.0989}, {"x": 0.9151, "y": 0.0989}, {"x": 0.9151, "y": 0.1158}, {"x": 0.076, "y": 0.1158}], "id": 161, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='162' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1078, "y": 0.1526}, {"x": 0.2639, "y": 0.1526}, {"x": 0.2639, "y": 0.1634}, {"x": 0.1078, "y": 0.1634}], "id": 162, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='163' data-category='paragraph' style='font-size:16px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1094, "y": 0.1726}, {"x": 0.1903, "y": 0.1726}, {"x": 0.1903, "y": 0.184}, {"x": 0.1094, "y": 0.184}], "id": 163, "page": 14}, {"category": "paragraph", "content": {"html": "<br><p id='164' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1095, "y": 0.1827}, {"x": 0.1181, "y": 0.1827}, {"x": 0.1181, "y": 0.1919}, {"x": 0.1095, "y": 0.1919}], "id": 164, "page": 14}, {"category": "table", "content": {"html": "<br><table id='165' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.), R(3.) ;</td></tr><tr><td>const Doubtevec2</td><td>N1(10) , N2(20) ;</td></tr><tr><td>const Doub</td><td>PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ;</td></tr><tr><td>const DoubleVec2</td><td>P4(L/2 + R, L/2);</td></tr><tr><td>DoubleMat</td><td>pos ;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>", "markdown": "| const double | L(10.), R(3.) ; |\n| --- | --- |\n| const Doubtevec2 | N1(10) , N2(20) ; |\n| const Doub | PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ; |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | pos ; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n", "text": "| const double | L(10.), R(3.) ; |\n| --- | --- |\n| const Doubtevec2 | N1(10) , N2(20) ; |\n| const Doub | PO(0. , 0.) , P1(L, 0.), P2(L, L), P3(0. , L) ; |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | pos ; |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n"}, "coordinates": [{"x": 0.1268, "y": 0.1903}, {"x": 0.6355, "y": 0.1903}, {"x": 0.6355, "y": 0.2599}, {"x": 0.1268, "y": 0.2599}], "id": 165, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='166' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>triamesh_iso: : registration(\"Licensed to SMART Inc .<br>,</p>", "markdown": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\ntriamesh_iso: : registration(\"Licensed to SMART Inc .\n,", "text": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\ntriamesh_iso: : registration(\"Licensed to SMART Inc .\n,"}, "coordinates": [{"x": 0.1322, "y": 0.2657}, {"x": 0.6899, "y": 0.2657}, {"x": 0.6899, "y": 0.2892}, {"x": 0.1322, "y": 0.2892}], "id": 166, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='167' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos . push_back (PO) ;<br>pos · push_back (P1) ;<br>pos . push_back(P2) ;<br>pos · push_back (P3) ;<br>pos . push_back (P4) ;<br>meshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on<br>meshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;<br>meshtools1d : : indices_ to_connectE2(indices, connectB) ;</p>", "markdown": "11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos · push_back (P1) ;\npos . push_back(P2) ;\npos · push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on\nmeshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d : : indices_ to_connectE2(indices, connectB) ;", "text": "11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos · push_back (P1) ;\npos . push_back(P2) ;\npos · push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_strai ght (pos, ⊙, 1, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_strai ght(pos, 1, 2, N1, indices) ; indices . pop_back() on\nmeshtools1d: : mesh_straight(pos, 2, 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d : : indices_ to_connectE2(indices, connectB) ;"}, "coordinates": [{"x": 0.1309, "y": 0.2973}, {"x": 0.7056, "y": 0.2973}, {"x": 0.7056, "y": 0.4011}, {"x": 0.1309, "y": 0.4011}], "id": 167, "page": 14}, {"category": "paragraph", "content": {"html": "<br><p id='168' data-category='paragraph' style='font-size:20px'>indices.clear();</p>", "markdown": "indices.clear();", "text": "indices.clear();"}, "coordinates": [{"x": 0.1317, "y": 0.3991}, {"x": 0.2637, "y": 0.3991}, {"x": 0.2637, "y": 0.4125}, {"x": 0.1317, "y": 0.4125}], "id": 168, "page": 14}, {"category": "paragraph", "content": {"html": "<br><p id='169' data-category='paragraph' style='font-size:16px'>meshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;<br>indices.back() = indices. front();<br>meshtools1d::indices_ to_connectE2(indices, connectB) ;</p>", "markdown": "meshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;\nindices.back() = indices. front();\nmeshtools1d::indices_ to_connectE2(indices, connectB) ;", "text": "meshtools1d: :extrude rotate (pos, 4, DoubleVec2(L/2., L/2.), 2.*M_PI, N2, indices) ;\nindices.back() = indices. front();\nmeshtools1d::indices_ to_connectE2(indices, connectB) ;"}, "coordinates": [{"x": 0.1308, "y": 0.4089}, {"x": 0.7983, "y": 0.4089}, {"x": 0.7983, "y": 0.4416}, {"x": 0.1308, "y": 0.4416}], "id": 169, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='170' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH.<br>triamesh_iso: :mesher the_mesher;<br>triamesh_iso: : mesher::data_type data (pos, connectB) ;<br>the_mesher. run(data) ;</p>", "markdown": "11 THE 2D MESH.\ntriamesh_iso: :mesher the_mesher;\ntriamesh_iso: : mesher::data_type data (pos, connectB) ;\nthe_mesher. run(data) ;", "text": "11 THE 2D MESH.\ntriamesh_iso: :mesher the_mesher;\ntriamesh_iso: : mesher::data_type data (pos, connectB) ;\nthe_mesher. run(data) ;"}, "coordinates": [{"x": 0.1318, "y": 0.449}, {"x": 0.577, "y": 0.449}, {"x": 0.577, "y": 0.4879}, {"x": 0.1318, "y": 0.4879}], "id": 170, "page": 14}, {"category": "paragraph", "content": {"html": "<p id='171' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1299, "y": 0.4938}, {"x": 0.7241, "y": 0.4938}, {"x": 0.7241, "y": 0.5177}, {"x": 0.1299, "y": 0.5177}], "id": 171, "page": 14}, {"category": "paragraph", "content": {"html": "<br><p id='172' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1056, "y": 0.5242}, {"x": 0.2077, "y": 0.5242}, {"x": 0.2077, "y": 0.5459}, {"x": 0.1056, "y": 0.5459}], "id": 172, "page": 14}, {"category": "table", "content": {"html": "<table id='173' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 14 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0046, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0046, "y": 1}], "id": 173, "page": 14}, {"category": "chart", "content": {"html": "<figure id='174' data-category='chart'><img data-coord=\"top-left:(114,115); bottom-right:(593,593)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>Red</td><td>Blue</td><td>Green</td><td>Yellow</td><td>Purple</td><td>Orange</td></tr></thead><tbody><tr><td>item_01</td><td>10</td><td>12</td><td>8</td><td>5</td><td>4</td><td>3</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: line\n|  | Red | Blue | Green | Yellow | Purple | Orange |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 12 | 8 | 5 | 4 | 3 |\n", "text": "![image](/image/placeholder)\n- Chart Type: line\n|  | Red | Blue | Green | Yellow | Purple | Orange |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 12 | 8 | 5 | 4 | 3 |\n"}, "coordinates": [{"x": 0.0923, "y": 0.0661}, {"x": 0.4782, "y": 0.0661}, {"x": 0.4782, "y": 0.3382}, {"x": 0.0923, "y": 0.3382}], "id": 174, "page": 15}, {"category": "figure", "content": {"html": "<br><figure id='175'><img alt=\"\" data-coord=\"top-left:(646,115); bottom-right:(1124,592)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5206, "y": 0.0659}, {"x": 0.9061, "y": 0.0659}, {"x": 0.9061, "y": 0.3377}, {"x": 0.5206, "y": 0.3377}], "id": 175, "page": 15}, {"category": "caption", "content": {"html": "<caption id='176' style='font-size:16px'>Figure 5 - Square with internal line (T3 and all-Q4).</caption>", "markdown": "Figure 5 - Square with internal line (T3 and all-Q4).", "text": "Figure 5 - Square with internal line (T3 and all-Q4)."}, "coordinates": [{"x": 0.3441, "y": 0.3472}, {"x": 0.655, "y": 0.3472}, {"x": 0.655, "y": 0.3617}, {"x": 0.3441, "y": 0.3617}], "id": 176, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='177' data-category='paragraph' style='font-size:18px'>The mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation<br>is defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �.</p>", "markdown": "The mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation\nis defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �.", "text": "The mesh of the circle is generated with the function cm2 : : meshtools1d : : extrude_rotate. The rotation\nis defined by a center, here by the point DoubleVec2 (L/2, L/2) and a rotation scalar around Oz, here 2 �."}, "coordinates": [{"x": 0.0749, "y": 0.3964}, {"x": 0.9095, "y": 0.3964}, {"x": 0.9095, "y": 0.4278}, {"x": 0.0749, "y": 0.4278}], "id": 177, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='178' data-category='paragraph' style='font-size:18px'>The circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point<br>#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to<br>replace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only<br>coincident17:</p>", "markdown": "The circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point\n#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to\nreplace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only\ncoincident17:", "text": "The circular line is discretized using 20 elements13 starting from point #4. Here, the last generated point - point\n#24 - is coincident with the first one - point #4. In order to close topologically the circle, it is important to\nreplace value 24 with value 4 in the indices vector SO that the first and the last point are identical not only\ncoincident17:"}, "coordinates": [{"x": 0.0762, "y": 0.4369}, {"x": 0.9168, "y": 0.4369}, {"x": 0.9168, "y": 0.4961}, {"x": 0.0762, "y": 0.4961}], "id": 178, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='179' data-category='paragraph' style='font-size:14px'>indices. back() = indices. front() ;</p>", "markdown": "indices. back() = indices. front() ;", "text": "indices. back() = indices. front() ;"}, "coordinates": [{"x": 0.1053, "y": 0.5326}, {"x": 0.3772, "y": 0.5326}, {"x": 0.3772, "y": 0.5477}, {"x": 0.1053, "y": 0.5477}], "id": 179, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='180' data-category='paragraph' style='font-size:18px'>As for the external contour, these indices are converted into edges with the indices_ to_connectE2<br>function and appended to the connectB matrix.</p>", "markdown": "As for the external contour, these indices are converted into edges with the indices_ to_connectE2\nfunction and appended to the connectB matrix.", "text": "As for the external contour, these indices are converted into edges with the indices_ to_connectE2\nfunction and appended to the connectB matrix."}, "coordinates": [{"x": 0.0767, "y": 0.5885}, {"x": 0.8584, "y": 0.5885}, {"x": 0.8584, "y": 0.6197}, {"x": 0.0767, "y": 0.6197}], "id": 180, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='181' data-category='paragraph' style='font-size:20px'>Again, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,<br>if we accept some triangles we can get a better mesh.</p>", "markdown": "Again, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,\nif we accept some triangles we can get a better mesh.", "text": "Again, to mesh with quads, we simply replace the tri amesh_ iso namespace with quadmesh_ iso. Moreover,\nif we accept some triangles we can get a better mesh."}, "coordinates": [{"x": 0.0766, "y": 0.63}, {"x": 0.9175, "y": 0.63}, {"x": 0.9175, "y": 0.6604}, {"x": 0.0766, "y": 0.6604}], "id": 181, "page": 15}, {"category": "footnote", "content": {"html": "<p id='182' data-category='footnote' style='font-size:14px'>13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.<br>14 Note that the coordinates at column 24 in the pos matrix will remain unused.</p>", "markdown": "13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.\n14 Note that the coordinates at column 24 in the pos matrix will remain unused.", "text": "13 Remember that CM2 QuadMesh needs an even number of edges on each line (external and internal lines) in all-quad mode.\n14 Note that the coordinates at column 24 in the pos matrix will remain unused."}, "coordinates": [{"x": 0.0629, "y": 0.8798}, {"x": 0.8284, "y": 0.8798}, {"x": 0.8284, "y": 0.9135}, {"x": 0.0629, "y": 0.9135}], "id": 182, "page": 15}, {"category": "table", "content": {"html": "<table id='183' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials |\n| --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 15 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0101, "y": 0.9481}, {"x": 1, "y": 0.9481}, {"x": 1, "y": 1}, {"x": 0.0101, "y": 1}], "id": 183, "page": 15}, {"category": "paragraph", "content": {"html": "<p id='184' data-category='paragraph' style='font-size:22px'>Here with CM2 QuadMesh� Iso in quad-dominant mode:</p>", "markdown": "Here with CM2 QuadMesh� Iso in quad-dominant mode:", "text": "Here with CM2 QuadMesh� Iso in quad-dominant mode:"}, "coordinates": [{"x": 0.0782, "y": 0.0648}, {"x": 0.5057, "y": 0.0648}, {"x": 0.5057, "y": 0.0809}, {"x": 0.0782, "y": 0.0809}], "id": 184, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='185' data-category='paragraph' style='font-size:16px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1053, "y": 0.1178}, {"x": 0.2639, "y": 0.1178}, {"x": 0.2639, "y": 0.1297}, {"x": 0.1053, "y": 0.1297}], "id": 185, "page": 16}, {"category": "paragraph", "content": {"html": "<br><p id='186' data-category='paragraph' style='font-size:16px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1091, "y": 0.1372}, {"x": 0.1906, "y": 0.1372}, {"x": 0.1906, "y": 0.1494}, {"x": 0.1091, "y": 0.1494}], "id": 186, "page": 16}, {"category": "paragraph", "content": {"html": "<br><p id='187' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1095, "y": 0.1483}, {"x": 0.1181, "y": 0.1483}, {"x": 0.1181, "y": 0.1579}, {"x": 0.1095, "y": 0.1579}], "id": 187, "page": 16}, {"category": "table", "content": {"html": "<br><table id='188' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(10) , R(3.) ·</td></tr><tr><td>const unsigned</td><td>N1(10), N2(20);</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>const DoubleVec2</td><td>0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R;</td></tr><tr><td>const DoubleVec2</td><td>L/2);</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>", "markdown": "| const double | L(10) , R(3.) · |\n| --- | --- |\n| const unsigned | N1(10), N2(20); |\n| DoubleMat | pos; |\n| const DoubleVec2 | 0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R; |\n| const DoubleVec2 | L/2); |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n", "text": "| const double | L(10) , R(3.) · |\n| --- | --- |\n| const unsigned | N1(10), N2(20); |\n| DoubleMat | pos; |\n| const DoubleVec2 | 0.), P1(L, 0.), P2(L, L), P3(0. , L) ; P4(L/2+R; |\n| const DoubleVec2 | L/2); |\n| UIntVec | indices; |\n| UIntMat | connectB; |\n"}, "coordinates": [{"x": 0.1272, "y": 0.1567}, {"x": 0.6358, "y": 0.1567}, {"x": 0.6358, "y": 0.2254}, {"x": 0.1272, "y": 0.2254}], "id": 188, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='189' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>\" \"F53EA108BCWX\") ;<br>quadmesh_iso: : registration(\"Licensed to SMART Inc .<br>,</p>", "markdown": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso: : registration(\"Licensed to SMART Inc .\n,", "text": "11 UNLOCK THE DLL.\n\" \"F53EA108BCWX\") ;\nquadmesh_iso: : registration(\"Licensed to SMART Inc .\n,"}, "coordinates": [{"x": 0.1308, "y": 0.2314}, {"x": 0.6916, "y": 0.2314}, {"x": 0.6916, "y": 0.2548}, {"x": 0.1308, "y": 0.2548}], "id": 189, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='190' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos. push_back (PO) ;<br>pos . push_back (P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;<br>pos . push_back (P4) ;<br>meshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;<br>meshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;<br>meshtools1d: :indices_to_connectE2(indices, connectB) ;<br>indices.clear() ;<br>meshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;<br>indices. back() = indices. front() ;<br>meshtools1d: :indices_to_connectE2 (indices, connectB) ;</p>", "markdown": "11 VERTICES AND LINE MESHES.\npos. push_back (PO) ;\npos . push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d: :indices_to_connectE2(indices, connectB) ;\nindices.clear() ;\nmeshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;\nindices. back() = indices. front() ;\nmeshtools1d: :indices_to_connectE2 (indices, connectB) ;", "text": "11 VERTICES AND LINE MESHES.\npos. push_back (PO) ;\npos . push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d: : mesh_straight(pos, ⊙, 1, N1 , indices) ; indices.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1 , 2, N1 , indices) ; indices. pop_back() ;\nmeshtools1d: :mesh_straight(pos, 2 , 3, N1, indices) ; indices. pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, N1, indices) ;\nmeshtools1d: :indices_to_connectE2(indices, connectB) ;\nindices.clear() ;\nmeshtools1d: :extrude_ rotate(pos, 4, DoubleVec2(L/2., L/2.) , 2. *M_PI, N2, indices) ;\nindices. back() = indices. front() ;\nmeshtools1d: :indices_to_connectE2 (indices, connectB) ;"}, "coordinates": [{"x": 0.1327, "y": 0.2631}, {"x": 0.7968, "y": 0.2631}, {"x": 0.7968, "y": 0.4059}, {"x": 0.1327, "y": 0.4059}], "id": 190, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='191' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.</p>", "markdown": "11 THE 2D MESH.", "text": "11 THE 2D MESH."}, "coordinates": [{"x": 0.1335, "y": 0.4137}, {"x": 0.2537, "y": 0.4137}, {"x": 0.2537, "y": 0.4236}, {"x": 0.1335, "y": 0.4236}], "id": 191, "page": 16}, {"category": "paragraph", "content": {"html": "<br><p id='192' data-category='paragraph' style='font-size:16px'>quadmesh_iso: :mesher the_mesher;<br>quadmesh_iso: :mesher: :data_type data(pos, connectB) ;<br>the_mesher.settings.all_quad_flag = false;<br>the_mesher run(data) ;</p>", "markdown": "quadmesh_iso: :mesher the_mesher;\nquadmesh_iso: :mesher: :data_type data(pos, connectB) ;\nthe_mesher.settings.all_quad_flag = false;\nthe_mesher run(data) ;", "text": "quadmesh_iso: :mesher the_mesher;\nquadmesh_iso: :mesher: :data_type data(pos, connectB) ;\nthe_mesher.settings.all_quad_flag = false;\nthe_mesher run(data) ;"}, "coordinates": [{"x": 0.1313, "y": 0.4172}, {"x": 0.5786, "y": 0.4172}, {"x": 0.5786, "y": 0.4613}, {"x": 0.1313, "y": 0.4613}], "id": 192, "page": 16}, {"category": "paragraph", "content": {"html": "<p id='193' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;", "text": "11 VISUALIZATION.\nmeshtools : : mecit_output(\"out.mesh\" , data.pos, data. connectM, CM2_FACE_MIX) ;"}, "coordinates": [{"x": 0.1301, "y": 0.4695}, {"x": 0.74, "y": 0.4695}, {"x": 0.74, "y": 0.4924}, {"x": 0.1301, "y": 0.4924}], "id": 193, "page": 16}, {"category": "paragraph", "content": {"html": "<br><p id='194' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.106, "y": 0.4996}, {"x": 0.2074, "y": 0.4996}, {"x": 0.2074, "y": 0.52}, {"x": 0.106, "y": 0.52}], "id": 194, "page": 16}, {"category": "chart", "content": {"html": "<figure id='195' data-category='chart'><img data-coord=\"top-left:(379,1005); bottom-right:(860,1482)\" /><figcaption><p>Chart Type: pie</p></figcaption><table><thead><tr><td></td><td>Purple</td><td>Orange</td><td>Red</td><td>Blue</td><td>Green</td></tr></thead><tbody><tr><td>item_01</td><td>20%</td><td>20%</td><td>20%</td><td>20%</td><td>20%</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: pie\n|  | Purple | Orange | Red | Blue | Green |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 20% | 20% | 20% | 20% | 20% |\n", "text": "![image](/image/placeholder)\n- Chart Type: pie\n|  | Purple | Orange | Red | Blue | Green |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 20% | 20% | 20% | 20% | 20% |\n"}, "coordinates": [{"x": 0.3056, "y": 0.5734}, {"x": 0.6934, "y": 0.5734}, {"x": 0.6934, "y": 0.8452}, {"x": 0.3056, "y": 0.8452}], "id": 195, "page": 16}, {"category": "caption", "content": {"html": "<caption id='196' style='font-size:16px'>Figure 6 - Square with internal line (quad-dominant mode).</caption>", "markdown": "Figure 6 - Square with internal line (quad-dominant mode).", "text": "Figure 6 - Square with internal line (quad-dominant mode)."}, "coordinates": [{"x": 0.318, "y": 0.8555}, {"x": 0.6793, "y": 0.8555}, {"x": 0.6793, "y": 0.8697}, {"x": 0.318, "y": 0.8697}], "id": 196, "page": 16}, {"category": "table", "content": {"html": "<table id='197' style='font-size:20px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 16 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0046, "y": 0.9474}, {"x": 1, "y": 0.9474}, {"x": 1, "y": 1}, {"x": 0.0046, "y": 1}], "id": 197, "page": 16}, {"category": "heading1", "content": {"html": "<h1 id='198' style='font-size:22px'>3. Square with internal hole</h1>", "markdown": "# 3. Square with internal hole", "text": "3. Square with internal hole"}, "coordinates": [{"x": 0.0771, "y": 0.0638}, {"x": 0.4587, "y": 0.0638}, {"x": 0.4587, "y": 0.0878}, {"x": 0.0771, "y": 0.0878}], "id": 198, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='199' data-category='paragraph' style='font-size:18px'>A hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that<br>this implies that all edges of the external contour should be oriented in a uniform way (either clockwise or<br>counter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert<br>the orientation of the internal edges and thus to remove the disk from the domain:</p>", "markdown": "A hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that\nthis implies that all edges of the external contour should be oriented in a uniform way (either clockwise or\ncounter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert\nthe orientation of the internal edges and thus to remove the disk from the domain:", "text": "A hole is an internal closed contour with edges oriented the opposite way from the external contour. Note that\nthis implies that all edges of the external contour should be oriented in a uniform way (either clockwise or\ncounter-clockwise15). Based on the previous example, we simply change the sign of the rotation vector to revert\nthe orientation of the internal edges and thus to remove the disk from the domain:"}, "coordinates": [{"x": 0.0764, "y": 0.0986}, {"x": 0.9209, "y": 0.0986}, {"x": 0.9209, "y": 0.1579}, {"x": 0.0764, "y": 0.1579}], "id": 199, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='200' data-category='paragraph' style='font-size:14px'>meshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;</p>", "markdown": "meshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;", "text": "meshtools1d : : extrude_rotate (pos, 4, DoubleVec3 (L/2., L/2.), -2.*M_PI, N2, indices) ;"}, "coordinates": [{"x": 0.1048, "y": 0.1937}, {"x": 0.7806, "y": 0.1937}, {"x": 0.7806, "y": 0.2088}, {"x": 0.1048, "y": 0.2088}], "id": 200, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='201' data-category='paragraph' style='font-size:20px'>And the resulting meshes:</p>", "markdown": "And the resulting meshes:", "text": "And the resulting meshes:"}, "coordinates": [{"x": 0.077, "y": 0.2512}, {"x": 0.2795, "y": 0.2512}, {"x": 0.2795, "y": 0.2669}, {"x": 0.077, "y": 0.2669}], "id": 201, "page": 17}, {"category": "figure", "content": {"html": "<figure id='202'><img alt=\"\" data-coord=\"top-left:(97,481); bottom-right:(572,954)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0786, "y": 0.2742}, {"x": 0.4609, "y": 0.2742}, {"x": 0.4609, "y": 0.5441}, {"x": 0.0786, "y": 0.5441}], "id": 202, "page": 17}, {"category": "figure", "content": {"html": "<br><figure id='203'><img alt=\"\" data-coord=\"top-left:(628,480); bottom-right:(1107,952)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.506, "y": 0.2739}, {"x": 0.8921, "y": 0.2739}, {"x": 0.8921, "y": 0.5433}, {"x": 0.506, "y": 0.5433}], "id": 203, "page": 17}, {"category": "caption", "content": {"html": "<caption id='204' style='font-size:14px'>Figure 7 - Square with a circular hole (T3 and all-Q4).</caption>", "markdown": "Figure 7 - Square with a circular hole (T3 and all-Q4).", "text": "Figure 7 - Square with a circular hole (T3 and all-Q4)."}, "coordinates": [{"x": 0.3371, "y": 0.559}, {"x": 0.6615, "y": 0.559}, {"x": 0.6615, "y": 0.574}, {"x": 0.3371, "y": 0.574}], "id": 204, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='205' data-category='paragraph' style='font-size:14px'>15 Without any closed internal hard line, the orientation of the external contour is irrelevant.</p>", "markdown": "15 Without any closed internal hard line, the orientation of the external contour is irrelevant.", "text": "15 Without any closed internal hard line, the orientation of the external contour is irrelevant."}, "coordinates": [{"x": 0.0635, "y": 0.8984}, {"x": 0.6188, "y": 0.8984}, {"x": 0.6188, "y": 0.9131}, {"x": 0.0635, "y": 0.9131}], "id": 205, "page": 17}, {"category": "table", "content": {"html": "<table id='206' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 17 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0069, "y": 0.9478}, {"x": 1, "y": 0.9478}, {"x": 1, "y": 1}, {"x": 0.0069, "y": 1}], "id": 206, "page": 17}, {"category": "paragraph", "content": {"html": "<p id='207' data-category='paragraph' style='font-size:20px'>One can nest alternatively positive and negative rotations:</p>", "markdown": "One can nest alternatively positive and negative rotations:", "text": "One can nest alternatively positive and negative rotations:"}, "coordinates": [{"x": 0.0759, "y": 0.0647}, {"x": 0.5185, "y": 0.0647}, {"x": 0.5185, "y": 0.081}, {"x": 0.0759, "y": 0.081}], "id": 207, "page": 18}, {"category": "figure", "content": {"html": "<figure id='208'><img alt=\"\" data-coord=\"top-left:(111,174); bottom-right:(591,653)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0895, "y": 0.0997}, {"x": 0.4762, "y": 0.0997}, {"x": 0.4762, "y": 0.3727}, {"x": 0.0895, "y": 0.3727}], "id": 208, "page": 18}, {"category": "figure", "content": {"html": "<br><figure id='209'><img alt=\"\" data-coord=\"top-left:(650,171); bottom-right:(1132,658)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5239, "y": 0.0978}, {"x": 0.9124, "y": 0.0978}, {"x": 0.9124, "y": 0.3754}, {"x": 0.5239, "y": 0.3754}], "id": 209, "page": 18}, {"category": "caption", "content": {"html": "<caption id='210' style='font-size:14px'>Figure 8 - Concentric circles with alternate orientation (T3 and all-Q4).</caption>", "markdown": "Figure 8 - Concentric circles with alternate orientation (T3 and all-Q4).", "text": "Figure 8 - Concentric circles with alternate orientation (T3 and all-Q4)."}, "coordinates": [{"x": 0.2863, "y": 0.3838}, {"x": 0.7106, "y": 0.3838}, {"x": 0.7106, "y": 0.3974}, {"x": 0.2863, "y": 0.3974}], "id": 210, "page": 18}, {"category": "table", "content": {"html": "<table id='211' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 18 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0048, "y": 0.948}, {"x": 1, "y": 0.948}, {"x": 1, "y": 1}, {"x": 0.0048, "y": 1}], "id": 211, "page": 18}, {"category": "heading1", "content": {"html": "<h1 id='212' style='font-size:22px'>4. Quadratic elements & high-order nodes</h1>", "markdown": "# 4. Quadratic elements & high-order nodes", "text": "4. Quadratic elements & high-order nodes"}, "coordinates": [{"x": 0.0765, "y": 0.0637}, {"x": 0.66, "y": 0.0637}, {"x": 0.66, "y": 0.0885}, {"x": 0.0765, "y": 0.0885}], "id": 212, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='213' data-category='paragraph' style='font-size:20px'>Let us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we<br>would like also the edges along the circular hole to be curved.</p>", "markdown": "Let us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we\nwould like also the edges along the circular hole to be curved.", "text": "Let us derive the example 3 \"Square with internal hole\" to generate quadratic T6 elements. In addition, we\nwould like also the edges along the circular hole to be curved."}, "coordinates": [{"x": 0.0761, "y": 0.099}, {"x": 0.8791, "y": 0.099}, {"x": 0.8791, "y": 0.1288}, {"x": 0.0761, "y": 0.1288}], "id": 213, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='214' data-category='paragraph' style='font-size:16px'>For that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :<br>: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic.</p>", "markdown": "For that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :\n: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic.", "text": "For that matter we use the conversion functions cm2 : : meshtools1d : : convert_ into_quadratic, cm2 :\n: meshtools1d : : convert_ into_linear and cm2 : : meshtools2d : :convert_ into_quadratic."}, "coordinates": [{"x": 0.0791, "y": 0.14}, {"x": 0.9112, "y": 0.14}, {"x": 0.9112, "y": 0.1704}, {"x": 0.0791, "y": 0.1704}], "id": 214, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='215' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1054, "y": 0.2068}, {"x": 0.2642, "y": 0.2068}, {"x": 0.2642, "y": 0.2189}, {"x": 0.1054, "y": 0.2189}], "id": 215, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='216' data-category='paragraph' style='font-size:16px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.109, "y": 0.2264}, {"x": 0.1907, "y": 0.2264}, {"x": 0.1907, "y": 0.2388}, {"x": 0.109, "y": 0.2388}], "id": 216, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='217' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.2373}, {"x": 0.1187, "y": 0.2373}, {"x": 0.1187, "y": 0.2466}, {"x": 0.1094, "y": 0.2466}], "id": 217, "page": 19}, {"category": "table", "content": {"html": "<br><table id='218' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.), R(3.) in</td></tr><tr><td>const unsigned</td><td>N1(10); N2(20) �.),</td></tr><tr><td>const Doub [eVec2</td><td>P2(L, L) , P3(0 * , L) ; P1(L,</td></tr><tr><td>const DoubleVec2</td><td>P4(L/2 + R, L/2);</td></tr><tr><td>DoubleMat</td><td>indices;</td></tr><tr><td>UIntVec</td><td></td></tr><tr><td>UIntMat</td><td>connectB, connectE2;</td></tr></tbody></table>", "markdown": "| const double | L(10.), R(3.) in |\n| --- | --- |\n| const unsigned | N1(10); N2(20) �.), |\n| const Doub [eVec2 | P2(L, L) , P3(0 * , L) ; P1(L, |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | indices; |\n| UIntVec |  |\n| UIntMat | connectB, connectE2; |\n", "text": "| const double | L(10.), R(3.) in |\n| --- | --- |\n| const unsigned | N1(10); N2(20) �.), |\n| const Doub [eVec2 | P2(L, L) , P3(0 * , L) ; P1(L, |\n| const DoubleVec2 | P4(L/2 + R, L/2); |\n| DoubleMat | indices; |\n| UIntVec |  |\n| UIntMat | connectB, connectE2; |\n"}, "coordinates": [{"x": 0.1273, "y": 0.2454}, {"x": 0.606, "y": 0.2454}, {"x": 0.606, "y": 0.3148}, {"x": 0.1273, "y": 0.3148}], "id": 218, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='219' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1331, "y": 0.3204}, {"x": 0.689, "y": 0.3204}, {"x": 0.689, "y": 0.3435}, {"x": 0.1331, "y": 0.3435}], "id": 219, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='220' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.<br>pos · push_back (PO) ;<br>pos · push_back (P1) ;<br>pos · push_back (P2) ;<br>pos · push_back (P3) ;<br>meshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;<br>. push_back (P4) ;<br>meshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on<br>meshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;<br>meshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;<br>meshtools1d: : indices_ to_connectE2(indices, connectB) ;<br>meshtools1d: : convert_into_quadratic(pos, connectB);<br>indi ces. clear () ;<br>meshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;<br>indi ces. back() = indi ces. front() ;<br>meshtools1d: :indices_ to_connectE3(indices, connectB) ;<br>connectE2.copy (connectB) ;<br>meshtools1d: :convert_into_linear (connectE2) ;</p>", "markdown": "11 VERTICES AND LINE MESHES.\npos · push_back (PO) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos · push_back (P3) ;\nmeshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;\n. push_back (P4) ;\nmeshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on\nmeshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;\nmeshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\nmeshtools1d: : convert_into_quadratic(pos, connectB);\nindi ces. clear () ;\nmeshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;\nindi ces. back() = indi ces. front() ;\nmeshtools1d: :indices_ to_connectE3(indices, connectB) ;\nconnectE2.copy (connectB) ;\nmeshtools1d: :convert_into_linear (connectE2) ;", "text": "11 VERTICES AND LINE MESHES.\npos · push_back (PO) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos · push_back (P3) ;\nmeshoolsid : : mesh_strai ght (pos, 日, 1, N1, indices) ; indices . pop_back() ;\n. push_back (P4) ;\nmeshtools1d : : mesh_strai ght (pos, 1, 2, N1, indices) ; indi ces · pop_back() on\nmeshtools1d : : mesh_strai ght (pos, 2 , 3, N1 , indices) ; indices · pop_back() ;\nmeshtools1d : : mesh_strai ght (pos, 3 , 日, N1, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\nmeshtools1d: : convert_into_quadratic(pos, connectB);\nindi ces. clear () ;\nmeshtools1d : :extrude_ rotate(pos, 4, DoubleVec2(L/2, L/2) , -2 * M_PI, 2 * N2, indices) ;\nindi ces. back() = indi ces. front() ;\nmeshtools1d: :indices_ to_connectE3(indices, connectB) ;\nconnectE2.copy (connectB) ;\nmeshtools1d: :convert_into_linear (connectE2) ;"}, "coordinates": [{"x": 0.1307, "y": 0.3521}, {"x": 0.8292, "y": 0.3521}, {"x": 0.8292, "y": 0.5255}, {"x": 0.1307, "y": 0.5255}], "id": 220, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='221' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here.</p>", "markdown": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here.", "text": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data (pos, connectE2) ; / / Linear edges here."}, "coordinates": [{"x": 0.1322, "y": 0.5326}, {"x": 0.7819, "y": 0.5326}, {"x": 0.7819, "y": 0.5646}, {"x": 0.1322, "y": 0.5646}], "id": 221, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='222' data-category='paragraph' style='font-size:14px'>the_mesher. run (data) ;</p>", "markdown": "the_mesher. run (data) ;", "text": "the_mesher. run (data) ;"}, "coordinates": [{"x": 0.132, "y": 0.5596}, {"x": 0.3027, "y": 0.5596}, {"x": 0.3027, "y": 0.5713}, {"x": 0.132, "y": 0.5713}], "id": 222, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='223' data-category='paragraph' style='font-size:16px'>meshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;</p>", "markdown": "meshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;", "text": "meshtools2d: :convert_into_quadratic(data.pos, data.connectM, connectB) ;"}, "coordinates": [{"x": 0.1321, "y": 0.5684}, {"x": 0.7093, "y": 0.5684}, {"x": 0.7093, "y": 0.5819}, {"x": 0.1321, "y": 0.5819}], "id": 223, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='224' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET6) ;"}, "coordinates": [{"x": 0.1319, "y": 0.5865}, {"x": 0.7235, "y": 0.5865}, {"x": 0.7235, "y": 0.6106}, {"x": 0.1319, "y": 0.6106}], "id": 224, "page": 19}, {"category": "paragraph", "content": {"html": "<br><p id='225' data-category='paragraph' style='font-size:14px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1053, "y": 0.6171}, {"x": 0.2068, "y": 0.6171}, {"x": 0.2068, "y": 0.6381}, {"x": 0.1053, "y": 0.6381}], "id": 225, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='226' data-category='paragraph' style='font-size:20px'>To keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter<br>(this will create new high-order nodes, different from those in connectB):</p>", "markdown": "To keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter\n(this will create new high-order nodes, different from those in connectB):", "text": "To keep the boundary edges straight (not curved) we convert T3 into T616 without the connectB parameter\n(this will create new high-order nodes, different from those in connectB):"}, "coordinates": [{"x": 0.0751, "y": 0.6804}, {"x": 0.8912, "y": 0.6804}, {"x": 0.8912, "y": 0.7117}, {"x": 0.0751, "y": 0.7117}], "id": 226, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='227' data-category='paragraph' style='font-size:16px'>meshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;</p>", "markdown": "meshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;", "text": "meshtools2d : :convert_into_quadratic(data.pos, data.connectM) ;"}, "coordinates": [{"x": 0.1056, "y": 0.7477}, {"x": 0.6025, "y": 0.7477}, {"x": 0.6025, "y": 0.7629}, {"x": 0.1056, "y": 0.7629}], "id": 227, "page": 19}, {"category": "footnote", "content": {"html": "<p id='228' data-category='footnote' style='font-size:14px'>16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_<br>order · Refer to the HTML reference manual for detailed information.</p>", "markdown": "16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_\norder · Refer to the HTML reference manual for detailed information.", "text": "16 A more general function is available to convert into any type of high-order elements:. cm2 : :meshtools2d: :convert_into_high_\norder · Refer to the HTML reference manual for detailed information."}, "coordinates": [{"x": 0.0655, "y": 0.8875}, {"x": 0.8861, "y": 0.8875}, {"x": 0.8861, "y": 0.9131}, {"x": 0.0655, "y": 0.9131}], "id": 228, "page": 19}, {"category": "table", "content": {"html": "<table id='229' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>19</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 19 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0108, "y": 0.9479}, {"x": 0.9999, "y": 0.9479}, {"x": 0.9999, "y": 1}, {"x": 0.0108, "y": 1}], "id": 229, "page": 19}, {"category": "paragraph", "content": {"html": "<p id='230' data-category='paragraph' style='font-size:18px'>This would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity<br>matrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly<br>interpolated between the initial vertices, all the edges would remain straight.</p>", "markdown": "This would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity\nmatrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly\ninterpolated between the initial vertices, all the edges would remain straight.", "text": "This would create and push new (high-order) nodes into matrix data · pos and convert the T3 connectivity\nmatrix data · connectM into a T6 connectivity matrix gaining three new rows. The new nodes being linearly\ninterpolated between the initial vertices, all the edges would remain straight."}, "coordinates": [{"x": 0.0755, "y": 0.0644}, {"x": 0.8901, "y": 0.0644}, {"x": 0.8901, "y": 0.1091}, {"x": 0.0755, "y": 0.1091}], "id": 230, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='231' data-category='paragraph' style='font-size:20px'>This is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity<br>matrix of the boundary edges (or some of them) is usually required later to setup boundary conditions<br>(Dirichlet, Neumann...)</p>", "markdown": "This is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity\nmatrix of the boundary edges (or some of them) is usually required later to setup boundary conditions\n(Dirichlet, Neumann...)", "text": "This is not what we want here (we want the edges along the circle to be curved). Moreover, the connectivity\nmatrix of the boundary edges (or some of them) is usually required later to setup boundary conditions\n(Dirichlet, Neumann...)"}, "coordinates": [{"x": 0.077, "y": 0.1193}, {"x": 0.8869, "y": 0.1193}, {"x": 0.8869, "y": 0.1637}, {"x": 0.077, "y": 0.1637}], "id": 231, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='232' data-category='paragraph' style='font-size:20px'>So, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-<br>node edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):</p>", "markdown": "So, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-\nnode edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):", "text": "So, for the outer square we use meshtools2d : : convert_ to_ quadratic to convert linear edges into 3-\nnode edges creating and pushing new high-order nodes into matrix pos (created at the centers of the edges):"}, "coordinates": [{"x": 0.0766, "y": 0.1744}, {"x": 0.9098, "y": 0.1744}, {"x": 0.9098, "y": 0.206}, {"x": 0.0766, "y": 0.206}], "id": 232, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='233' data-category='paragraph' style='font-size:16px'>meshtools1d : : convert_into_quadratic (pos, connectB) ;</p>", "markdown": "meshtools1d : : convert_into_quadratic (pos, connectB) ;", "text": "meshtools1d : : convert_into_quadratic (pos, connectB) ;"}, "coordinates": [{"x": 0.1048, "y": 0.2409}, {"x": 0.5222, "y": 0.2409}, {"x": 0.5222, "y": 0.2558}, {"x": 0.1048, "y": 0.2558}], "id": 233, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='234' data-category='paragraph' style='font-size:18px'>The connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are<br>unchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17).</p>", "markdown": "The connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are\nunchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17).", "text": "The connectivity matrix connectB gains one new row (the new high-order nodes). The first two rows are\nunchanged. A matrix view to these first two rows is equivalent to the initial connectivity matrix (linear edges17)."}, "coordinates": [{"x": 0.0755, "y": 0.2969}, {"x": 0.9064, "y": 0.2969}, {"x": 0.9064, "y": 0.3286}, {"x": 0.0755, "y": 0.3286}], "id": 234, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='235' data-category='paragraph' style='font-size:16px'>0</p>", "markdown": "0", "text": "0"}, "coordinates": [{"x": 0.2732, "y": 0.3513}, {"x": 0.2845, "y": 0.3513}, {"x": 0.2845, "y": 0.3616}, {"x": 0.2732, "y": 0.3616}], "id": 235, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='236' data-category='paragraph' style='font-size:16px'>linear nodes</p>", "markdown": "linear nodes", "text": "linear nodes"}, "coordinates": [{"x": 0.1674, "y": 0.3596}, {"x": 0.2492, "y": 0.3596}, {"x": 0.2492, "y": 0.372}, {"x": 0.1674, "y": 0.372}], "id": 236, "page": 20}, {"category": "paragraph", "content": {"html": "<br><p id='237' data-category='paragraph' style='font-size:14px'>1</p>", "markdown": "1", "text": "1"}, "coordinates": [{"x": 0.2747, "y": 0.3703}, {"x": 0.282, "y": 0.3703}, {"x": 0.282, "y": 0.379}, {"x": 0.2747, "y": 0.379}], "id": 237, "page": 20}, {"category": "table", "content": {"html": "<br><table id='238' style='font-size:16px'><thead><tr><td></td><td>1</td><td>2 3</td><td>4</td><td>6</td><td>8</td><td>10</td></tr></thead><tbody><tr><td></td><td>2</td><td>3</td><td>4</td><td>5 7</td><td>9</td><td>11</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16 17</td><td>18</td><td>19</td></tr></tbody></table>", "markdown": "|  | 1 | 2 3 | 4 | 6 | 8 | 10 |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 2 | 3 | 4 | 5 7 | 9 | 11 |\n| 12 | 13 | 14 | 15 | 16 17 | 18 | 19 |\n", "text": "|  | 1 | 2 3 | 4 | 6 | 8 | 10 |\n| --- | --- | --- | --- | --- | --- | --- |\n|  | 2 | 3 | 4 | 5 7 | 9 | 11 |\n| 12 | 13 | 14 | 15 | 16 17 | 18 | 19 |\n"}, "coordinates": [{"x": 0.2804, "y": 0.3454}, {"x": 0.8374, "y": 0.3454}, {"x": 0.8374, "y": 0.4017}, {"x": 0.2804, "y": 0.4017}], "id": 238, "page": 20}, {"category": "caption", "content": {"html": "<caption id='239' style='font-size:16px'>Figure 9 - Example of connectivity matrix for quadratic edges and view to linear edges.</caption>", "markdown": "Figure 9 - Example of connectivity matrix for quadratic edges and view to linear edges.", "text": "Figure 9 - Example of connectivity matrix for quadratic edges and view to linear edges."}, "coordinates": [{"x": 0.2758, "y": 0.4121}, {"x": 0.8018, "y": 0.4121}, {"x": 0.8018, "y": 0.4269}, {"x": 0.2758, "y": 0.4269}], "id": 239, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='240' data-category='paragraph' style='font-size:20px'>For the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence<br>of node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).<br>This is possible because we have generated along the circle twice as much nodes as in the previous example<br>(extrude_rotate with 2 N2).</p>", "markdown": "For the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence\nof node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).\nThis is possible because we have generated along the circle twice as much nodes as in the previous example\n(extrude_rotate with 2 N2).", "text": "For the inner circle, we create quadratic edges directly with indice_ to_connectE3 to transform a sequence\nof node indices into a quadratic connectivity matrix, as illustrated by the second set of edges (along the circle).\nThis is possible because we have generated along the circle twice as much nodes as in the previous example\n(extrude_rotate with 2 N2)."}, "coordinates": [{"x": 0.0768, "y": 0.4616}, {"x": 0.9132, "y": 0.4616}, {"x": 0.9132, "y": 0.5198}, {"x": 0.0768, "y": 0.5198}], "id": 240, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='241' data-category='paragraph' style='font-size:22px'>Now we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along<br>the circle.</p>", "markdown": "Now we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along\nthe circle.", "text": "Now we have quadratic edges all along the boundaries. Straight edges along the square, curved edges along\nthe circle."}, "coordinates": [{"x": 0.077, "y": 0.531}, {"x": 0.8971, "y": 0.531}, {"x": 0.8971, "y": 0.5607}, {"x": 0.077, "y": 0.5607}], "id": 241, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='242' data-category='paragraph' style='font-size:20px'>However, the mesh generators accept only linear edges upon entry and give only linear face elements upon<br>exit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called<br>connectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear<br>edges with convert_ into_ linear.</p>", "markdown": "However, the mesh generators accept only linear edges upon entry and give only linear face elements upon\nexit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called\nconnectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear\nedges with convert_ into_ linear.", "text": "However, the mesh generators accept only linear edges upon entry and give only linear face elements upon\nexit. Hence, we have to feed the mesher with the linear view of the connectB edge connectivity matrix (called\nconnectE2 in the example). For that matter, we duplicate connectB and transform the copy back into linear\nedges with convert_ into_ linear."}, "coordinates": [{"x": 0.077, "y": 0.5716}, {"x": 0.9106, "y": 0.5716}, {"x": 0.9106, "y": 0.6291}, {"x": 0.077, "y": 0.6291}], "id": 242, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='243' data-category='paragraph' style='font-size:20px'>After the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes<br>along the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity<br>matrix connectB created before:</p>", "markdown": "After the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes\nalong the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity\nmatrix connectB created before:", "text": "After the surface meshing, to transform the linear T3 faces into T6 faces and to reuse the quadratic nodes\nalong the boundaries (and then keeping curved edges along the circle), we pass the quadratic edge connectivity\nmatrix connectB created before:"}, "coordinates": [{"x": 0.0771, "y": 0.6405}, {"x": 0.9214, "y": 0.6405}, {"x": 0.9214, "y": 0.6852}, {"x": 0.0771, "y": 0.6852}], "id": 243, "page": 20}, {"category": "footnote", "content": {"html": "<p id='244' data-category='footnote' style='font-size:14px'>meshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;</p>", "markdown": "meshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;", "text": "meshtools2d : : convert_into_quadratic (data.pos, data connectM, connectB ) ;"}, "coordinates": [{"x": 0.1048, "y": 0.7215}, {"x": 0.6824, "y": 0.7215}, {"x": 0.6824, "y": 0.7364}, {"x": 0.1048, "y": 0.7364}], "id": 244, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='245' data-category='paragraph' style='font-size:20px'>This forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match.</p>", "markdown": "This forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match.", "text": "This forces convert_into_quadratic to use the high-order nodes of connectB wherever edges match."}, "coordinates": [{"x": 0.0753, "y": 0.7777}, {"x": 0.8911, "y": 0.7777}, {"x": 0.8911, "y": 0.795}, {"x": 0.0753, "y": 0.795}], "id": 245, "page": 20}, {"category": "paragraph", "content": {"html": "<p id='246' data-category='paragraph' style='font-size:16px'>17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them.</p>", "markdown": "17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them.", "text": "17 Note that the mid-side node is local node #2 after the linear nodes #0 and #1 though geometrically placed between them."}, "coordinates": [{"x": 0.0637, "y": 0.8983}, {"x": 0.8197, "y": 0.8983}, {"x": 0.8197, "y": 0.9132}, {"x": 0.0637, "y": 0.9132}], "id": 246, "page": 20}, {"category": "table", "content": {"html": "<table id='247' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>20 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 20 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 20 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0087, "y": 0.9479}, {"x": 0.9999, "y": 0.9479}, {"x": 0.9999, "y": 1}, {"x": 0.0087, "y": 1}], "id": 247, "page": 20}, {"category": "heading1", "content": {"html": "<h1 id='248' style='font-size:22px'>5. Square with grading mesh size</h1>", "markdown": "# 5. Square with grading mesh size", "text": "5. Square with grading mesh size"}, "coordinates": [{"x": 0.0766, "y": 0.0633}, {"x": 0.5332, "y": 0.0633}, {"x": 0.5332, "y": 0.0888}, {"x": 0.0766, "y": 0.0888}], "id": 248, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='249' data-category='paragraph' style='font-size:20px'>There are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along<br>the boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates<br>these values inside the domain and generates elements accordingly.</p>", "markdown": "There are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along\nthe boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates\nthese values inside the domain and generates elements accordingly.", "text": "There are two ways to get a graded size in a mesh. First, you can simply generate edges with varying size along\nthe boundary (or interior lines). The mesher computes a default size value on each hard node18, interpolates\nthese values inside the domain and generates elements accordingly."}, "coordinates": [{"x": 0.0759, "y": 0.0989}, {"x": 0.9139, "y": 0.0989}, {"x": 0.9139, "y": 0.1434}, {"x": 0.0759, "y": 0.1434}], "id": 249, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='250' data-category='paragraph' style='font-size:20px'>To illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of<br>the contour we specify different mesh sizes on each four vertices:</p>", "markdown": "To illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of\nthe contour we specify different mesh sizes on each four vertices:", "text": "To illustrate this, let us use again the example of the square. Instead of meshing regularly the four segments of\nthe contour we specify different mesh sizes on each four vertices:"}, "coordinates": [{"x": 0.0757, "y": 0.1534}, {"x": 0.9169, "y": 0.1534}, {"x": 0.9169, "y": 0.1841}, {"x": 0.0757, "y": 0.1841}], "id": 250, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='251' data-category='paragraph' style='font-size:14px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1049, "y": 0.2209}, {"x": 0.2641, "y": 0.2209}, {"x": 0.2641, "y": 0.2335}, {"x": 0.1049, "y": 0.2335}], "id": 251, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='252' data-category='paragraph' style='font-size:16px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.109, "y": 0.2414}, {"x": 0.19, "y": 0.2414}, {"x": 0.19, "y": 0.2533}, {"x": 0.109, "y": 0.2533}], "id": 252, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='253' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.2514}, {"x": 0.1187, "y": 0.2514}, {"x": 0.1187, "y": 0.2611}, {"x": 0.1094, "y": 0.2611}], "id": 253, "page": 21}, {"category": "table", "content": {"html": "<br><table id='254' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(10.);</td></tr><tr><td>const unsi gLevec2</td><td>N(10).3,</td></tr><tr><td>const Doub</td><td>P1(L, 0.) , P2(L, L), P3(0. , L) ;</td></tr><tr><td>DoubleMat</td><td>indices</td></tr><tr><td>UIntVec</td><td>, hard_nodes (5) ;</td></tr><tr><td>DoubleVec</td><td>sizes(5);</td></tr><tr><td>UIntMat</td><td>connectB;</td></tr></tbody></table>", "markdown": "| const double | L(10.); |\n| --- | --- |\n| const unsi gLevec2 | N(10).3, |\n| const Doub | P1(L, 0.) , P2(L, L), P3(0. , L) ; |\n| DoubleMat | indices |\n| UIntVec | , hard_nodes (5) ; |\n| DoubleVec | sizes(5); |\n| UIntMat | connectB; |\n", "text": "| const double | L(10.); |\n| --- | --- |\n| const unsi gLevec2 | N(10).3, |\n| const Doub | P1(L, 0.) , P2(L, L), P3(0. , L) ; |\n| DoubleMat | indices |\n| UIntVec | , hard_nodes (5) ; |\n| DoubleVec | sizes(5); |\n| UIntMat | connectB; |\n"}, "coordinates": [{"x": 0.1285, "y": 0.259}, {"x": 0.609, "y": 0.259}, {"x": 0.609, "y": 0.3288}, {"x": 0.1285, "y": 0.3288}], "id": 254, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='255' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration (\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1326, "y": 0.3352}, {"x": 0.6901, "y": 0.3352}, {"x": 0.6901, "y": 0.358}, {"x": 0.1326, "y": 0.358}], "id": 255, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='256' data-category='paragraph' style='font-size:14px'>11 VERTICES AND LINE MESHES.</p>", "markdown": "11 VERTICES AND LINE MESHES.", "text": "11 VERTICES AND LINE MESHES."}, "coordinates": [{"x": 0.1352, "y": 0.364}, {"x": 0.3572, "y": 0.364}, {"x": 0.3572, "y": 0.3753}, {"x": 0.1352, "y": 0.3753}], "id": 256, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='257' data-category='paragraph' style='font-size:14px'>pos · push_back (PO) ;<br>pos · push_back (P1) ;<br>pos . push_back (P2) ;<br>pos · push_back(P3) ;<br>hard_nodes [0] = 0; sizes [0] = 0. 1*L/N;<br>hard_nodes [1] 1; sizes [1] = 2. 0*L/N;<br>hard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;<br>hard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;<br>hard_nodes [4] = 0; sizes [4] = 0. 1*L/N;<br>meshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>", "markdown": "pos · push_back (PO) ;\npos · push_back (P1) ;\npos . push_back (P2) ;\npos · push_back(P3) ;\nhard_nodes [0] = 0; sizes [0] = 0. 1*L/N;\nhard_nodes [1] 1; sizes [1] = 2. 0*L/N;\nhard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;\nhard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;\nhard_nodes [4] = 0; sizes [4] = 0. 1*L/N;\nmeshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;", "text": "pos · push_back (PO) ;\npos · push_back (P1) ;\npos . push_back (P2) ;\npos · push_back(P3) ;\nhard_nodes [0] = 0; sizes [0] = 0. 1*L/N;\nhard_nodes [1] 1; sizes [1] = 2. 0*L/N;\nhard_nodes [2] = 2; sizes [2] = 0 . 1*L/N;\nhard_nodes [3] = 3; sizes [3] = 2 · 0*L/N;\nhard_nodes [4] = 0; sizes [4] = 0. 1*L/N;\nmeshtools1d: :mesh_straight (pos, hard_nodes, sizes, true, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;"}, "coordinates": [{"x": 0.1308, "y": 0.3685}, {"x": 0.6745, "y": 0.3685}, {"x": 0.6745, "y": 0.4775}, {"x": 0.1308, "y": 0.4775}], "id": 257, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='258' data-category='paragraph' style='font-size:14px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_iso: : mesher: :data_type data (pos, connectB) ;<br>the_mesher . run(data) ;</p>", "markdown": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;", "text": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher: :data_type data (pos, connectB) ;\nthe_mesher . run(data) ;"}, "coordinates": [{"x": 0.1317, "y": 0.4889}, {"x": 0.5778, "y": 0.4889}, {"x": 0.5778, "y": 0.5271}, {"x": 0.1317, "y": 0.5271}], "id": 258, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='259' data-category='paragraph' style='font-size:14px'>11 VISUALIZATION.<br>meshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output (\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1305, "y": 0.5359}, {"x": 0.7229, "y": 0.5359}, {"x": 0.7229, "y": 0.5575}, {"x": 0.1305, "y": 0.5575}], "id": 259, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='260' data-category='paragraph' style='font-size:14px'>return 0;<br>11 main</p>", "markdown": "return 0;\n11 main", "text": "return 0;\n11 main"}, "coordinates": [{"x": 0.1239, "y": 0.5643}, {"x": 0.2073, "y": 0.5643}, {"x": 0.2073, "y": 0.5853}, {"x": 0.1239, "y": 0.5853}], "id": 260, "page": 21}, {"category": "paragraph", "content": {"html": "<br><p id='261' data-category='paragraph' style='font-size:14px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1084, "y": 0.5749}, {"x": 0.1176, "y": 0.5749}, {"x": 0.1176, "y": 0.5845}, {"x": 0.1084, "y": 0.5845}], "id": 261, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='262' data-category='paragraph' style='font-size:18px'>This variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal<br>line) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best<br>the target values on the four corners.</p>", "markdown": "This variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal\nline) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best\nthe target values on the four corners.", "text": "This variant of the cm2 : : meshtools1d : : mesh_straight function uses a vector of hard nodes (a polygonal\nline) and a vector of target size values, one value for each hard node. The contour mesh is generated to fit best\nthe target values on the four corners."}, "coordinates": [{"x": 0.0759, "y": 0.6284}, {"x": 0.9167, "y": 0.6284}, {"x": 0.9167, "y": 0.6725}, {"x": 0.0759, "y": 0.6725}], "id": 262, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='263' data-category='paragraph' style='font-size:20px'>These target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used<br>to compute the 2-D size map.</p>", "markdown": "These target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used\nto compute the 2-D size map.", "text": "These target sizes are not used by the 2-D mesher. Only the resulting edge lengths of the contour will be used\nto compute the 2-D size map."}, "coordinates": [{"x": 0.0761, "y": 0.6831}, {"x": 0.9117, "y": 0.6831}, {"x": 0.9117, "y": 0.7141}, {"x": 0.0761, "y": 0.7141}], "id": 263, "page": 21}, {"category": "paragraph", "content": {"html": "<p id='264' data-category='paragraph' style='font-size:14px'>18 By averaging the lengths of the adjacent edges to each hard node.</p>", "markdown": "18 By averaging the lengths of the adjacent edges to each hard node.", "text": "18 By averaging the lengths of the adjacent edges to each hard node."}, "coordinates": [{"x": 0.0637, "y": 0.8992}, {"x": 0.4811, "y": 0.8992}, {"x": 0.4811, "y": 0.9132}, {"x": 0.0637, "y": 0.9132}], "id": 264, "page": 21}, {"category": "table", "content": {"html": "<table id='265' style='font-size:18px'><thead></thead><tbody><tr><td>TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 & CM2 - 21 tutorials</td></tr></tbody></table>", "markdown": "| TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 & CM2 - 21 tutorials |\n| --- | --- |\n", "text": "| TriaMeshⓇ QuadMesh� Iso/Aniso Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 & CM2 - 21 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0074, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0074, "y": 1}], "id": 265, "page": 21}, {"category": "figure", "content": {"html": "<figure id='266'><img alt=\"\" data-coord=\"top-left:(114,117); bottom-right:(593,591)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0924, "y": 0.0668}, {"x": 0.4781, "y": 0.0668}, {"x": 0.4781, "y": 0.3375}, {"x": 0.0924, "y": 0.3375}], "id": 266, "page": 22}, {"category": "figure", "content": {"html": "<br><figure id='267'><img alt=\"\" data-coord=\"top-left:(648,116); bottom-right:(1123,590)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5229, "y": 0.0662}, {"x": 0.9053, "y": 0.0662}, {"x": 0.9053, "y": 0.3368}, {"x": 0.5229, "y": 0.3368}], "id": 267, "page": 22}, {"category": "caption", "content": {"html": "<caption id='268' style='font-size:14px'>Figure 10 - Meshes with grading size (T3 and all-Q4).</caption>", "markdown": "Figure 10 - Meshes with grading size (T3 and all-Q4).", "text": "Figure 10 - Meshes with grading size (T3 and all-Q4)."}, "coordinates": [{"x": 0.337, "y": 0.3474}, {"x": 0.6591, "y": 0.3474}, {"x": 0.6591, "y": 0.3617}, {"x": 0.337, "y": 0.3617}], "id": 268, "page": 22}, {"category": "paragraph", "content": {"html": "<p id='269' data-category='paragraph' style='font-size:18px'>The second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some<br>hard nodes. This is explained in the next section.</p>", "markdown": "The second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some\nhard nodes. This is explained in the next section.", "text": "The second way to get grading sizes is to specify in the data of the 2-D mesher the target size values on some\nhard nodes. This is explained in the next section."}, "coordinates": [{"x": 0.0757, "y": 0.3964}, {"x": 0.9069, "y": 0.3964}, {"x": 0.9069, "y": 0.4275}, {"x": 0.0757, "y": 0.4275}], "id": 269, "page": 22}, {"category": "table", "content": {"html": "<table id='270' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 22 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0048, "y": 0.9481}, {"x": 1, "y": 0.9481}, {"x": 1, "y": 1}, {"x": 0.0048, "y": 1}], "id": 270, "page": 22}, {"category": "heading1", "content": {"html": "<h1 id='271' style='font-size:20px'>6. Square with an internal hard node</h1>", "markdown": "# 6. Square with an internal hard node", "text": "6. Square with an internal hard node"}, "coordinates": [{"x": 0.0774, "y": 0.0642}, {"x": 0.5781, "y": 0.0642}, {"x": 0.5781, "y": 0.088}, {"x": 0.0774, "y": 0.088}], "id": 271, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='272' data-category='paragraph' style='font-size:18px'>So far, we have seen only three fields of the structure used to exchange data with the mesher:</p>", "markdown": "So far, we have seen only three fields of the structure used to exchange data with the mesher:", "text": "So far, we have seen only three fields of the structure used to exchange data with the mesher:"}, "coordinates": [{"x": 0.0747, "y": 0.099}, {"x": 0.7911, "y": 0.099}, {"x": 0.7911, "y": 0.1155}, {"x": 0.0747, "y": 0.1155}], "id": 272, "page": 23}, {"category": "list", "content": {"html": "<p id='273' data-category='list' style='font-size:18px'>· The pos matrix for the coordinates of the points.<br>· The connectB matrix for the connectivity of the hard edges.<br>· The connectM matrix for the connectivity of the 2-D mesh.</p>", "markdown": "- · The pos matrix for the coordinates of the points.\n- · The connectB matrix for the connectivity of the hard edges.\n- · The connectM matrix for the connectivity of the 2-D mesh.\n", "text": "· The pos matrix for the coordinates of the points.\n· The connectB matrix for the connectivity of the hard edges.\n· The connectM matrix for the connectivity of the 2-D mesh."}, "coordinates": [{"x": 0.0844, "y": 0.1257}, {"x": 0.5644, "y": 0.1257}, {"x": 0.5644, "y": 0.1745}, {"x": 0.0844, "y": 0.1745}], "id": 273, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='274' data-category='paragraph' style='font-size:18px'>In this example we add an isolated hard node at the center of the square and specify a target size on it. This will<br>be done using the two new fields isolated_nodes and metrics:</p>", "markdown": "In this example we add an isolated hard node at the center of the square and specify a target size on it. This will\nbe done using the two new fields isolated_nodes and metrics:", "text": "In this example we add an isolated hard node at the center of the square and specify a target size on it. This will\nbe done using the two new fields isolated_nodes and metrics:"}, "coordinates": [{"x": 0.0766, "y": 0.1848}, {"x": 0.9209, "y": 0.1848}, {"x": 0.9209, "y": 0.2155}, {"x": 0.0766, "y": 0.2155}], "id": 274, "page": 23}, {"category": "figure", "content": {"html": "<figure id='275'><img style='font-size:14px' alt=\"#include 'stdafx.h'\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration('Licensed to SMART Inc. ' 'F53EA108BCWX') ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output('out.mesh' , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main\" data-coord=\"top-left:(100,405); bottom-right:(1144,1135)\" /></figure>", "markdown": "![image](/image/placeholder)\n#include \"stdafx.h\"\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main", "text": "![image](/image/placeholder)\n#include \"stdafx.h\"\nint main()\n{\nconst double L(10.);\nconst unsi Levec2 N(10) ;\nPO(0. , 0.), P1(L, 0. ) , P2(L, L), P3(0. , L) , P4(L/2., L/2.) ;\nconst Doub\nDoubleMat pos;\nUIntVec indices;\nUIntMat connectB;\n11 UNLOCK THE DLL.\ntriamesh_ iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\n11 VERTICES AND LINE MESHES.\npos . push_back (PO) ;\npos . push_back (P1) ;\npos . push_back(P2) ;\npos . push_back (P3) ;\npos . push_back (P4) ;\nmeshtools1d : : mesh_straight (pos, ⊙, 1, N, indices) ; indices . pop_ back() ;\nmeshtools1d: : mesh_strai ght(pos , 1 , 2, N indices) ; indices · pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2 , 3, N, indices) ; indices · pop_back () ;\nmeshtools1d: : mesh_straight (pos, 3 , ⊙ , N, indices) ;\nmeshtools1d: : indices_ to_connectE2(indices, connectB) ;\n11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_iso: : mesher : : data_ type data (pos, connectB) ;\ndata · isolated_ nodes. push_back(4) ;\ndata · metrics. resize(5, 0.0) ;\ndata · metrics[4] = 0. 1*L/N;\nthe_mesher . run (data) ;\n11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;\nreturn 0;\n} 11 main"}, "coordinates": [{"x": 0.0806, "y": 0.2309}, {"x": 0.922, "y": 0.2309}, {"x": 0.922, "y": 0.6475}, {"x": 0.0806, "y": 0.6475}], "id": 275, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='276' data-category='paragraph' style='font-size:18px'>We have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is<br>pushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be<br>honored in the final mesh.</p>", "markdown": "We have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is\npushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be\nhonored in the final mesh.", "text": "We have created a new point at the centre with coordinates placed in column #4 of matrix pos. Its index (4) is\npushed into the vector data · isolated_nodes. This new field stores the isolated nodes that must be\nhonored in the final mesh."}, "coordinates": [{"x": 0.0767, "y": 0.669}, {"x": 0.9077, "y": 0.669}, {"x": 0.9077, "y": 0.7125}, {"x": 0.0767, "y": 0.7125}], "id": 276, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='277' data-category='paragraph' style='font-size:16px'>The vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or<br>not present- a default value will be used instead19.</p>", "markdown": "The vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or\nnot present- a default value will be used instead19.", "text": "The vector data  metrics stores the user-specified target sizes. If the value for a node is zero -or negative or\nnot present- a default value will be used instead19."}, "coordinates": [{"x": 0.0766, "y": 0.7242}, {"x": 0.9104, "y": 0.7242}, {"x": 0.9104, "y": 0.7536}, {"x": 0.0766, "y": 0.7536}], "id": 277, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='278' data-category='paragraph' style='font-size:18px'>In our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10<br>times finer mesh around it.</p>", "markdown": "In our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10\ntimes finer mesh around it.", "text": "In our example the vector is resized to 5 with all values set to zero except for point #4 where we ask for a 10\ntimes finer mesh around it."}, "coordinates": [{"x": 0.0776, "y": 0.7645}, {"x": 0.8986, "y": 0.7645}, {"x": 0.8986, "y": 0.7946}, {"x": 0.0776, "y": 0.7946}], "id": 278, "page": 23}, {"category": "paragraph", "content": {"html": "<p id='279' data-category='paragraph' style='font-size:14px'>19 For an isolated node, the default computed size is based on the size value of the nearest nodes.</p>", "markdown": "19 For an isolated node, the default computed size is based on the size value of the nearest nodes.", "text": "19 For an isolated node, the default computed size is based on the size value of the nearest nodes."}, "coordinates": [{"x": 0.0646, "y": 0.8985}, {"x": 0.6581, "y": 0.8985}, {"x": 0.6581, "y": 0.9133}, {"x": 0.0646, "y": 0.9133}], "id": 279, "page": 23}, {"category": "table", "content": {"html": "<table id='280' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>23 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 23 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 23 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0083, "y": 0.9475}, {"x": 1, "y": 0.9475}, {"x": 1, "y": 1}, {"x": 0.0083, "y": 1}], "id": 280, "page": 23}, {"category": "figure", "content": {"html": "<figure id='281'><img alt=\"\" data-coord=\"top-left:(116,117); bottom-right:(593,592)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.094, "y": 0.067}, {"x": 0.4782, "y": 0.067}, {"x": 0.4782, "y": 0.3379}, {"x": 0.094, "y": 0.3379}], "id": 281, "page": 24}, {"category": "figure", "content": {"html": "<br><figure id='282'><img alt=\"\" data-coord=\"top-left:(649,116); bottom-right:(1123,590)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5233, "y": 0.0666}, {"x": 0.9056, "y": 0.0666}, {"x": 0.9056, "y": 0.3367}, {"x": 0.5233, "y": 0.3367}], "id": 282, "page": 24}, {"category": "caption", "content": {"html": "<caption id='283' style='font-size:14px'>Figure 11 - Mesh concentration near a hard node (T3 and all-Q4).</caption>", "markdown": "Figure 11 - Mesh concentration near a hard node (T3 and all-Q4).", "text": "Figure 11 - Mesh concentration near a hard node (T3 and all-Q4)."}, "coordinates": [{"x": 0.297, "y": 0.3478}, {"x": 0.6997, "y": 0.3478}, {"x": 0.6997, "y": 0.3615}, {"x": 0.297, "y": 0.3615}], "id": 283, "page": 24}, {"category": "table", "content": {"html": "<table id='284' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 24 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0046, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0046, "y": 1}], "id": 284, "page": 24}, {"category": "heading1", "content": {"html": "<h1 id='285' style='font-size:22px'>7. Multiple meshes</h1>", "markdown": "# 7. Multiple meshes", "text": "7. Multiple meshes"}, "coordinates": [{"x": 0.0779, "y": 0.0637}, {"x": 0.3404, "y": 0.0637}, {"x": 0.3404, "y": 0.0874}, {"x": 0.0779, "y": 0.0874}], "id": 285, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='286' data-category='paragraph' style='font-size:20px'>The matrix connectB can contain internal lines. It can also contain several external disconnected contours (to<br>mesh several disconnected domains simultaneously). Some care must be taken however in the orientation of<br>these contours. For multiple domains, the edges of all external contours must be oriented the same way, for<br>instance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect<br>each other.</p>", "markdown": "The matrix connectB can contain internal lines. It can also contain several external disconnected contours (to\nmesh several disconnected domains simultaneously). Some care must be taken however in the orientation of\nthese contours. For multiple domains, the edges of all external contours must be oriented the same way, for\ninstance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect\neach other.", "text": "The matrix connectB can contain internal lines. It can also contain several external disconnected contours (to\nmesh several disconnected domains simultaneously). Some care must be taken however in the orientation of\nthese contours. For multiple domains, the edges of all external contours must be oriented the same way, for\ninstance counter-clockwise (the so-called positive orientation). In addition, these contours must not intersect\neach other."}, "coordinates": [{"x": 0.0765, "y": 0.0983}, {"x": 0.9114, "y": 0.0983}, {"x": 0.9114, "y": 0.172}, {"x": 0.0765, "y": 0.172}], "id": 286, "page": 25}, {"category": "figure", "content": {"html": "<figure id='287'><img alt=\"\" data-coord=\"top-left:(117,335); bottom-right:(595,810)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0943, "y": 0.1912}, {"x": 0.4796, "y": 0.1912}, {"x": 0.4796, "y": 0.4621}, {"x": 0.0943, "y": 0.4621}], "id": 287, "page": 25}, {"category": "figure", "content": {"html": "<br><figure id='288'><img alt=\"\" data-coord=\"top-left:(651,337); bottom-right:(1121,807)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5249, "y": 0.1926}, {"x": 0.9038, "y": 0.1926}, {"x": 0.9038, "y": 0.4606}, {"x": 0.5249, "y": 0.4606}], "id": 288, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='289' data-category='paragraph' style='font-size:16px'>Figure 12 - Multiple meshes (T3 and all-Q4).<br>The four sub-domains are meshed simultaneously.</p>", "markdown": "Figure 12 - Multiple meshes (T3 and all-Q4).\nThe four sub-domains are meshed simultaneously.", "text": "Figure 12 - Multiple meshes (T3 and all-Q4).\nThe four sub-domains are meshed simultaneously."}, "coordinates": [{"x": 0.3448, "y": 0.4719}, {"x": 0.6538, "y": 0.4719}, {"x": 0.6538, "y": 0.4967}, {"x": 0.3448, "y": 0.4967}], "id": 289, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='290' data-category='paragraph' style='font-size:20px'>In this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:</p>", "markdown": "In this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:", "text": "In this example, the coordinates matrix and the connectivity of the contour meshes are read from a file20:"}, "coordinates": [{"x": 0.0762, "y": 0.5323}, {"x": 0.8752, "y": 0.5323}, {"x": 0.8752, "y": 0.5496}, {"x": 0.0762, "y": 0.5496}], "id": 290, "page": 25}, {"category": "figure", "content": {"html": "<figure id='291'><img style='font-size:14px' alt=\"#include 'stdafx.h'\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm('cards.dat') ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration('Licensed to SMART Inc. ' 'F53EA108BCWX') ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( 'out.mesh' , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main\" data-coord=\"top-left:(100,993); bottom-right:(1139,1389)\" /></figure>", "markdown": "![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm(\"cards.dat\") ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( \"out.mesh\" , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main", "text": "![image](/image/placeholder)\n#include \"stdafx.h\"\n#include <fstream>\nint main()\n{\nstd: : ifstream istrm(\"cards.dat\") ;\ntriamesh_iso : : mesher the_mesher ;\ntriamesh_iso : : mesher: :data_type data;\ntriamesh_iso : : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,\nmatio : : read (istrm, data.pos) ;\nmatio: : read (istrm, data.connectB) ;\nthe_mesher · run(data) ;\nmeshtools : : medit_output ( \"out.mesh\" , data · pos, data · connectM, CM2_FACET3) ;\nreturn ⊙;\n} 11 main"}, "coordinates": [{"x": 0.0811, "y": 0.5662}, {"x": 0.9185, "y": 0.5662}, {"x": 0.9185, "y": 0.7921}, {"x": 0.0811, "y": 0.7921}], "id": 291, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='292' data-category='paragraph' style='font-size:14px'>20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines.</p>", "markdown": "20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines.", "text": "20 We could also have used the function cm2 : : meshtools1d : :mesh_spline which generate 1-D meshes along splines."}, "coordinates": [{"x": 0.0632, "y": 0.8985}, {"x": 0.8029, "y": 0.8985}, {"x": 0.8029, "y": 0.913}, {"x": 0.0632, "y": 0.913}], "id": 292, "page": 25}, {"category": "table", "content": {"html": "<table id='293' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>& 25 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 25 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 25 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0078, "y": 0.9478}, {"x": 0.9998, "y": 0.9478}, {"x": 0.9998, "y": 1}, {"x": 0.0078, "y": 1}], "id": 293, "page": 25}, {"category": "paragraph", "content": {"html": "<p id='294' data-category='paragraph' style='font-size:20px'>The input boundary meshes are read from an ASCII file with cm2 : : matio: :read21</p>", "markdown": "The input boundary meshes are read from an ASCII file with cm2 : : matio: :read21", "text": "The input boundary meshes are read from an ASCII file with cm2 : : matio: :read21"}, "coordinates": [{"x": 0.0748, "y": 0.064}, {"x": 0.7108, "y": 0.064}, {"x": 0.7108, "y": 0.0809}, {"x": 0.0748, "y": 0.0809}], "id": 294, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='295' data-category='paragraph' style='font-size:20px'>The format for the matrices is:</p>", "markdown": "The format for the matrices is:", "text": "The format for the matrices is:"}, "coordinates": [{"x": 0.0753, "y": 0.0905}, {"x": 0.311, "y": 0.0905}, {"x": 0.311, "y": 0.1068}, {"x": 0.0753, "y": 0.1068}], "id": 295, "page": 26}, {"category": "table", "content": {"html": "<table id='296' style='font-size:16px'><thead></thead><tbody><tr><td>n X m</td><td>[ <table><thead></thead><tbody><tr><td>do,o</td><td>do,1</td><td>do,2</td><td>· · ·</td><td>do,m-1</td></tr><tr><td>d1,0</td><td>d1,1</td><td>d1,2</td><td>· · ·</td><td>d1,m-1</td></tr></tbody></table></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>dn-1, 0</td><td></td><td>dn-1,1</td><td>dn-1,2 ·</td><td>· ·</td><td>dn-1,m-1</td><td>]</td></tr></tbody></table>", "markdown": "| n X m | [ <table><thead></thead><tbody><tr><td>do,o</td><td>do,1</td><td>do,2</td><td>· · ·</td><td>do,m-1</td></tr><tr><td>d1,0</td><td>d1,1</td><td>d1,2</td><td>· · ·</td><td>d1,m-1</td></tr></tbody></table> |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n| dn-1, 0 |  | dn-1,1 | dn-1,2 · | · · | dn-1,m-1 | ] |\n", "text": "| n X m | [ {LinL_0003} |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- |\n| dn-1, 0 |  | dn-1,1 | dn-1,2 · | · · | dn-1,m-1 | ] |\n"}, "coordinates": [{"x": 0.1229, "y": 0.12}, {"x": 0.4132, "y": 0.12}, {"x": 0.4132, "y": 0.1892}, {"x": 0.1229, "y": 0.1892}], "id": 296, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='297' data-category='paragraph' style='font-size:22px'>The format for each component of the matrix is free.</p>", "markdown": "The format for each component of the matrix is free.", "text": "The format for each component of the matrix is free."}, "coordinates": [{"x": 0.0759, "y": 0.2087}, {"x": 0.479, "y": 0.2087}, {"x": 0.479, "y": 0.2248}, {"x": 0.0759, "y": 0.2248}], "id": 297, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='298' data-category='paragraph' style='font-size:18px'>For instance a 2 X 4 Doub leMat can be stored as:</p>", "markdown": "For instance a 2 X 4 Doub leMat can be stored as:", "text": "For instance a 2 X 4 Doub leMat can be stored as:"}, "coordinates": [{"x": 0.0772, "y": 0.2347}, {"x": 0.4588, "y": 0.2347}, {"x": 0.4588, "y": 0.2506}, {"x": 0.0772, "y": 0.2506}], "id": 298, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='299' data-category='paragraph' style='font-size:16px'>2 X 4 [<br>0 0.5 1 2.0<br>0 1 1 2.E-1]</p>", "markdown": "2 X 4 [\n0 0.5 1 2.0\n0 1 1 2.E-1]", "text": "2 X 4 [\n0 0.5 1 2.0\n0 1 1 2.E-1]"}, "coordinates": [{"x": 0.1206, "y": 0.2623}, {"x": 0.2813, "y": 0.2623}, {"x": 0.2813, "y": 0.3067}, {"x": 0.1206, "y": 0.3067}], "id": 299, "page": 26}, {"category": "heading1", "content": {"html": "<h1 id='300' style='font-size:20px'>Notes:</h1>", "markdown": "# Notes:", "text": "Notes:"}, "coordinates": [{"x": 0.0768, "y": 0.3253}, {"x": 0.1314, "y": 0.3253}, {"x": 0.1314, "y": 0.3402}, {"x": 0.0768, "y": 0.3402}], "id": 300, "page": 26}, {"category": "list", "content": {"html": "<p id='301' data-category='list' style='font-size:20px'>· We can see in this example that the meshes may not always be symmetric even with a symmetric contour.<br>· We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-<br>domain to be meshed in a structured manner.</p>", "markdown": "- · We can see in this example that the meshes may not always be symmetric even with a symmetric contour.\n- · We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-\n- domain to be meshed in a structured manner.\n", "text": "· We can see in this example that the meshes may not always be symmetric even with a symmetric contour.\n· We can set the flag multi_structured_ flag = true to force any rectangle-like (or diamond-like) sub-\ndomain to be meshed in a structured manner."}, "coordinates": [{"x": 0.0853, "y": 0.3519}, {"x": 0.9046, "y": 0.3519}, {"x": 0.9046, "y": 0.3979}, {"x": 0.0853, "y": 0.3979}], "id": 301, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='302' data-category='paragraph' style='font-size:14px'>21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.<br>This can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files.</p>", "markdown": "21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.\nThis can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files.", "text": "21 A similar cm2 : :matio: : transpose_read function can read a matrix and transpose it on the fly.\nThis can be more useful because itis usually more convenient to store the transposed matrices in the ASCII files."}, "coordinates": [{"x": 0.0633, "y": 0.8879}, {"x": 0.76, "y": 0.8879}, {"x": 0.76, "y": 0.9132}, {"x": 0.0633, "y": 0.9132}], "id": 302, "page": 26}, {"category": "table", "content": {"html": "<table id='303' style='font-size:20px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>26 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 26 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 26 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0085, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0085, "y": 1}], "id": 303, "page": 26}, {"category": "paragraph", "content": {"html": "<p id='304' data-category='paragraph' style='font-size:22px'>As an exercise we can get the same result by making four successive meshes and concatenating the results:</p>", "markdown": "As an exercise we can get the same result by making four successive meshes and concatenating the results:", "text": "As an exercise we can get the same result by making four successive meshes and concatenating the results:"}, "coordinates": [{"x": 0.076, "y": 0.0648}, {"x": 0.8941, "y": 0.0648}, {"x": 0.8941, "y": 0.0815}, {"x": 0.076, "y": 0.0815}], "id": 304, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='305' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"<br>#include <fstream></p>", "markdown": "#include \"stdafx.h\"\n#include <fstream>", "text": "#include \"stdafx.h\"\n#include <fstream>"}, "coordinates": [{"x": 0.1063, "y": 0.1188}, {"x": 0.263, "y": 0.1188}, {"x": 0.263, "y": 0.1388}, {"x": 0.1063, "y": 0.1388}], "id": 305, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='306' data-category='paragraph' style='font-size:18px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1097, "y": 0.1472}, {"x": 0.1898, "y": 0.1472}, {"x": 0.1898, "y": 0.1586}, {"x": 0.1097, "y": 0.1586}], "id": 306, "page": 27}, {"category": "paragraph", "content": {"html": "<br><p id='307' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1095, "y": 0.1577}, {"x": 0.1181, "y": 0.1577}, {"x": 0.1181, "y": 0.1673}, {"x": 0.1095, "y": 0.1673}], "id": 307, "page": 27}, {"category": "table", "content": {"html": "<br><table id='308' style='font-size:18px'><thead></thead><tbody><tr><td>std: :ifstream</td><td>istrm</td></tr><tr><td>UIntMat</td><td>connectM;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr></tbody></table>", "markdown": "| std: :ifstream | istrm |\n| --- | --- |\n| UIntMat | connectM; |\n| DoubleMat | pos; |\n", "text": "| std: :ifstream | istrm |\n| --- | --- |\n| UIntMat | connectM; |\n| DoubleMat | pos; |\n"}, "coordinates": [{"x": 0.1305, "y": 0.1661}, {"x": 0.4482, "y": 0.1661}, {"x": 0.4482, "y": 0.1968}, {"x": 0.1305, "y": 0.1968}], "id": 308, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='309' data-category='paragraph' style='font-size:14px'>\" \"F53EA108BCWX\") ;<br>triamesh_iso : : registration(\"Licensed to SMART Inc . ,</p>", "markdown": "\" \"F53EA108BCWX\") ;\ntriamesh_iso : : registration(\"Licensed to SMART Inc . ,", "text": "\" \"F53EA108BCWX\") ;\ntriamesh_iso : : registration(\"Licensed to SMART Inc . ,"}, "coordinates": [{"x": 0.1323, "y": 0.204}, {"x": 0.6902, "y": 0.204}, {"x": 0.6902, "y": 0.2161}, {"x": 0.1323, "y": 0.2161}], "id": 309, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='310' data-category='paragraph' style='font-size:16px'>triamesh_ iso : : mesher the_mesher;<br>triamesh_iso : : mesher: :data_type data;</p>", "markdown": "triamesh_ iso : : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data;", "text": "triamesh_ iso : : mesher the_mesher;\ntriamesh_iso : : mesher: :data_type data;"}, "coordinates": [{"x": 0.1309, "y": 0.2229}, {"x": 0.5009, "y": 0.2229}, {"x": 0.5009, "y": 0.2445}, {"x": 0.1309, "y": 0.2445}], "id": 310, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='311' data-category='paragraph' style='font-size:16px'>istrm. open(\"heart.dat\") ;<br>matio : : read (istrm, data · pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run (data) ;<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>", "markdown": "istrm. open(\"heart.dat\") ;\nmatio : : read (istrm, data · pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;", "text": "istrm. open(\"heart.dat\") ;\nmatio : : read (istrm, data · pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;"}, "coordinates": [{"x": 0.1327, "y": 0.2514}, {"x": 0.4101, "y": 0.2514}, {"x": 0.4101, "y": 0.311}, {"x": 0.1327, "y": 0.311}], "id": 311, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='312' data-category='paragraph' style='font-size:16px'>istrm. open(\"spade.dat\") ;<br>matio: : read(istrm, data . pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher ・ run (data) ;<br>matscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>", "markdown": "istrm. open(\"spade.dat\") ;\nmatio: : read(istrm, data . pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher ・ run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;", "text": "istrm. open(\"spade.dat\") ;\nmatio: : read(istrm, data . pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher ・ run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;"}, "coordinates": [{"x": 0.1323, "y": 0.3192}, {"x": 0.6147, "y": 0.3192}, {"x": 0.6147, "y": 0.3866}, {"x": 0.1323, "y": 0.3866}], "id": 312, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='313' data-category='paragraph' style='font-size:16px'>istrm. open(\"diamond. dat\") ;<br>matio : : read (istrm, data. pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run(data) ;<br>matscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.<br>pos. push_back(data. pos) ;<br>connectM.push_back(data.connectM) ;</p>", "markdown": "istrm. open(\"diamond. dat\") ;\nmatio : : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run(data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;", "text": "istrm. open(\"diamond. dat\") ;\nmatio : : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run(data) ;\nmatscal: : add (pos. cols () , data.connectM) ; 11 Shift indices.\npos. push_back(data. pos) ;\nconnectM.push_back(data.connectM) ;"}, "coordinates": [{"x": 0.1312, "y": 0.395}, {"x": 0.6159, "y": 0.395}, {"x": 0.6159, "y": 0.4627}, {"x": 0.1312, "y": 0.4627}], "id": 313, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='314' data-category='paragraph' style='font-size:16px'>istrm. open(\"club. dat\") ;<br>matio: : read (istrm, data. pos) ;<br>matio: : read (istrm, data. connectB) ;<br>the_mesher. run (data) ;<br>matscal: : add (pos. cols () , data.connectM) ; / / Shift indices.<br>pos. push_back(data.pos) ;<br>connectM.push_back(data.connectM) ;</p>", "markdown": "istrm. open(\"club. dat\") ;\nmatio: : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; / / Shift indices.\npos. push_back(data.pos) ;\nconnectM.push_back(data.connectM) ;", "text": "istrm. open(\"club. dat\") ;\nmatio: : read (istrm, data. pos) ;\nmatio: : read (istrm, data. connectB) ;\nthe_mesher. run (data) ;\nmatscal: : add (pos. cols () , data.connectM) ; / / Shift indices.\npos. push_back(data.pos) ;\nconnectM.push_back(data.connectM) ;"}, "coordinates": [{"x": 0.1316, "y": 0.4711}, {"x": 0.6202, "y": 0.4711}, {"x": 0.6202, "y": 0.539}, {"x": 0.1316, "y": 0.539}], "id": 314, "page": 27}, {"category": "paragraph", "content": {"html": "<p id='315' data-category='paragraph' style='font-size:16px'>meshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;</p>", "markdown": "meshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;", "text": "meshtools : :medit_output(\"out.mesh\" , pos, connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1313, "y": 0.5456}, {"x": 0.6432, "y": 0.5456}, {"x": 0.6432, "y": 0.559}, {"x": 0.1313, "y": 0.559}], "id": 315, "page": 27}, {"category": "footer", "content": {"html": "<br><footer id='316' style='font-size:18px'>return 0;<br>} 11 main</footer>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1059, "y": 0.5663}, {"x": 0.2077, "y": 0.5663}, {"x": 0.2077, "y": 0.5872}, {"x": 0.1059, "y": 0.5872}], "id": 316, "page": 27}, {"category": "table", "content": {"html": "<table id='317' style='font-size:20px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 27 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0047, "y": 0.9481}, {"x": 1, "y": 0.9481}, {"x": 1, "y": 1}, {"x": 0.0047, "y": 1}], "id": 317, "page": 27}, {"category": "heading1", "content": {"html": "<h1 id='318' style='font-size:22px'>8. Shared boundaries</h1>", "markdown": "# 8. Shared boundaries", "text": "8. Shared boundaries"}, "coordinates": [{"x": 0.0781, "y": 0.0644}, {"x": 0.3736, "y": 0.0644}, {"x": 0.3736, "y": 0.0861}, {"x": 0.0781, "y": 0.0861}], "id": 318, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='319' data-category='paragraph' style='font-size:16px'>Edges can be shared between some contours and lines. In this case some edges are defined several times<br>(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more<br>convenient for the user to generate the 1-D meshes of the contours independently from each other. That<br>usually implies duplicated nodes on the shared contours.</p>", "markdown": "Edges can be shared between some contours and lines. In this case some edges are defined several times\n(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more\nconvenient for the user to generate the 1-D meshes of the contours independently from each other. That\nusually implies duplicated nodes on the shared contours.", "text": "Edges can be shared between some contours and lines. In this case some edges are defined several times\n(usually twice) in the connectB matrix but with different orientation. In addition it is sometimes more\nconvenient for the user to generate the 1-D meshes of the contours independently from each other. That\nusually implies duplicated nodes on the shared contours."}, "coordinates": [{"x": 0.0766, "y": 0.099}, {"x": 0.8822, "y": 0.099}, {"x": 0.8822, "y": 0.1574}, {"x": 0.0766, "y": 0.1574}], "id": 319, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='320' data-category='paragraph' style='font-size:18px'>The following example deals with such a case.</p>", "markdown": "The following example deals with such a case.", "text": "The following example deals with such a case."}, "coordinates": [{"x": 0.0768, "y": 0.1673}, {"x": 0.4247, "y": 0.1673}, {"x": 0.4247, "y": 0.1839}, {"x": 0.0768, "y": 0.1839}], "id": 320, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='321' data-category='paragraph' style='font-size:18px'>Consider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared<br>between sub-domains but with different orientation. We also want to mesh the contours of the sub-domains<br>independently from each other but without any duplicated nodes.</p>", "markdown": "Consider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared\nbetween sub-domains but with different orientation. We also want to mesh the contours of the sub-domains\nindependently from each other but without any duplicated nodes.", "text": "Consider three sub-domains all oriented counter-clockwise as defined below. Several edges are shared\nbetween sub-domains but with different orientation. We also want to mesh the contours of the sub-domains\nindependently from each other but without any duplicated nodes."}, "coordinates": [{"x": 0.0771, "y": 0.1937}, {"x": 0.9001, "y": 0.1937}, {"x": 0.9001, "y": 0.2389}, {"x": 0.0771, "y": 0.2389}], "id": 321, "page": 28}, {"category": "chart", "content": {"html": "<figure id='322' data-category='chart'><img data-coord=\"top-left:(359,446); bottom-right:(868,863)\" /><figcaption><p>Chart Type: line</p></figcaption><table><thead><tr><td></td><td>P0</td><td>P</td><td>P3</td><td>P4</td><td>P5</td><td>P6</td></tr></thead><tbody><tr><td>item_01</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: line\n|  | P0 | P | P3 | P4 | P5 | P6 |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 1 | 1 | 1 | 1 | 1 | 1 |\n", "text": "![image](/image/placeholder)\n- Chart Type: line\n|  | P0 | P | P3 | P4 | P5 | P6 |\n| --- | --- | --- | --- | --- | --- | --- |\n| item_01 | 1 | 1 | 1 | 1 | 1 | 1 |\n"}, "coordinates": [{"x": 0.2894, "y": 0.2545}, {"x": 0.6998, "y": 0.2545}, {"x": 0.6998, "y": 0.4922}, {"x": 0.2894, "y": 0.4922}], "id": 322, "page": 28}, {"category": "caption", "content": {"html": "<caption id='323' style='font-size:14px'>Figure 13 - Domain composed of three attached sub-domains.</caption>", "markdown": "Figure 13 - Domain composed of three attached sub-domains.", "text": "Figure 13 - Domain composed of three attached sub-domains."}, "coordinates": [{"x": 0.3066, "y": 0.5025}, {"x": 0.6906, "y": 0.5025}, {"x": 0.6906, "y": 0.5168}, {"x": 0.3066, "y": 0.5168}], "id": 323, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='324' data-category='paragraph' style='font-size:18px'>The shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict<br>mode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes<br>can be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,<br>the mesher may not be able to tell the sign of the inner square, and that can lead to a hole.</p>", "markdown": "The shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict\nmode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes\ncan be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,\nthe mesher may not be able to tell the sign of the inner square, and that can lead to a hole.", "text": "The shared edges are no problem for the mesher. The duplicate nodes however must be avoided. In non-strict\nmode (see CM2 TriaMesh� Iso/Aniso and CM2 QuadMesh� Iso/Aniso - reference manual), duplicated nodes\ncan be discarded indeed but that implies also that the associated edges cannot be enforced. As a side effect,\nthe mesher may not be able to tell the sign of the inner square, and that can lead to a hole."}, "coordinates": [{"x": 0.0768, "y": 0.5517}, {"x": 0.9195, "y": 0.5517}, {"x": 0.9195, "y": 0.6107}, {"x": 0.0768, "y": 0.6107}], "id": 324, "page": 28}, {"category": "paragraph", "content": {"html": "<p id='325' data-category='paragraph' style='font-size:20px'>The solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:</p>", "markdown": "The solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:", "text": "The solution consists in merging the nodes after the meshing of the edges before the 2-D meshing:"}, "coordinates": [{"x": 0.077, "y": 0.6206}, {"x": 0.8289, "y": 0.6206}, {"x": 0.8289, "y": 0.6385}, {"x": 0.077, "y": 0.6385}], "id": 325, "page": 28}, {"category": "table", "content": {"html": "<table id='326' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 28 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0047, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0047, "y": 1}], "id": 326, "page": 28}, {"category": "heading1", "content": {"html": "<h1 id='327' style='font-size:18px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1052, "y": 0.0855}, {"x": 0.2641, "y": 0.0855}, {"x": 0.2641, "y": 0.0974}, {"x": 0.1052, "y": 0.0974}], "id": 327, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='328' data-category='paragraph' style='font-size:18px'>static void mesh_segment</p>", "markdown": "static void mesh_segment", "text": "static void mesh_segment"}, "coordinates": [{"x": 0.1064, "y": 0.1063}, {"x": 0.306, "y": 0.1063}, {"x": 0.306, "y": 0.1168}, {"x": 0.1064, "y": 0.1168}], "id": 328, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='329' data-category='paragraph' style='font-size:20px'>(DoubleMat& pos, UIntMat& connectB,<br>unsigned start_index, unsigned stop_index, unsigned num_edges)</p>", "markdown": "(DoubleMat& pos, UIntMat& connectB,\nunsigned start_index, unsigned stop_index, unsigned num_edges)", "text": "(DoubleMat& pos, UIntMat& connectB,\nunsigned start_index, unsigned stop_index, unsigned num_edges)"}, "coordinates": [{"x": 0.1175, "y": 0.117}, {"x": 0.6313, "y": 0.117}, {"x": 0.6313, "y": 0.1383}, {"x": 0.1175, "y": 0.1383}], "id": 329, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='330' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1095, "y": 0.1374}, {"x": 0.1181, "y": 0.1374}, {"x": 0.1181, "y": 0.147}, {"x": 0.1095, "y": 0.147}], "id": 330, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='331' data-category='paragraph' style='font-size:18px'>UIntVec indices;<br>meshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectB) ;</p>", "markdown": "UIntVec indices;\nmeshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;", "text": "UIntVec indices;\nmeshtools1d : :mesh_straight (pos, start_index, stop_index, num_edges, indices) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectB) ;"}, "coordinates": [{"x": 0.1265, "y": 0.1453}, {"x": 0.7543, "y": 0.1453}, {"x": 0.7543, "y": 0.1792}, {"x": 0.1265, "y": 0.1792}], "id": 331, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='332' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1073, "y": 0.1772}, {"x": 0.118, "y": 0.1772}, {"x": 0.118, "y": 0.1885}, {"x": 0.1073, "y": 0.1885}], "id": 332, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='333' data-category='paragraph' style='font-size:18px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1092, "y": 0.1966}, {"x": 0.1906, "y": 0.1966}, {"x": 0.1906, "y": 0.2086}, {"x": 0.1092, "y": 0.2086}], "id": 333, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='334' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.208}, {"x": 0.1187, "y": 0.208}, {"x": 0.1187, "y": 0.2177}, {"x": 0.1094, "y": 0.2177}], "id": 334, "page": 29}, {"category": "table", "content": {"html": "<br><table id='335' style='font-size:16px'><thead></thead><tbody><tr><td>const DoubleVec2</td><td>PO (0.,</td><td>0.),</td><td>P1(10. , 0.),</td><td>P2(10. , 2.) ,</td><td></td><td></td><td>P3(8. , 2.) ;</td></tr><tr><td>const DoubleVec2</td><td></td><td>P4 (2. , 2.),</td><td></td><td>P5(0. , 2.) ,</td><td>P6(10. , 10. ) ,</td><td>P7(0. ,</td><td>10.) ;</td></tr><tr><td>const DoubleVec2</td><td></td><td>P8 (2., 8.)</td><td>,</td><td>P9 (8. , 8.) ;</td><td></td><td></td><td></td></tr><tr><td>const unsi gned</td><td></td><td>N(4) ;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DoubleMat</td><td></td><td>pos;</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>UIntMat</td><td></td><td>connectB;</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>", "markdown": "| const DoubleVec2 | PO (0., | 0.), | P1(10. , 0.), | P2(10. , 2.) , |  |  | P3(8. , 2.) ; |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| const DoubleVec2 |  | P4 (2. , 2.), |  | P5(0. , 2.) , | P6(10. , 10. ) , | P7(0. , | 10.) ; |\n| const DoubleVec2 |  | P8 (2., 8.) | , | P9 (8. , 8.) ; |  |  |  |\n| const unsi gned |  | N(4) ; |  |  |  |  |  |\n| DoubleMat |  | pos; |  |  |  |  |  |\n| UIntMat |  | connectB; |  |  |  |  |  |\n", "text": "| const DoubleVec2 | PO (0., | 0.), | P1(10. , 0.), | P2(10. , 2.) , |  |  | P3(8. , 2.) ; |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| const DoubleVec2 |  | P4 (2. , 2.), |  | P5(0. , 2.) , | P6(10. , 10. ) , | P7(0. , | 10.) ; |\n| const DoubleVec2 |  | P8 (2., 8.) | , | P9 (8. , 8.) ; |  |  |  |\n| const unsi gned |  | N(4) ; |  |  |  |  |  |\n| DoubleMat |  | pos; |  |  |  |  |  |\n| UIntMat |  | connectB; |  |  |  |  |  |\n"}, "coordinates": [{"x": 0.1278, "y": 0.216}, {"x": 0.6911, "y": 0.216}, {"x": 0.6911, "y": 0.2792}, {"x": 0.1278, "y": 0.2792}], "id": 335, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='336' data-category='paragraph' style='font-size:16px'>11 UNLOCK THE DLL.<br>triamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1322, "y": 0.2868}, {"x": 0.6898, "y": 0.2868}, {"x": 0.6898, "y": 0.3105}, {"x": 0.1322, "y": 0.3105}], "id": 336, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='337' data-category='paragraph' style='font-size:18px'>11 VERTICES POINTS.</p>", "markdown": "11 VERTICES POINTS.", "text": "11 VERTICES POINTS."}, "coordinates": [{"x": 0.1324, "y": 0.3175}, {"x": 0.2835, "y": 0.3175}, {"x": 0.2835, "y": 0.3292}, {"x": 0.1324, "y": 0.3292}], "id": 337, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='338' data-category='paragraph' style='font-size:14px'>pos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;<br>pos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;<br>pos . push_back(P8) ; pos · push_back(P9) ;</p>", "markdown": "pos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;\npos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;\npos . push_back(P8) ; pos · push_back(P9) ;", "text": "pos . push_back (PO) ; pos . push_back(P1) ; pos . push_back (P2) ; pos · push_back (P3) ;\npos · push_back (P4) ; pos · push_back(P5) ; pos · push_back (P6) ; pos · push_back (P7) ;\npos . push_back(P8) ; pos · push_back(P9) ;"}, "coordinates": [{"x": 0.1319, "y": 0.326}, {"x": 0.7404, "y": 0.326}, {"x": 0.7404, "y": 0.3601}, {"x": 0.1319, "y": 0.3601}], "id": 338, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='339' data-category='paragraph' style='font-size:16px'>11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·</p>", "markdown": "11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·", "text": "11 BOTTOM RECTANGLE POSITIVE (I.E. COUNTER-CLOCKWISE) ·"}, "coordinates": [{"x": 0.1318, "y": 0.3678}, {"x": 0.5672, "y": 0.3678}, {"x": 0.5672, "y": 0.3803}, {"x": 0.1318, "y": 0.3803}], "id": 339, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='340' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 日, 1, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 日, 1, N) ;", "text": "mesh_segment (pos, connectB, 日, 1, N) ;"}, "coordinates": [{"x": 0.1313, "y": 0.3784}, {"x": 0.432, "y": 0.3784}, {"x": 0.432, "y": 0.3917}, {"x": 0.1313, "y": 0.3917}], "id": 340, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='341' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 1, 2, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 1, 2, N) ;", "text": "mesh_segment(pos, connectB, 1, 2, N) ;"}, "coordinates": [{"x": 0.1318, "y": 0.3883}, {"x": 0.432, "y": 0.3883}, {"x": 0.432, "y": 0.4015}, {"x": 0.1318, "y": 0.4015}], "id": 341, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='342' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 2, 3, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 2, 3, N) ;", "text": "mesh_segment (pos, connectB, 2, 3, N) ;"}, "coordinates": [{"x": 0.1317, "y": 0.3977}, {"x": 0.4321, "y": 0.3977}, {"x": 0.4321, "y": 0.4117}, {"x": 0.1317, "y": 0.4117}], "id": 342, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='343' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 3, 4, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 3, 4, N) ;", "text": "mesh_segment (pos, connectB, 3, 4, N) ;"}, "coordinates": [{"x": 0.1318, "y": 0.4083}, {"x": 0.4321, "y": 0.4083}, {"x": 0.4321, "y": 0.4218}, {"x": 0.1318, "y": 0.4218}], "id": 343, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='344' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 4, 5, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 4, 5, N) ;", "text": "mesh_segment(pos, connectB, 4, 5, N) ;"}, "coordinates": [{"x": 0.1319, "y": 0.4189}, {"x": 0.4319, "y": 0.4189}, {"x": 0.4319, "y": 0.4315}, {"x": 0.1319, "y": 0.4315}], "id": 344, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='345' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 5, 日, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 5, 日, N) ;", "text": "mesh_segment(pos, connectB, 5, 日, N) ;"}, "coordinates": [{"x": 0.1313, "y": 0.429}, {"x": 0.4319, "y": 0.429}, {"x": 0.4319, "y": 0.4417}, {"x": 0.1313, "y": 0.4417}], "id": 345, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='346' data-category='paragraph' style='font-size:16px'>11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·</p>", "markdown": "11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·", "text": "11 TOP HORSE-SHOE POSITIVE (I. E. COUNTER-CLOCKWISE) ·"}, "coordinates": [{"x": 0.1318, "y": 0.4492}, {"x": 0.5511, "y": 0.4492}, {"x": 0.5511, "y": 0.4613}, {"x": 0.1318, "y": 0.4613}], "id": 346, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='347' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 2, 6, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 2, 6, N) ;", "text": "mesh_segment (pos, connectB, 2, 6, N) ;"}, "coordinates": [{"x": 0.1313, "y": 0.4594}, {"x": 0.432, "y": 0.4594}, {"x": 0.432, "y": 0.4726}, {"x": 0.1313, "y": 0.4726}], "id": 347, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='348' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 6, 7, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 6, 7, N) ;", "text": "mesh_segment(pos, connectB, 6, 7, N) ;"}, "coordinates": [{"x": 0.1317, "y": 0.4689}, {"x": 0.432, "y": 0.4689}, {"x": 0.432, "y": 0.4823}, {"x": 0.1317, "y": 0.4823}], "id": 348, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='349' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 7, 5, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 7, 5, N) ;", "text": "mesh_segment (pos, connectB, 7, 5, N) ;"}, "coordinates": [{"x": 0.1318, "y": 0.479}, {"x": 0.4321, "y": 0.479}, {"x": 0.4321, "y": 0.4926}, {"x": 0.1318, "y": 0.4926}], "id": 349, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='350' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 5, 4, N) ·</p>", "markdown": "mesh_segment (pos, connectB, 5, 4, N) ·", "text": "mesh_segment (pos, connectB, 5, 4, N) ·"}, "coordinates": [{"x": 0.1319, "y": 0.4893}, {"x": 0.432, "y": 0.4893}, {"x": 0.432, "y": 0.5023}, {"x": 0.1319, "y": 0.5023}], "id": 350, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='351' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 4, 8, N) ·</p>", "markdown": "mesh_segment (pos, connectB, 4, 8, N) ·", "text": "mesh_segment (pos, connectB, 4, 8, N) ·"}, "coordinates": [{"x": 0.1317, "y": 0.4993}, {"x": 0.432, "y": 0.4993}, {"x": 0.432, "y": 0.5127}, {"x": 0.1317, "y": 0.5127}], "id": 351, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='352' data-category='paragraph' style='font-size:20px'>mesh_segment (pos, connectB, 8, 9, N) ;</p>", "markdown": "mesh_segment (pos, connectB, 8, 9, N) ;", "text": "mesh_segment (pos, connectB, 8, 9, N) ;"}, "coordinates": [{"x": 0.1319, "y": 0.5092}, {"x": 0.432, "y": 0.5092}, {"x": 0.432, "y": 0.5222}, {"x": 0.1319, "y": 0.5222}], "id": 352, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='353' data-category='paragraph' style='font-size:20px'>mesh_segment(pos, connectB, 9, 3, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 9, 3, N) ;", "text": "mesh_segment(pos, connectB, 9, 3, N) ;"}, "coordinates": [{"x": 0.1319, "y": 0.5193}, {"x": 0.432, "y": 0.5193}, {"x": 0.432, "y": 0.5324}, {"x": 0.1319, "y": 0.5324}], "id": 353, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='354' data-category='paragraph' style='font-size:18px'>mesh_segment(pos, connectB, 3, 2, N) ;</p>", "markdown": "mesh_segment(pos, connectB, 3, 2, N) ;", "text": "mesh_segment(pos, connectB, 3, 2, N) ;"}, "coordinates": [{"x": 0.1314, "y": 0.5302}, {"x": 0.4319, "y": 0.5302}, {"x": 0.4319, "y": 0.5424}, {"x": 0.1314, "y": 0.5424}], "id": 354, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='355' data-category='paragraph' style='font-size:18px'>11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·<br>mesh_segment (pos, connectB, 3, 9, N) ;<br>mesh_segment(pos, connectB, 9, 8, N) ;<br>mesh_segment(pos, connectB, 8, 4, N) ;<br>mesh_segment(pos, connectB, 4, 3, N) ;</p>", "markdown": "11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 3, 9, N) ;\nmesh_segment(pos, connectB, 9, 8, N) ;\nmesh_segment(pos, connectB, 8, 4, N) ;\nmesh_segment(pos, connectB, 4, 3, N) ;", "text": "11 INNER SQUARE POSITIVE (I. E. COUNTER-CLOCKWISE) ·\nmesh_segment (pos, connectB, 3, 9, N) ;\nmesh_segment(pos, connectB, 9, 8, N) ;\nmesh_segment(pos, connectB, 8, 4, N) ;\nmesh_segment(pos, connectB, 4, 3, N) ;"}, "coordinates": [{"x": 0.1309, "y": 0.549}, {"x": 0.5392, "y": 0.549}, {"x": 0.5392, "y": 0.6032}, {"x": 0.1309, "y": 0.6032}], "id": 355, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='356' data-category='paragraph' style='font-size:18px'>11 MERGE TOGETHER DUPLICATED NODES.<br>meshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;</p>", "markdown": "11 MERGE TOGETHER DUPLICATED NODES.\nmeshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;", "text": "11 MERGE TOGETHER DUPLICATED NODES.\nmeshtools : : merge (pos, connectB, /*tol=>*/ 1E-6, /*merge_type=>* / 0) ;"}, "coordinates": [{"x": 0.1301, "y": 0.6097}, {"x": 0.6849, "y": 0.6097}, {"x": 0.6849, "y": 0.6341}, {"x": 0.1301, "y": 0.6341}], "id": 356, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='357' data-category='paragraph' style='font-size:18px'>11 THE 2D MESH.</p>", "markdown": "11 THE 2D MESH.", "text": "11 THE 2D MESH."}, "coordinates": [{"x": 0.1332, "y": 0.6403}, {"x": 0.2543, "y": 0.6403}, {"x": 0.2543, "y": 0.6519}, {"x": 0.1332, "y": 0.6519}], "id": 357, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='358' data-category='paragraph' style='font-size:16px'>triamesh_iso: : mesher the_mesher;<br>triamesh_iso : : mesher: :data_ type data (pos, connectB) ;<br>the_mesher · run(data) ;</p>", "markdown": "triamesh_iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_ type data (pos, connectB) ;\nthe_mesher · run(data) ;", "text": "triamesh_iso: : mesher the_mesher;\ntriamesh_iso : : mesher: :data_ type data (pos, connectB) ;\nthe_mesher · run(data) ;"}, "coordinates": [{"x": 0.1322, "y": 0.6487}, {"x": 0.579, "y": 0.6487}, {"x": 0.579, "y": 0.6824}, {"x": 0.1322, "y": 0.6824}], "id": 358, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='359' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1288, "y": 0.6916}, {"x": 0.7233, "y": 0.6916}, {"x": 0.7233, "y": 0.7151}, {"x": 0.1288, "y": 0.7151}], "id": 359, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='360' data-category='paragraph' style='font-size:18px'>return 0;<br>11 main</p>", "markdown": "return 0;\n11 main", "text": "return 0;\n11 main"}, "coordinates": [{"x": 0.1279, "y": 0.7225}, {"x": 0.2073, "y": 0.7225}, {"x": 0.2073, "y": 0.7433}, {"x": 0.1279, "y": 0.7433}], "id": 360, "page": 29}, {"category": "paragraph", "content": {"html": "<br><p id='361' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1084, "y": 0.7334}, {"x": 0.1176, "y": 0.7334}, {"x": 0.1176, "y": 0.7431}, {"x": 0.1084, "y": 0.7431}], "id": 361, "page": 29}, {"category": "table", "content": {"html": "<table id='362' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 29 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0049, "y": 0.9483}, {"x": 1, "y": 0.9483}, {"x": 1, "y": 1}, {"x": 0.0049, "y": 1}], "id": 362, "page": 29}, {"category": "paragraph", "content": {"html": "<p id='363' data-category='paragraph' style='font-size:20px'>Note that this solution works because the shared edges are discretized similarly and the nodes are (almost)<br>coincident.</p>", "markdown": "Note that this solution works because the shared edges are discretized similarly and the nodes are (almost)\ncoincident.", "text": "Note that this solution works because the shared edges are discretized similarly and the nodes are (almost)\ncoincident."}, "coordinates": [{"x": 0.0749, "y": 0.0633}, {"x": 0.893, "y": 0.0633}, {"x": 0.893, "y": 0.0953}, {"x": 0.0749, "y": 0.0953}], "id": 363, "page": 30}, {"category": "figure", "content": {"html": "<figure id='364'><img alt=\"\" data-coord=\"top-left:(114,198); bottom-right:(593,674)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0923, "y": 0.1133}, {"x": 0.4782, "y": 0.1133}, {"x": 0.4782, "y": 0.3844}, {"x": 0.0923, "y": 0.3844}], "id": 364, "page": 30}, {"category": "chart", "content": {"html": "<br><figure id='365' data-category='chart'><img data-coord=\"top-left:(648,199); bottom-right:(1124,673)\" /><figcaption><p>Chart Type: bar</p></figcaption><table><thead><tr><td></td><td>Red</td><td>Blue</td><td>Green</td><td>Purple</td><td>Cyan</td></tr></thead><tbody><tr><td>item_01</td><td>10</td><td>10</td><td>10</td><td>10</td><td>20</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: bar\n|  | Red | Blue | Green | Purple | Cyan |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 10 | 10 | 10 | 20 |\n", "text": "![image](/image/placeholder)\n- Chart Type: bar\n|  | Red | Blue | Green | Purple | Cyan |\n| --- | --- | --- | --- | --- | --- |\n| item_01 | 10 | 10 | 10 | 10 | 20 |\n"}, "coordinates": [{"x": 0.5222, "y": 0.1138}, {"x": 0.9057, "y": 0.1138}, {"x": 0.9057, "y": 0.3837}, {"x": 0.5222, "y": 0.3837}], "id": 365, "page": 30}, {"category": "caption", "content": {"html": "<caption id='366' style='font-size:14px'>Figure 14 - Example with shared boundaries (T3 and all-Q4).</caption>", "markdown": "Figure 14 - Example with shared boundaries (T3 and all-Q4).", "text": "Figure 14 - Example with shared boundaries (T3 and all-Q4)."}, "coordinates": [{"x": 0.314, "y": 0.3973}, {"x": 0.6841, "y": 0.3973}, {"x": 0.6841, "y": 0.4121}, {"x": 0.314, "y": 0.4121}], "id": 366, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='367' data-category='paragraph' style='font-size:20px'>Note that the contour of the inner square is oriented completely both ways (positive and negative). In such a<br>case, the mesher favors the positive orientation and keeps the inner sub-domain.</p>", "markdown": "Note that the contour of the inner square is oriented completely both ways (positive and negative). In such a\ncase, the mesher favors the positive orientation and keeps the inner sub-domain.", "text": "Note that the contour of the inner square is oriented completely both ways (positive and negative). In such a\ncase, the mesher favors the positive orientation and keeps the inner sub-domain."}, "coordinates": [{"x": 0.0764, "y": 0.4471}, {"x": 0.899, "y": 0.4471}, {"x": 0.899, "y": 0.4778}, {"x": 0.0764, "y": 0.4778}], "id": 367, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='368' data-category='paragraph' style='font-size:16px'>A similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers<br>the inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external<br>domain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole).</p>", "markdown": "A similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers\nthe inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external\ndomain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole).", "text": "A similar case occurs when an inner contour is not properly oriented (see figure below). The mesher considers\nthe inner domain to have the same status as the \"most external domain\" adjacent to it. Here the most external\ndomain adjacent to the inner square is the outer square. Hence, the inner square will be meshed (i.e. no hole)."}, "coordinates": [{"x": 0.0762, "y": 0.4876}, {"x": 0.9163, "y": 0.4876}, {"x": 0.9163, "y": 0.5338}, {"x": 0.0762, "y": 0.5338}], "id": 368, "page": 30}, {"category": "figure", "content": {"html": "<figure id='369'><img alt=\"\" data-coord=\"top-left:(450,964); bottom-right:(788,1267)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3633, "y": 0.5501}, {"x": 0.6357, "y": 0.5501}, {"x": 0.6357, "y": 0.7225}, {"x": 0.3633, "y": 0.7225}], "id": 369, "page": 30}, {"category": "caption", "content": {"html": "<caption id='370' style='font-size:14px'>Figure 15 - Example of ambiguous orientation of an inner contour.</caption>", "markdown": "Figure 15 - Example of ambiguous orientation of an inner contour.", "text": "Figure 15 - Example of ambiguous orientation of an inner contour."}, "coordinates": [{"x": 0.293, "y": 0.7319}, {"x": 0.7036, "y": 0.7319}, {"x": 0.7036, "y": 0.746}, {"x": 0.293, "y": 0.746}], "id": 370, "page": 30}, {"category": "table", "content": {"html": "<table id='371' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 30 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0048, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0048, "y": 1}], "id": 371, "page": 30}, {"category": "paragraph", "content": {"html": "<p id='372' data-category='paragraph' style='font-size:18px'>Here is another example where a hole is adjacent to the external contour. In this case, the most external<br>domain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole).</p>", "markdown": "Here is another example where a hole is adjacent to the external contour. In this case, the most external\ndomain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole).", "text": "Here is another example where a hole is adjacent to the external contour. In this case, the most external\ndomain adjacent to the inner square is the outside void. Hence, the inner square will not be meshed (i.e. hole)."}, "coordinates": [{"x": 0.0761, "y": 0.0646}, {"x": 0.9127, "y": 0.0646}, {"x": 0.9127, "y": 0.0958}, {"x": 0.0761, "y": 0.0958}], "id": 372, "page": 31}, {"category": "figure", "content": {"html": "<figure id='373'><img alt=\"\" data-coord=\"top-left:(425,191); bottom-right:(815,559)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3431, "y": 0.1093}, {"x": 0.6575, "y": 0.1093}, {"x": 0.6575, "y": 0.3192}, {"x": 0.3431, "y": 0.3192}], "id": 373, "page": 31}, {"category": "caption", "content": {"html": "<br><caption id='374' style='font-size:14px'>Figure 16 - Hole adjacent to the external contour.</caption>", "markdown": "Figure 16 - Hole adjacent to the external contour.", "text": "Figure 16 - Hole adjacent to the external contour."}, "coordinates": [{"x": 0.3442, "y": 0.3163}, {"x": 0.6536, "y": 0.3163}, {"x": 0.6536, "y": 0.3302}, {"x": 0.3442, "y": 0.3302}], "id": 374, "page": 31}, {"category": "figure", "content": {"html": "<figure id='375'><img alt=\"\" data-coord=\"top-left:(113,701); bottom-right:(595,1183)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0917, "y": 0.3998}, {"x": 0.48, "y": 0.3998}, {"x": 0.48, "y": 0.6745}, {"x": 0.0917, "y": 0.6745}], "id": 375, "page": 31}, {"category": "chart", "content": {"html": "<br><figure id='376' data-category='chart'><img data-coord=\"top-left:(647,704); bottom-right:(1124,1180)\" /><figcaption><p>Chart Type: bar</p></figcaption><table><thead><tr><td></td><td>Dark Gray</td><td>Light Gray</td></tr></thead><tbody><tr><td>item_01</td><td>50</td><td>50</td></tr></tbody></table></figure>", "markdown": "![image](/image/placeholder)\n- Chart Type: bar\n|  | Dark Gray | Light Gray |\n| --- | --- | --- |\n| item_01 | 50 | 50 |\n", "text": "![image](/image/placeholder)\n- Chart Type: bar\n|  | Dark Gray | Light Gray |\n| --- | --- | --- |\n| item_01 | 50 | 50 |\n"}, "coordinates": [{"x": 0.5219, "y": 0.4017}, {"x": 0.9061, "y": 0.4017}, {"x": 0.9061, "y": 0.673}, {"x": 0.5219, "y": 0.673}], "id": 376, "page": 31}, {"category": "caption", "content": {"html": "<caption id='377' style='font-size:14px'>Figure 17 - Example of ambiguous orientation of an inner contour.</caption>", "markdown": "Figure 17 - Example of ambiguous orientation of an inner contour.", "text": "Figure 17 - Example of ambiguous orientation of an inner contour."}, "coordinates": [{"x": 0.2929, "y": 0.6827}, {"x": 0.7035, "y": 0.6827}, {"x": 0.7035, "y": 0.6958}, {"x": 0.2929, "y": 0.6958}], "id": 377, "page": 31}, {"category": "table", "content": {"html": "<table id='378' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 31 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0045, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0045, "y": 1}], "id": 378, "page": 31}, {"category": "heading1", "content": {"html": "<h1 id='379' style='font-size:20px'>9. Background mesh</h1>", "markdown": "# 9. Background mesh", "text": "9. Background mesh"}, "coordinates": [{"x": 0.0774, "y": 0.0645}, {"x": 0.3615, "y": 0.0645}, {"x": 0.3615, "y": 0.0875}, {"x": 0.0774, "y": 0.0875}], "id": 379, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='380' data-category='paragraph' style='font-size:16px'>Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially<br>when automatic mesh adaptivity is involved. The background mesh option is the solution in this case.</p>", "markdown": "Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case.", "text": "Sometimes it is not convenient to specify the target mesh sizes at some hard nodes. This is the case especially\nwhen automatic mesh adaptivity is involved. The background mesh option is the solution in this case."}, "coordinates": [{"x": 0.0758, "y": 0.0988}, {"x": 0.9121, "y": 0.0988}, {"x": 0.9121, "y": 0.1295}, {"x": 0.0758, "y": 0.1295}], "id": 380, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='381' data-category='paragraph' style='font-size:18px'>The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside<br>the domain. It's represented by the connectivity matrix background_mesh in the data of the mesher.</p>", "markdown": "The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It's represented by the connectivity matrix background_mesh in the data of the mesher.", "text": "The background mesh is an auxiliary mesh used by the mesher to find the target mesh size at any point inside\nthe domain. It's represented by the connectivity matrix background_mesh in the data of the mesher."}, "coordinates": [{"x": 0.0766, "y": 0.1392}, {"x": 0.9116, "y": 0.1392}, {"x": 0.9116, "y": 0.17}, {"x": 0.0766, "y": 0.17}], "id": 381, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='382' data-category='paragraph' style='font-size:16px'>As always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or<br>vectors (such as connectM or connectB).</p>", "markdown": "As always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or\nvectors (such as connectM or connectB).", "text": "As always the indices of the nodes refer to columns in the same pos matrix as all other connectivity matrices or\nvectors (such as connectM or connectB)."}, "coordinates": [{"x": 0.0764, "y": 0.18}, {"x": 0.9205, "y": 0.18}, {"x": 0.9205, "y": 0.2098}, {"x": 0.0764, "y": 0.2098}], "id": 382, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='383' data-category='paragraph' style='font-size:16px'>The nodes of the background mesh can share nodes with connectB or can all be different. They must all have<br>a valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside<br>the background mesh.</p>", "markdown": "The nodes of the background mesh can share nodes with connectB or can all be different. They must all have\na valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside\nthe background mesh.", "text": "The nodes of the background mesh can share nodes with connectB or can all be different. They must all have\na valid associated size value in the metrics array. The size map (also called metric map) is interpolated inside\nthe background mesh."}, "coordinates": [{"x": 0.0767, "y": 0.2202}, {"x": 0.9146, "y": 0.2202}, {"x": 0.9146, "y": 0.2642}, {"x": 0.0767, "y": 0.2642}], "id": 383, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='384' data-category='paragraph' style='font-size:18px'>In the following example, a regular structured background mesh is used to support a size map with a sinusoidal<br>variation in the two directions. The domain to be meshed is a simple square regularly discretized along its<br>boundaries22.</p>", "markdown": "In the following example, a regular structured background mesh is used to support a size map with a sinusoidal\nvariation in the two directions. The domain to be meshed is a simple square regularly discretized along its\nboundaries22.", "text": "In the following example, a regular structured background mesh is used to support a size map with a sinusoidal\nvariation in the two directions. The domain to be meshed is a simple square regularly discretized along its\nboundaries22."}, "coordinates": [{"x": 0.0774, "y": 0.2748}, {"x": 0.921, "y": 0.2748}, {"x": 0.921, "y": 0.3191}, {"x": 0.0774, "y": 0.3191}], "id": 384, "page": 32}, {"category": "paragraph", "content": {"html": "<p id='385' data-category='paragraph' style='font-size:14px'>22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities.</p>", "markdown": "22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities.", "text": "22 For a change, we use here the mesh_straight overload with the parameters for the sizes at the extremities."}, "coordinates": [{"x": 0.0635, "y": 0.8991}, {"x": 0.7223, "y": 0.8991}, {"x": 0.7223, "y": 0.9128}, {"x": 0.0635, "y": 0.9128}], "id": 385, "page": 32}, {"category": "table", "content": {"html": "<table id='386' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>& 32 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 32 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMeshⓇ CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | & 32 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0077, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0077, "y": 1}], "id": 386, "page": 32}, {"category": "heading1", "content": {"html": "<h1 id='387' style='font-size:18px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1056, "y": 0.0854}, {"x": 0.2648, "y": 0.0854}, {"x": 0.2648, "y": 0.0974}, {"x": 0.1056, "y": 0.0974}], "id": 387, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='388' data-category='paragraph' style='font-size:20px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1086, "y": 0.1047}, {"x": 0.1907, "y": 0.1047}, {"x": 0.1907, "y": 0.1166}, {"x": 0.1086, "y": 0.1166}], "id": 388, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='389' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1158}, {"x": 0.1187, "y": 0.1158}, {"x": 0.1187, "y": 0.1251}, {"x": 0.1094, "y": 0.1251}], "id": 389, "page": 33}, {"category": "table", "content": {"html": "<br><table id='390' style='font-size:18px'><thead></thead><tbody><tr><td>const double</td><td>L(4.), h0 (0. 25) , h1 (0. 05) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connectE2, connectT3, BGM;</td></tr><tr><td>DoubleVec</td><td>sizes;</td></tr><tr><td>unsigned</td><td>n;</td></tr><tr><td>double</td><td>W, h;</td></tr></tbody></table>", "markdown": "| const double | L(4.), h0 (0. 25) , h1 (0. 05) ; |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE2, connectT3, BGM; |\n| DoubleVec | sizes; |\n| unsigned | n; |\n| double | W, h; |\n", "text": "| const double | L(4.), h0 (0. 25) , h1 (0. 05) ; |\n| --- | --- |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connectE2, connectT3, BGM; |\n| DoubleVec | sizes; |\n| unsigned | n; |\n| double | W, h; |\n"}, "coordinates": [{"x": 0.129, "y": 0.1223}, {"x": 0.4909, "y": 0.1223}, {"x": 0.4909, "y": 0.1932}, {"x": 0.129, "y": 0.1932}], "id": 390, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='391' data-category='paragraph' style='font-size:16px'>11 UNLOCK THE DLL.<br>triamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso: :registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1318, "y": 0.1997}, {"x": 0.691, "y": 0.1997}, {"x": 0.691, "y": 0.2221}, {"x": 0.1318, "y": 0.2221}], "id": 391, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='392' data-category='paragraph' style='font-size:18px'>11 VERTICES AND LINE MESHES.<br>pos · push_back (DoubleVec2(-L/2, -L/2)) ;<br>pos · push_back(DoubleVec2 (+L/2, -L/2)) ;<br>pos · push_back(DoubleVec2 (+L/2, +L/2)) ;<br>pos · push_back(DoubleVec2 (-L/2, +L/2))<br>meshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;<br>indices. pop_ back() ;<br>meshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;<br>indices. pop_ back() ;<br>meshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;<br>indices. pop_back() ;<br>meshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;<br>meshtools1d: : indices_to_connectE2(indices, connectE2) ;</p>", "markdown": "11 VERTICES AND LINE MESHES.\npos · push_back (DoubleVec2(-L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, +L/2)) ;\npos · push_back(DoubleVec2 (-L/2, +L/2))\nmeshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;\nindices. pop_back() ;\nmeshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;", "text": "11 VERTICES AND LINE MESHES.\npos · push_back (DoubleVec2(-L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, -L/2)) ;\npos · push_back(DoubleVec2 (+L/2, +L/2)) ;\npos · push_back(DoubleVec2 (-L/2, +L/2))\nmeshtools1d: : mesh_ straight(pos, 日, 1, ho, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 1, 2, h0, h0, true, indices) ;\nindices. pop_ back() ;\nmeshtools1d : : mesh_ straight(pos, 2, 3, h0, h0, true, indices) ;\nindices. pop_back() ;\nmeshtools1d : : mesh_straight(pos, 3, 0, h0, ho, true, indices) ;\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;"}, "coordinates": [{"x": 0.1332, "y": 0.2298}, {"x": 0.628, "y": 0.2298}, {"x": 0.628, "y": 0.355}, {"x": 0.1332, "y": 0.355}], "id": 392, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='393' data-category='paragraph' style='font-size:18px'>11 THE BACKGROUND MESH.</p>", "markdown": "11 THE BACKGROUND MESH.", "text": "11 THE BACKGROUND MESH."}, "coordinates": [{"x": 0.1333, "y": 0.3614}, {"x": 0.3197, "y": 0.3614}, {"x": 0.3197, "y": 0.3724}, {"x": 0.1333, "y": 0.3724}], "id": 393, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='394' data-category='paragraph' style='font-size:14px'>n = unsigned(L/h1) ;</p>", "markdown": "n = unsigned(L/h1) ;", "text": "n = unsigned(L/h1) ;"}, "coordinates": [{"x": 0.1333, "y": 0.3726}, {"x": 0.2923, "y": 0.3726}, {"x": 0.2923, "y": 0.3821}, {"x": 0.1333, "y": 0.3821}], "id": 394, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='395' data-category='paragraph' style='font-size:20px'>indices.clear () ;<br>meshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;<br>indices.pop_ back() ;<br>meshtools1d: :mesh_ straight(pos, 1, 2, n, indices);<br>indices.pop_back() ;<br>meshtools1d: :mesh_ straight(pos, 2, 3, n, indices);<br>indices.pop_back() ;<br>meshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;<br>meshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;</p>", "markdown": "indices.clear () ;\nmeshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;\nindices.pop_ back() ;\nmeshtools1d: :mesh_ straight(pos, 1, 2, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_ straight(pos, 2, 3, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;\nmeshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;", "text": "indices.clear () ;\nmeshtools1d: :mesh_ straight(pos, 0, 1, n, indices) ;\nindices.pop_ back() ;\nmeshtools1d: :mesh_ straight(pos, 1, 2, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_ straight(pos, 2, 3, n, indices);\nindices.pop_back() ;\nmeshtools1d: :mesh_straight(pos, 3, 0, n, indices) ;\nmeshtools2d: :mesh_struct_T3(pos, indices, n, true, BGM) ;"}, "coordinates": [{"x": 0.1306, "y": 0.3823}, {"x": 0.5845, "y": 0.3823}, {"x": 0.5845, "y": 0.4703}, {"x": 0.1306, "y": 0.4703}], "id": 395, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='396' data-category='paragraph' style='font-size:18px'>11 THE METRICS ON THE BACKGROUND MESH.<br>indices.clear();<br>meshtools: :unique_ indices(indices, BGM) ;<br>sizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.<br>for (size_t i = 0; i く indices.size(); ++i)</p>", "markdown": "11 THE METRICS ON THE BACKGROUND MESH.\nindices.clear();\nmeshtools: :unique_ indices(indices, BGM) ;\nsizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.\nfor (size_t i = 0; i く indices.size(); ++i)", "text": "11 THE METRICS ON THE BACKGROUND MESH.\nindices.clear();\nmeshtools: :unique_ indices(indices, BGM) ;\nsizes.resize(pos. cols() , 0.) ; 11 Null value for nodes not in BGM.\nfor (size_t i = 0; i く indices.size(); ++i)"}, "coordinates": [{"x": 0.1305, "y": 0.4755}, {"x": 0.7071, "y": 0.4755}, {"x": 0.7071, "y": 0.527}, {"x": 0.1305, "y": 0.527}], "id": 396, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='397' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1332, "y": 0.5241}, {"x": 0.1425, "y": 0.5241}, {"x": 0.1425, "y": 0.5338}, {"x": 0.1332, "y": 0.5338}], "id": 397, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='398' data-category='paragraph' style='font-size:18px'>n = indices[i];<br>n)));<br>W = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;<br>h = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +<br>sizes[n] = h;</p>", "markdown": "n = indices[i];\nn)));\nW = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;\nh = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +\nsizes[n] = h;", "text": "n = indices[i];\nn)));\nW = std: :max(: :fabs(pos(0, n)), ⌀1 /2.;\nh = : :cos(8. *M_PI*w/L) * (h0-h1)/2. +\nsizes[n] = h;"}, "coordinates": [{"x": 0.151, "y": 0.5328}, {"x": 0.5721, "y": 0.5328}, {"x": 0.5721, "y": 0.5741}, {"x": 0.151, "y": 0.5741}], "id": 398, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='399' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1317, "y": 0.5707}, {"x": 0.1419, "y": 0.5707}, {"x": 0.1419, "y": 0.5826}, {"x": 0.1317, "y": 0.5826}], "id": 399, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='400' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH.<br>triamesh_ iso: : mesher the_mesher;<br>triamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;<br>data.background_mesh = BGM;<br>data. metrics = sizes;<br>the_mesher · run(data) ;</p>", "markdown": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;\ndata.background_mesh = BGM;\ndata. metrics = sizes;\nthe_mesher · run(data) ;", "text": "11 THE 2D MESH.\ntriamesh_ iso: : mesher the_mesher;\ntriamesh_ iso: : mesher : : data_ type data (pos, connectE2) ;\ndata.background_mesh = BGM;\ndata. metrics = sizes;\nthe_mesher · run(data) ;"}, "coordinates": [{"x": 0.1322, "y": 0.5905}, {"x": 0.5873, "y": 0.5905}, {"x": 0.5873, "y": 0.6475}, {"x": 0.1322, "y": 0.6475}], "id": 400, "page": 33}, {"category": "paragraph", "content": {"html": "<p id='401' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1297, "y": 0.6564}, {"x": 0.7223, "y": 0.6564}, {"x": 0.7223, "y": 0.6782}, {"x": 0.1297, "y": 0.6782}], "id": 401, "page": 33}, {"category": "paragraph", "content": {"html": "<br><p id='402' data-category='paragraph' style='font-size:18px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1053, "y": 0.6857}, {"x": 0.2064, "y": 0.6857}, {"x": 0.2064, "y": 0.7062}, {"x": 0.1053, "y": 0.7062}], "id": 402, "page": 33}, {"category": "table", "content": {"html": "<table id='403' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 33 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0045, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0045, "y": 1}], "id": 403, "page": 33}, {"category": "figure", "content": {"html": "<figure id='404'><img alt=\"\" data-coord=\"top-left:(117,118); bottom-right:(593,592)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0943, "y": 0.0674}, {"x": 0.4779, "y": 0.0674}, {"x": 0.4779, "y": 0.3375}, {"x": 0.0943, "y": 0.3375}], "id": 404, "page": 34}, {"category": "figure", "content": {"html": "<br><figure id='405'><img alt=\"\" data-coord=\"top-left:(650,117); bottom-right:(1124,591)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.524, "y": 0.0668}, {"x": 0.906, "y": 0.0668}, {"x": 0.906, "y": 0.337}, {"x": 0.524, "y": 0.337}], "id": 405, "page": 34}, {"category": "caption", "content": {"html": "<caption id='406' style='font-size:14px'>Figure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).</caption>", "markdown": "Figure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4).", "text": "Figure 18 - Use of a background mesh to support a sizes map on the domain (T3 and all-Q4)."}, "coordinates": [{"x": 0.2175, "y": 0.3471}, {"x": 0.7806, "y": 0.3471}, {"x": 0.7806, "y": 0.3619}, {"x": 0.2175, "y": 0.3619}], "id": 406, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='407' data-category='paragraph' style='font-size:20px'>The background mesh is the same structured triangle mesh in both cases (here, covering all the domain):</p>", "markdown": "The background mesh is the same structured triangle mesh in both cases (here, covering all the domain):", "text": "The background mesh is the same structured triangle mesh in both cases (here, covering all the domain):"}, "coordinates": [{"x": 0.0757, "y": 0.3964}, {"x": 0.8728, "y": 0.3964}, {"x": 0.8728, "y": 0.4135}, {"x": 0.0757, "y": 0.4135}], "id": 407, "page": 34}, {"category": "figure", "content": {"html": "<figure id='408'><img alt=\"\" data-coord=\"top-left:(381,756); bottom-right:(860,1233)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3076, "y": 0.4313}, {"x": 0.6934, "y": 0.4313}, {"x": 0.6934, "y": 0.7035}, {"x": 0.3076, "y": 0.7035}], "id": 408, "page": 34}, {"category": "caption", "content": {"html": "<caption id='409' style='font-size:16px'>Figure 19 - The background mesh used in the previous examples.</caption>", "markdown": "Figure 19 - The background mesh used in the previous examples.", "text": "Figure 19 - The background mesh used in the previous examples."}, "coordinates": [{"x": 0.2985, "y": 0.7132}, {"x": 0.7, "y": 0.7132}, {"x": 0.7, "y": 0.7273}, {"x": 0.2985, "y": 0.7273}], "id": 409, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='410' data-category='paragraph' style='font-size:18px'>The background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it<br>and/or be partially outside of the domain. In the areas not covered by the background mesh, the default size<br>field based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead.</p>", "markdown": "The background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it\nand/or be partially outside of the domain. In the areas not covered by the background mesh, the default size\nfield based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead.", "text": "The background mesh does not need to fit exactly the domain to be meshed. It can cover only a small part of it\nand/or be partially outside of the domain. In the areas not covered by the background mesh, the default size\nfield based on hard edge length, specific sizes at the hard nodes and target size (if any of them) is used instead."}, "coordinates": [{"x": 0.0759, "y": 0.762}, {"x": 0.9194, "y": 0.762}, {"x": 0.9194, "y": 0.8078}, {"x": 0.0759, "y": 0.8078}], "id": 410, "page": 34}, {"category": "paragraph", "content": {"html": "<p id='411' data-category='paragraph' style='font-size:18px'>Here is an example where the domain is a disk and the background mesh is also a disk but with half the radius.<br>We have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area.</p>", "markdown": "Here is an example where the domain is a disk and the background mesh is also a disk but with half the radius.\nWe have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area.", "text": "Here is an example where the domain is a disk and the background mesh is also a disk but with half the radius.\nWe have set a uniform value for the sizes map on the background mesh to get a finer mesh in this area."}, "coordinates": [{"x": 0.0764, "y": 0.8171}, {"x": 0.916, "y": 0.8171}, {"x": 0.916, "y": 0.8481}, {"x": 0.0764, "y": 0.8481}], "id": 411, "page": 34}, {"category": "table", "content": {"html": "<table id='412' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 34 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.006, "y": 0.9478}, {"x": 1, "y": 0.9478}, {"x": 1, "y": 1}, {"x": 0.006, "y": 1}], "id": 412, "page": 34}, {"category": "figure", "content": {"html": "<figure id='413'><img alt=\"\" data-coord=\"top-left:(374,111); bottom-right:(867,598)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.3019, "y": 0.0633}, {"x": 0.6993, "y": 0.0633}, {"x": 0.6993, "y": 0.3409}, {"x": 0.3019, "y": 0.3409}], "id": 413, "page": 35}, {"category": "caption", "content": {"html": "<caption id='414' style='font-size:16px'>Figure 20 - Background mesh covering only a fraction of the domain.</caption>", "markdown": "Figure 20 - Background mesh covering only a fraction of the domain.", "text": "Figure 20 - Background mesh covering only a fraction of the domain."}, "coordinates": [{"x": 0.2873, "y": 0.3474}, {"x": 0.7089, "y": 0.3474}, {"x": 0.7089, "y": 0.3616}, {"x": 0.2873, "y": 0.3616}], "id": 414, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='415' data-category='paragraph' style='font-size:20px'>We can also consider the case where the boundary mesh of the domain must also be governed by a<br>background mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to<br>support the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"<br>and the associated sizes. The discretization for this 1D background mesh must be fine enough to represent<br>accurately the geometry of the line.</p>", "markdown": "We can also consider the case where the boundary mesh of the domain must also be governed by a\nbackground mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to\nsupport the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"\nand the associated sizes. The discretization for this 1D background mesh must be fine enough to represent\naccurately the geometry of the line.", "text": "We can also consider the case where the boundary mesh of the domain must also be governed by a\nbackground mesh. In addition to the 2D-background mesh we need also to discretize the boundary in order to\nsupport the sizes map on this line. Then the real boundary mesh is generated using this 1D \"background mesh\"\nand the associated sizes. The discretization for this 1D background mesh must be fine enough to represent\naccurately the geometry of the line."}, "coordinates": [{"x": 0.0757, "y": 0.3974}, {"x": 0.9193, "y": 0.3974}, {"x": 0.9193, "y": 0.4703}, {"x": 0.0757, "y": 0.4703}], "id": 415, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='416' data-category='paragraph' style='font-size:18px'>An overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full<br>circle with 200 nodes in indices0 starting from node #1 and centered on point CR:</p>", "markdown": "An overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full\ncircle with 200 nodes in indices0 starting from node #1 and centered on point CR:", "text": "An overload of the cm2 : : meshtools1d : : mesh_ line function is used for that23. Here we discretize a full\ncircle with 200 nodes in indices0 starting from node #1 and centered on point CR:"}, "coordinates": [{"x": 0.0761, "y": 0.4801}, {"x": 0.8842, "y": 0.4801}, {"x": 0.8842, "y": 0.5111}, {"x": 0.0761, "y": 0.5111}], "id": 416, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='417' data-category='paragraph' style='font-size:14px'>meshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;<br>indices0 . back() = indices0. front();</p>", "markdown": "meshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;\nindices0 . back() = indices0. front();", "text": "meshtools1d : : extrude_rotate(pos, 1, CR, 2 * M_PI, 200, indices0) ;\nindices0 . back() = indices0. front();"}, "coordinates": [{"x": 0.1025, "y": 0.5462}, {"x": 0.6351, "y": 0.5462}, {"x": 0.6351, "y": 0.5716}, {"x": 0.1025, "y": 0.5716}], "id": 417, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='418' data-category='paragraph' style='font-size:18px'>Sizes are specified on the nodes of this circle and a new set of adapted nodes are generated:</p>", "markdown": "Sizes are specified on the nodes of this circle and a new set of adapted nodes are generated:", "text": "Sizes are specified on the nodes of this circle and a new set of adapted nodes are generated:"}, "coordinates": [{"x": 0.0763, "y": 0.6129}, {"x": 0.7821, "y": 0.6129}, {"x": 0.7821, "y": 0.6303}, {"x": 0.0763, "y": 0.6303}], "id": 418, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='419' data-category='paragraph' style='font-size:16px'>vecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.<br>meshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,<br>UINT_MAX, 0. , indices, new U, new_sizes) ;<br>meshtools1d : : indices_to_connectE2 (indices, connectE) ;</p>", "markdown": "vecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.\nmeshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,\nUINT_MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectE) ;", "text": "vecvec : :push_back(sizes, indices0, sizes0) ; 11 Pick-up sizes for indices0.\nmeshtoo ls1d : : mesh_line (pos, indices0, sizes0, true, 1,\nUINT_MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d : : indices_to_connectE2 (indices, connectE) ;"}, "coordinates": [{"x": 0.1018, "y": 0.6653}, {"x": 0.7272, "y": 0.6653}, {"x": 0.7272, "y": 0.7077}, {"x": 0.1018, "y": 0.7077}], "id": 419, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='420' data-category='paragraph' style='font-size:20px'>The parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,<br>maximum of UINT_MAX edges along the arc and no chordal control21.</p>", "markdown": "The parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,\nmaximum of UINT_MAX edges along the arc and no chordal control21.", "text": "The parameters true, 1, UINT_MAX and 0. stand for: force even number of edges, minimum of 1 edge,\nmaximum of UINT_MAX edges along the arc and no chordal control21."}, "coordinates": [{"x": 0.0746, "y": 0.7507}, {"x": 0.8591, "y": 0.7507}, {"x": 0.8591, "y": 0.781}, {"x": 0.0746, "y": 0.781}], "id": 420, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='421' data-category='paragraph' style='font-size:18px'>The indices vector now contains the nodes of the circle mesh adapted to the metrics.</p>", "markdown": "The indices vector now contains the nodes of the circle mesh adapted to the metrics.", "text": "The indices vector now contains the nodes of the circle mesh adapted to the metrics."}, "coordinates": [{"x": 0.0769, "y": 0.7908}, {"x": 0.7392, "y": 0.7908}, {"x": 0.7392, "y": 0.8071}, {"x": 0.0769, "y": 0.8071}], "id": 421, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='422' data-category='paragraph' style='font-size:18px'>new_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these<br>nodes but these vectors are not used in the rest of the example.</p>", "markdown": "new_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these\nnodes but these vectors are not used in the rest of the example.", "text": "new_ U and new_sizes contain the parameter values along the circle and the interpolated metrics at these\nnodes but these vectors are not used in the rest of the example."}, "coordinates": [{"x": 0.0766, "y": 0.8177}, {"x": 0.8923, "y": 0.8177}, {"x": 0.8923, "y": 0.8474}, {"x": 0.0766, "y": 0.8474}], "id": 422, "page": 35}, {"category": "paragraph", "content": {"html": "<p id='423' data-category='paragraph' style='font-size:16px'>23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library.</p>", "markdown": "23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library.", "text": "23 Several overloads for mesh_straight, mesh_spl ine and mesh_ line exist in the meshtools1d library."}, "coordinates": [{"x": 0.0637, "y": 0.8987}, {"x": 0.721, "y": 0.8987}, {"x": 0.721, "y": 0.9136}, {"x": 0.0637, "y": 0.9136}], "id": 423, "page": 35}, {"category": "table", "content": {"html": "<table id='424' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>35</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 35 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0121, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0121, "y": 1}], "id": 424, "page": 35}, {"category": "figure", "content": {"html": "<figure id='425'><img alt=\"\" data-coord=\"top-left:(117,117); bottom-right:(597,590)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0948, "y": 0.0672}, {"x": 0.4811, "y": 0.0672}, {"x": 0.4811, "y": 0.3368}, {"x": 0.0948, "y": 0.3368}], "id": 425, "page": 36}, {"category": "figure", "content": {"html": "<br><figure id='426'><img alt=\"\" data-coord=\"top-left:(645,109); bottom-right:(1127,593)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.52, "y": 0.0623}, {"x": 0.9084, "y": 0.0623}, {"x": 0.9084, "y": 0.3381}, {"x": 0.52, "y": 0.3381}], "id": 426, "page": 36}, {"category": "caption", "content": {"html": "<caption id='427' style='font-size:16px'>Figure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).</caption>", "markdown": "Figure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4).", "text": "Figure 21 - Background meshes for both the boundary and the domain (T3 and all-Q4)."}, "coordinates": [{"x": 0.2353, "y": 0.347}, {"x": 0.7636, "y": 0.347}, {"x": 0.7636, "y": 0.3619}, {"x": 0.2353, "y": 0.3619}], "id": 427, "page": 36}, {"category": "paragraph", "content": {"html": "<p id='428' data-category='paragraph' style='font-size:20px'>Note: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it<br>to a changed metrics map.</p>", "markdown": "Note: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it\nto a changed metrics map.", "text": "Note: A background mesh can be used also in REGULARIZE_MODE on a pre-existing mesh to adapt/optimize it\nto a changed metrics map."}, "coordinates": [{"x": 0.0765, "y": 0.3965}, {"x": 0.914, "y": 0.3965}, {"x": 0.914, "y": 0.4282}, {"x": 0.0765, "y": 0.4282}], "id": 428, "page": 36}, {"category": "paragraph", "content": {"html": "<p id='429' data-category='paragraph' style='font-size:14px'>24 See HTML reference manual for more info on these parameters.</p>", "markdown": "24 See HTML reference manual for more info on these parameters.", "text": "24 See HTML reference manual for more info on these parameters."}, "coordinates": [{"x": 0.0628, "y": 0.899}, {"x": 0.4683, "y": 0.899}, {"x": 0.4683, "y": 0.9126}, {"x": 0.0628, "y": 0.9126}], "id": 429, "page": 36}, {"category": "table", "content": {"html": "<table id='430' style='font-size:18px'><thead></thead><tbody><tr><td>QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials</td></tr></tbody></table>", "markdown": "| QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials |\n| --- | --- |\n", "text": "| QuadMesh� Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 Iso/Aniso - 36 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0068, "y": 0.9478}, {"x": 1, "y": 0.9478}, {"x": 1, "y": 1}, {"x": 0.0068, "y": 1}], "id": 430, "page": 36}, {"category": "heading1", "content": {"html": "<h1 id='431' style='font-size:18px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1055, "y": 0.0854}, {"x": 0.2645, "y": 0.0854}, {"x": 0.2645, "y": 0.0974}, {"x": 0.1055, "y": 0.0974}], "id": 431, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='432' data-category='paragraph' style='font-size:18px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1085, "y": 0.1048}, {"x": 0.1905, "y": 0.1048}, {"x": 0.1905, "y": 0.1165}, {"x": 0.1085, "y": 0.1165}], "id": 432, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='433' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1158}, {"x": 0.1187, "y": 0.1158}, {"x": 0.1187, "y": 0.1251}, {"x": 0.1094, "y": 0.1251}], "id": 433, "page": 37}, {"category": "table", "content": {"html": "<br><table id='434' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>R(4.) ;</td></tr><tr><td>const double</td><td>h0(0.5) , h1(0.05) , sig(0. 40) ;</td></tr><tr><td>const DoubleVec2</td><td>CR(0 · 0.) , PO(R, 0.) ; ,</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>DoubleVec</td><td>new_U, sizes, sizes0, new_sizes;</td></tr><tr><td>UIntVec</td><td>indices0, indices;</td></tr><tr><td>UIntMat</td><td>connectE, connectM, BGM;</td></tr><tr><td>double</td><td>x, y, W, wo, w1, w2;</td></tr></tbody></table>", "markdown": "| const double | R(4.) ; |\n| --- | --- |\n| const double | h0(0.5) , h1(0.05) , sig(0. 40) ; |\n| const DoubleVec2 | CR(0 · 0.) , PO(R, 0.) ; , |\n| DoubleMat | pos; |\n| DoubleVec | new_U, sizes, sizes0, new_sizes; |\n| UIntVec | indices0, indices; |\n| UIntMat | connectE, connectM, BGM; |\n| double | x, y, W, wo, w1, w2; |\n", "text": "| const double | R(4.) ; |\n| --- | --- |\n| const double | h0(0.5) , h1(0.05) , sig(0. 40) ; |\n| const DoubleVec2 | CR(0 · 0.) , PO(R, 0.) ; , |\n| DoubleMat | pos; |\n| DoubleVec | new_U, sizes, sizes0, new_sizes; |\n| UIntVec | indices0, indices; |\n| UIntMat | connectE, connectM, BGM; |\n| double | x, y, W, wo, w1, w2; |\n"}, "coordinates": [{"x": 0.1288, "y": 0.1242}, {"x": 0.5936, "y": 0.1242}, {"x": 0.5936, "y": 0.2032}, {"x": 0.1288, "y": 0.2032}], "id": 434, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='435' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;<br>\"<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;\n\"\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_iso : : registration(\"Licensed to SMART Inc . \"F53EA108BCWX\") ;\n\"\n,"}, "coordinates": [{"x": 0.1306, "y": 0.2074}, {"x": 0.692, "y": 0.2074}, {"x": 0.692, "y": 0.232}, {"x": 0.1306, "y": 0.232}], "id": 435, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='436' data-category='paragraph' style='font-size:14px'>triamesh_iso : : mesher the_mesher;</p>", "markdown": "triamesh_iso : : mesher the_mesher;", "text": "triamesh_iso : : mesher the_mesher;"}, "coordinates": [{"x": 0.1334, "y": 0.2376}, {"x": 0.4482, "y": 0.2376}, {"x": 0.4482, "y": 0.2499}, {"x": 0.1334, "y": 0.2499}], "id": 436, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='437' data-category='paragraph' style='font-size:14px'>pos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·<br>pos . push_back(P0) ; 11 Point #1 (start of the circle) ·</p>", "markdown": "pos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·\npos . push_back(P0) ; 11 Point #1 (start of the circle) ·", "text": "pos · push_back(CR) ; 11 Point #⊙ (centre of the circle) ·\npos . push_back(P0) ; 11 Point #1 (start of the circle) ·"}, "coordinates": [{"x": 0.1328, "y": 0.257}, {"x": 0.5923, "y": 0.257}, {"x": 0.5923, "y": 0.2779}, {"x": 0.1328, "y": 0.2779}], "id": 437, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='438' data-category='paragraph' style='font-size:16px'>11 THE 2D BACKGROUND MESH<br>n = unsigned (2. *M_PI*R / h1) ;<br>meshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;<br>indices. back() = indices · front() ; 11 Close the circle.<br>meshtools1d: : indices_ to_connectE2(indices, connectE) ;<br>triamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;<br>the_ mesher . run(BGMdata) ;<br>BGMdata.extract(pos, BGM) ;</p>", "markdown": "11 THE 2D BACKGROUND MESH\nn = unsigned (2. *M_PI*R / h1) ;\nmeshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;\nindices. back() = indices · front() ; 11 Close the circle.\nmeshtools1d: : indices_ to_connectE2(indices, connectE) ;\ntriamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;\nthe_ mesher . run(BGMdata) ;\nBGMdata.extract(pos, BGM) ;", "text": "11 THE 2D BACKGROUND MESH\nn = unsigned (2. *M_PI*R / h1) ;\nmeshtools1d: :extrude rotate(pos, 1, CR, 2 * M_PI, n, indices) ;\nindices. back() = indices · front() ; 11 Close the circle.\nmeshtools1d: : indices_ to_connectE2(indices, connectE) ;\ntriamesh_ iso : : mesher : : data_type BGMdata(pos, connectE) ;\nthe_ mesher . run(BGMdata) ;\nBGMdata.extract(pos, BGM) ;"}, "coordinates": [{"x": 0.1309, "y": 0.2847}, {"x": 0.6388, "y": 0.2847}, {"x": 0.6388, "y": 0.3628}, {"x": 0.1309, "y": 0.3628}], "id": 438, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='439' data-category='paragraph' style='font-size:18px'>11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·<br>meshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;<br>indices0.back() = indices0.front();</p>", "markdown": "11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·\nmeshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;\nindices0.back() = indices0.front();", "text": "11 MESH THE GEOMETRIC SUPPORT OF THE BOUNDARY (1D BACKGROUND MESH) ·\nmeshtools1d: :extrude_ rotate(pos, 1, CR, 2*M_PI, 200, indices0) ;\nindices0.back() = indices0.front();"}, "coordinates": [{"x": 0.1321, "y": 0.3706}, {"x": 0.6749, "y": 0.3706}, {"x": 0.6749, "y": 0.4009}, {"x": 0.1321, "y": 0.4009}], "id": 439, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='440' data-category='paragraph' style='font-size:16px'>11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .<br>indices.clear();<br>meshtools: :unique indices(indices, BGM) ;<br>indices.push_back(indices0); 11 Also the nodes of the circle.<br>sizes. resize(pos. cols() , 0.);<br>for (size_t i = 0; i く indices.size() ; ++i)</p>", "markdown": "11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .\nindices.clear();\nmeshtools: :unique indices(indices, BGM) ;\nindices.push_back(indices0); 11 Also the nodes of the circle.\nsizes. resize(pos. cols() , 0.);\nfor (size_t i = 0; i く indices.size() ; ++i)", "text": "11 THE METRICS ON THE BACKGROUND MESHES (1D AND 2D) .\nindices.clear();\nmeshtools: :unique indices(indices, BGM) ;\nindices.push_back(indices0); 11 Also the nodes of the circle.\nsizes. resize(pos. cols() , 0.);\nfor (size_t i = 0; i く indices.size() ; ++i)"}, "coordinates": [{"x": 0.1325, "y": 0.4072}, {"x": 0.6678, "y": 0.4072}, {"x": 0.6678, "y": 0.4716}, {"x": 0.1325, "y": 0.4716}], "id": 440, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='441' data-category='paragraph' style='font-size:16px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.467}, {"x": 0.143, "y": 0.467}, {"x": 0.143, "y": 0.4763}, {"x": 0.1338, "y": 0.4763}], "id": 441, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='442' data-category='paragraph' style='font-size:14px'>const size_t n = indices[i] ;<br>X = pos(0, n) ;<br>y = pos(1, n) ;<br>w⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;<br>w1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;<br>w2 = : : fabs (x + R/2) ;<br>W = std : : min (wo, w1) ; sigil. Gaussian variations.<br>W = std : : min (w, w2) /<br>W = : :exp(-w*w) ;<br>sizes[n] = = h0* (1. -w) + h1*w;</p>", "markdown": "const size_t n = indices[i] ;\nX = pos(0, n) ;\ny = pos(1, n) ;\nw⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;\nw1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;\nw2 = : : fabs (x + R/2) ;\nW = std : : min (wo, w1) ; sigil. Gaussian variations.\nW = std : : min (w, w2) /\nW = : :exp(-w*w) ;\nsizes[n] = = h0* (1. -w) + h1*w;", "text": "const size_t n = indices[i] ;\nX = pos(0, n) ;\ny = pos(1, n) ;\nw⊙ = : : fabs (y + 2*x - R/2) / : :sqrt(5.) ;\nw1 = : : fabs (y - X - R/2) / : :sqrt(2.) ;\nw2 = : : fabs (x + R/2) ;\nW = std : : min (wo, w1) ; sigil. Gaussian variations.\nW = std : : min (w, w2) /\nW = : :exp(-w*w) ;\nsizes[n] = = h0* (1. -w) + h1*w;"}, "coordinates": [{"x": 0.152, "y": 0.4759}, {"x": 0.5467, "y": 0.4759}, {"x": 0.5467, "y": 0.573}, {"x": 0.152, "y": 0.573}], "id": 442, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='443' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1327, "y": 0.5713}, {"x": 0.1409, "y": 0.5713}, {"x": 0.1409, "y": 0.5821}, {"x": 0.1327, "y": 0.5821}], "id": 443, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='444' data-category='paragraph' style='font-size:20px'>11 Pick-up the sizes along the circle.<br>sizes0.clear();<br>vecvec: :push_back(sizes, indices0, sizes0) ;</p>", "markdown": "11 Pick-up the sizes along the circle.\nsizes0.clear();\nvecvec: :push_back(sizes, indices0, sizes0) ;", "text": "11 Pick-up the sizes along the circle.\nsizes0.clear();\nvecvec: :push_back(sizes, indices0, sizes0) ;"}, "coordinates": [{"x": 0.1307, "y": 0.5888}, {"x": 0.4831, "y": 0.5888}, {"x": 0.4831, "y": 0.621}, {"x": 0.1307, "y": 0.621}], "id": 444, "page": 37}, {"category": "paragraph", "content": {"html": "<br><p id='445' data-category='paragraph' style='font-size:20px'>11 MESH THE CIRCLE ACCORDING TO THE METRICS.<br>indices.clear();<br>connectE.clear();<br>meshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,<br>UINT MAX, 0. , indices, new U, new_sizes) ;<br>meshtools1d: :indices_to_connectE2(indices, connectE) ;</p>", "markdown": "11 MESH THE CIRCLE ACCORDING TO THE METRICS.\nindices.clear();\nconnectE.clear();\nmeshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,\nUINT MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d: :indices_to_connectE2(indices, connectE) ;", "text": "11 MESH THE CIRCLE ACCORDING TO THE METRICS.\nindices.clear();\nconnectE.clear();\nmeshtools1d: :mesh_line(pos, indices0, sizes0, true, 1,\nUINT MAX, 0. , indices, new U, new_sizes) ;\nmeshtools1d: :indices_to_connectE2(indices, connectE) ;"}, "coordinates": [{"x": 0.1301, "y": 0.626}, {"x": 0.6524, "y": 0.626}, {"x": 0.6524, "y": 0.6877}, {"x": 0.1301, "y": 0.6877}], "id": 445, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='446' data-category='paragraph' style='font-size:16px'>11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.<br>triamesh_ iso: : mesher : : data_ type data(pos, connectE) ;<br>data.background_mesh = BGM;<br>data.metrics = sizes;<br>the_mesher run(data) ;</p>", "markdown": "11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.\ntriamesh_ iso: : mesher : : data_ type data(pos, connectE) ;\ndata.background_mesh = BGM;\ndata.metrics = sizes;\nthe_mesher run(data) ;", "text": "11 THE 2D MESH ACCORDING TO THE METRICS ON THE BGM.\ntriamesh_ iso: : mesher : : data_ type data(pos, connectE) ;\ndata.background_mesh = BGM;\ndata.metrics = sizes;\nthe_mesher run(data) ;"}, "coordinates": [{"x": 0.1317, "y": 0.6936}, {"x": 0.5784, "y": 0.6936}, {"x": 0.5784, "y": 0.7393}, {"x": 0.1317, "y": 0.7393}], "id": 446, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='447' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\" , data.pos, data.connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1305, "y": 0.7497}, {"x": 0.7238, "y": 0.7497}, {"x": 0.7238, "y": 0.7729}, {"x": 0.1305, "y": 0.7729}], "id": 447, "page": 37}, {"category": "paragraph", "content": {"html": "<p id='448' data-category='paragraph' style='font-size:18px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1057, "y": 0.7806}, {"x": 0.2068, "y": 0.7806}, {"x": 0.2068, "y": 0.8015}, {"x": 0.1057, "y": 0.8015}], "id": 448, "page": 37}, {"category": "table", "content": {"html": "<table id='449' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh � & CM2 QuadMesh� Iso/Aniso - 37 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0056, "y": 0.9485}, {"x": 0.9999, "y": 0.9485}, {"x": 0.9999, "y": 1}, {"x": 0.0056, "y": 1}], "id": 449, "page": 37}, {"category": "heading1", "content": {"html": "<h1 id='450' style='font-size:22px'>10. Anisotropic meshes</h1>", "markdown": "# 10. Anisotropic meshes", "text": "10. Anisotropic meshes"}, "coordinates": [{"x": 0.0764, "y": 0.0639}, {"x": 0.3974, "y": 0.0639}, {"x": 0.3974, "y": 0.087}, {"x": 0.0764, "y": 0.087}], "id": 450, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='451' data-category='paragraph' style='font-size:18px'>CM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce<br>equilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific<br>directions. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic<br>unstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their<br>isotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic<br>case we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined<br>by a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array.</p>", "markdown": "CM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce\nequilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific\ndirections. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic\nunstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their\nisotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic\ncase we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined\nby a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array.", "text": "CM2 TriaMesh Iso and CM2 QuadMesh Iso are isotropic unstructured meshers, that is, they tend to produce\nequilateral triangles and squares. It is sometimes useful however to have elements stretched in some specific\ndirections. To deal with complex domains we still need an unstructured mesher. Here come the anisotropic\nunstructured meshers CM2 TriaMesh Aniso and CM2 QuadMesh Aniso. They are almost identical to their\nisotropic counterparts except for the data . metrics array that is now a matrix (DoubleMat). In the isotropic\ncase we needed only a scalar at each node to define the target mesh size. Now the target mesh size is defined\nby a 2 X 2 symmetric matrix at each node, stored column-wise in the metrics array."}, "coordinates": [{"x": 0.0769, "y": 0.0995}, {"x": 0.909, "y": 0.0995}, {"x": 0.909, "y": 0.2007}, {"x": 0.0769, "y": 0.2007}], "id": 451, "page": 38}, {"category": "figure", "content": {"html": "<figure id='452'><img style='font-size:14px' alt=\"h1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right).\" data-coord=\"top-left:(309,402); bottom-right:(911,841)\" /></figure>", "markdown": "![image](/image/placeholder)\nh1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right).", "text": "![image](/image/placeholder)\nh1\nh\nP ho\nP\nFigure 22 - A single scalar defines an isotropic metric (left).\nA 2D-anisotropic metric needs two vectors (right)."}, "coordinates": [{"x": 0.2494, "y": 0.2297}, {"x": 0.7345, "y": 0.2297}, {"x": 0.7345, "y": 0.4799}, {"x": 0.2494, "y": 0.4799}], "id": 452, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='453' data-category='paragraph' style='font-size:20px'>Mj = ab b<br>c</p>", "markdown": "Mj = ab b\nc", "text": "Mj = ab b\nc"}, "coordinates": [{"x": 0.1235, "y": 0.5468}, {"x": 0.2382, "y": 0.5468}, {"x": 0.2382, "y": 0.5847}, {"x": 0.1235, "y": 0.5847}], "id": 453, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='454' data-category='paragraph' style='font-size:16px'>with :</p>", "markdown": "with :", "text": "with :"}, "coordinates": [{"x": 0.1259, "y": 0.5876}, {"x": 0.1744, "y": 0.5876}, {"x": 0.1744, "y": 0.6026}, {"x": 0.1259, "y": 0.6026}], "id": 454, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='455' data-category='paragraph' style='font-size:16px'>a > 0<br>ac - b2 > 0<br>i.e. the two eigen values are > 0</p>", "markdown": "a > 0\nac - b2 > 0\ni.e. the two eigen values are > 0", "text": "a > 0\nac - b2 > 0\ni.e. the two eigen values are > 0"}, "coordinates": [{"x": 0.1417, "y": 0.6091}, {"x": 0.4066, "y": 0.6091}, {"x": 0.4066, "y": 0.6666}, {"x": 0.1417, "y": 0.6666}], "id": 455, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='456' data-category='paragraph' style='font-size:18px'>data.metrics</p>", "markdown": "data.metrics", "text": "data.metrics"}, "coordinates": [{"x": 0.5068, "y": 0.5749}, {"x": 0.6127, "y": 0.5749}, {"x": 0.6127, "y": 0.5913}, {"x": 0.5068, "y": 0.5913}], "id": 456, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='457' data-category='paragraph' style='font-size:14px'>a</p>", "markdown": "a", "text": "a"}, "coordinates": [{"x": 0.7026, "y": 0.5652}, {"x": 0.716, "y": 0.5652}, {"x": 0.716, "y": 0.5746}, {"x": 0.7026, "y": 0.5746}], "id": 457, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='458' data-category='paragraph' style='font-size:14px'>·</p>", "markdown": "·", "text": "·"}, "coordinates": [{"x": 0.6819, "y": 0.5709}, {"x": 0.6853, "y": 0.5709}, {"x": 0.6853, "y": 0.5737}, {"x": 0.6819, "y": 0.5737}], "id": 458, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='459' data-category='paragraph' style='font-size:18px'>b</p>", "markdown": "b", "text": "b"}, "coordinates": [{"x": 0.7027, "y": 0.5762}, {"x": 0.7152, "y": 0.5762}, {"x": 0.7152, "y": 0.5887}, {"x": 0.7027, "y": 0.5887}], "id": 459, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='460' data-category='paragraph' style='font-size:22px'>:</p>", "markdown": ":", "text": ":"}, "coordinates": [{"x": 0.6363, "y": 0.5703}, {"x": 0.643, "y": 0.5703}, {"x": 0.643, "y": 0.5985}, {"x": 0.6363, "y": 0.5985}], "id": 460, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='461' data-category='paragraph' style='font-size:14px'>c</p>", "markdown": "c", "text": "c"}, "coordinates": [{"x": 0.7032, "y": 0.5938}, {"x": 0.7152, "y": 0.5938}, {"x": 0.7152, "y": 0.6031}, {"x": 0.7032, "y": 0.6031}], "id": 461, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='462' data-category='paragraph' style='font-size:20px'>column #j</p>", "markdown": "column #j", "text": "column #j"}, "coordinates": [{"x": 0.563, "y": 0.6305}, {"x": 0.6405, "y": 0.6305}, {"x": 0.6405, "y": 0.6449}, {"x": 0.563, "y": 0.6449}], "id": 462, "page": 38}, {"category": "caption", "content": {"html": "<caption id='463' style='font-size:14px'>Figure 23 - Definition and storage of the 2-D anisotropic metrics.</caption>", "markdown": "Figure 23 - Definition and storage of the 2-D anisotropic metrics.", "text": "Figure 23 - Definition and storage of the 2-D anisotropic metrics."}, "coordinates": [{"x": 0.2968, "y": 0.6979}, {"x": 0.7004, "y": 0.6979}, {"x": 0.7004, "y": 0.7129}, {"x": 0.2968, "y": 0.7129}], "id": 463, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='464' data-category='paragraph' style='font-size:18px'>Let (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:</p>", "markdown": "Let (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:", "text": "Let (V⌀, V1) be the two ortho-normal vectors along the axes of the ellipse:"}, "coordinates": [{"x": 0.0753, "y": 0.7473}, {"x": 0.6228, "y": 0.7473}, {"x": 0.6228, "y": 0.7653}, {"x": 0.0753, "y": 0.7653}], "id": 464, "page": 38}, {"category": "paragraph", "content": {"html": "<br><p id='465' data-category='paragraph' style='font-size:22px'>[vo] = [v1] = 1<br><V0,V1>=0</p>", "markdown": "[vo] = [v1] = 1\n<V0,V1>=0", "text": "[vo] = [v1] = 1\n<V0,V1>=0"}, "coordinates": [{"x": 0.1203, "y": 0.7754}, {"x": 0.2465, "y": 0.7754}, {"x": 0.2465, "y": 0.8293}, {"x": 0.1203, "y": 0.8293}], "id": 465, "page": 38}, {"category": "table", "content": {"html": "<table id='466' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 38 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0052, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0052, "y": 1}], "id": 466, "page": 38}, {"category": "paragraph", "content": {"html": "<p id='467' data-category='paragraph' style='font-size:20px'>Then the metrics Mj writes:</p>", "markdown": "Then the metrics Mj writes:", "text": "Then the metrics Mj writes:"}, "coordinates": [{"x": 0.0763, "y": 0.0647}, {"x": 0.287, "y": 0.0647}, {"x": 0.287, "y": 0.0805}, {"x": 0.0763, "y": 0.0805}], "id": 467, "page": 39}, {"category": "equation", "content": {"html": "<p id='468' data-category='equation'>$$\\begin{array}{c c}{{M_{j}=\\mathbf{B}}}&{{\\displaystyle\\left[\\frac{1}{h_{0}^{~2}}\\right.\\quad\\qquad}}&{{\\displaystyle\\left|\\begin{array}{c}{{}}\\\\ {{}}\\\\ {{}}&{{}}\\\\ {{\\displaystyle\\qquad\\displaystyle\\frac{1}{h_{1}^{~2}}\\end{array}\\right|}}}\\end{array}\\right.\\qquad}}\\end{array}$$</p>", "markdown": "$$\\begin{array}{c c}{{M_{j}=\\mathbf{B}}}&{{\\displaystyle\\left[\\frac{1}{h_{0}^{~2}}\\right.\\quad\\qquad}}&{{\\displaystyle\\left|\\begin{array}{c}{{}}\\\\ {{}}\\\\ {{}}&{{}}\\\\ {{\\displaystyle\\qquad\\displaystyle\\frac{1}{h_{1}^{~2}}\\end{array}\\right|}}}\\end{array}\\right.\\qquad}}\\end{array}$$", "text": "1\n 0\n 2\n ho T\n M = B\n B\n j 1\n 0\n 2\n h"}, "coordinates": [{"x": 0.1196, "y": 0.0884}, {"x": 0.3377, "y": 0.0884}, {"x": 0.3377, "y": 0.1727}, {"x": 0.1196, "y": 0.1727}], "id": 468, "page": 39}, {"category": "paragraph", "content": {"html": "<br><p id='469' data-category='paragraph' style='font-size:18px'>with :</p>", "markdown": "with :", "text": "with :"}, "coordinates": [{"x": 0.1248, "y": 0.1748}, {"x": 0.1756, "y": 0.1748}, {"x": 0.1756, "y": 0.1895}, {"x": 0.1248, "y": 0.1895}], "id": 469, "page": 39}, {"category": "paragraph", "content": {"html": "<br><p id='470' data-category='paragraph' style='font-size:22px'>B = [vo v1]<br>stored column - wise</p>", "markdown": "B = [vo v1]\nstored column - wise", "text": "B = [vo v1]\nstored column - wise"}, "coordinates": [{"x": 0.1393, "y": 0.1912}, {"x": 0.3285, "y": 0.1912}, {"x": 0.3285, "y": 0.233}, {"x": 0.1393, "y": 0.233}], "id": 470, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='471' data-category='paragraph' style='font-size:18px'>The metric equivalent to an isotropic size of h writes:</p>", "markdown": "The metric equivalent to an isotropic size of h writes:", "text": "The metric equivalent to an isotropic size of h writes:"}, "coordinates": [{"x": 0.076, "y": 0.2541}, {"x": 0.479, "y": 0.2541}, {"x": 0.479, "y": 0.2708}, {"x": 0.076, "y": 0.2708}], "id": 471, "page": 39}, {"category": "equation", "content": {"html": "<p id='472' data-category='equation'>$$M_{_{j}}=\\left[\\frac{1}{h^{2}}\\quad\\begin{array}{c c c}{{0}}\\\\ {{}}&{{}}\\\\ {{0}}&{{\\frac{1}{h^{2}}\\right]$$</p>", "markdown": "$$M_{_{j}}=\\left[\\frac{1}{h^{2}}\\quad\\begin{array}{c c c}{{0}}\\\\ {{}}&{{}}\\\\ {{0}}&{{\\frac{1}{h^{2}}\\right]$$", "text": "1\n 0\n h2\n M =\n i 1\n 0\n h2"}, "coordinates": [{"x": 0.1173, "y": 0.2782}, {"x": 0.279, "y": 0.2782}, {"x": 0.279, "y": 0.3602}, {"x": 0.1173, "y": 0.3602}], "id": 472, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='473' data-category='paragraph' style='font-size:20px'>A null matrix would lead to infinite sizes in both directions (infinite circle).</p>", "markdown": "A null matrix would lead to infinite sizes in both directions (infinite circle).", "text": "A null matrix would lead to infinite sizes in both directions (infinite circle)."}, "coordinates": [{"x": 0.0767, "y": 0.3792}, {"x": 0.6272, "y": 0.3792}, {"x": 0.6272, "y": 0.3965}, {"x": 0.0767, "y": 0.3965}], "id": 473, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='474' data-category='paragraph' style='font-size:20px'>When the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic<br>default metrics we have seen before. For each hard node the default metric is based on the length of the<br>adjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for<br>instance examples 1, 2, 3 or 4 and replace:</p>", "markdown": "When the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic\ndefault metrics we have seen before. For each hard node the default metric is based on the length of the\nadjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for\ninstance examples 1, 2, 3 or 4 and replace:", "text": "When the user doesn't specify a metric, the mesher uses the default one which is equivalent to the isotropic\ndefault metrics we have seen before. For each hard node the default metric is based on the length of the\nadjacent edges. This leads to the same default behavior as their related isotropic counterparts. Take for\ninstance examples 1, 2, 3 or 4 and replace:"}, "coordinates": [{"x": 0.0758, "y": 0.4061}, {"x": 0.8976, "y": 0.4061}, {"x": 0.8976, "y": 0.4652}, {"x": 0.0758, "y": 0.4652}], "id": 474, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='475' data-category='paragraph' style='font-size:14px'>triamesh_ iso : : mesher the_mesher;</p>", "markdown": "triamesh_ iso : : mesher the_mesher;", "text": "triamesh_ iso : : mesher the_mesher;"}, "coordinates": [{"x": 0.1044, "y": 0.5018}, {"x": 0.4176, "y": 0.5018}, {"x": 0.4176, "y": 0.5173}, {"x": 0.1044, "y": 0.5173}], "id": 475, "page": 39}, {"category": "heading1", "content": {"html": "<h1 id='476' style='font-size:20px'>with:</h1>", "markdown": "# with:", "text": "with:"}, "coordinates": [{"x": 0.0774, "y": 0.558}, {"x": 0.1187, "y": 0.558}, {"x": 0.1187, "y": 0.5725}, {"x": 0.0774, "y": 0.5725}], "id": 476, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='477' data-category='paragraph' style='font-size:14px'>triamesh_aniso : : mesher the_mesher;</p>", "markdown": "triamesh_aniso : : mesher the_mesher;", "text": "triamesh_aniso : : mesher the_mesher;"}, "coordinates": [{"x": 0.1061, "y": 0.6116}, {"x": 0.4159, "y": 0.6116}, {"x": 0.4159, "y": 0.6245}, {"x": 0.1061, "y": 0.6245}], "id": 477, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='478' data-category='paragraph' style='font-size:20px'>and you get the same meshes25.</p>", "markdown": "and you get the same meshes25.", "text": "and you get the same meshes25."}, "coordinates": [{"x": 0.0763, "y": 0.6666}, {"x": 0.3244, "y": 0.6666}, {"x": 0.3244, "y": 0.683}, {"x": 0.0763, "y": 0.683}], "id": 478, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='479' data-category='paragraph' style='font-size:14px'>25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower).</p>", "markdown": "25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower).", "text": "25 The anisotropic meshers are however much slower than their isotropic counterparts (about 4 times slower)."}, "coordinates": [{"x": 0.0631, "y": 0.8988}, {"x": 0.7297, "y": 0.8988}, {"x": 0.7297, "y": 0.9131}, {"x": 0.0631, "y": 0.9131}], "id": 479, "page": 39}, {"category": "table", "content": {"html": "<table id='480' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>39 tutorials</td></tr></tbody></table>", "markdown": "| CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 39 tutorials |\n| --- | --- |\n", "text": "| CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - Ⓒ Computing Objects /version 5.6 rev. February 2025 | 39 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0082, "y": 0.948}, {"x": 1, "y": 0.948}, {"x": 1, "y": 1}, {"x": 0.0082, "y": 1}], "id": 480, "page": 39}, {"category": "paragraph", "content": {"html": "<p id='481' data-category='paragraph' style='font-size:20px'>To benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.<br>positive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these<br>matrices as in the following example.</p>", "markdown": "To benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.\npositive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these\nmatrices as in the following example.", "text": "To benefit from the anisotropic feature the user must fill the metrics array with valid anisotropic matrices (i.e.\npositive-definite matrices). Some functions in meshtools and meshtools1d can help in computing these\nmatrices as in the following example."}, "coordinates": [{"x": 0.0764, "y": 0.0636}, {"x": 0.9157, "y": 0.0636}, {"x": 0.9157, "y": 0.1099}, {"x": 0.0764, "y": 0.1099}], "id": 481, "page": 40}, {"category": "figure", "content": {"html": "<figure id='482'><img alt=\"\" data-coord=\"top-left:(113,225); bottom-right:(595,698)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0911, "y": 0.1288}, {"x": 0.4795, "y": 0.1288}, {"x": 0.4795, "y": 0.3985}, {"x": 0.0911, "y": 0.3985}], "id": 482, "page": 40}, {"category": "caption", "content": {"html": "<caption id='483' style='font-size:16px'>Figure 24 - Anisotropic meshes (T3 and Q4).</caption>", "markdown": "Figure 24 - Anisotropic meshes (T3 and Q4).", "text": "Figure 24 - Anisotropic meshes (T3 and Q4)."}, "coordinates": [{"x": 0.3627, "y": 0.4086}, {"x": 0.6355, "y": 0.4086}, {"x": 0.6355, "y": 0.4227}, {"x": 0.3627, "y": 0.4227}], "id": 483, "page": 40}, {"category": "paragraph", "content": {"html": "<p id='484' data-category='paragraph' style='font-size:20px'>Here a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the<br>previous section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We<br>need also specify that we want a different size along the normals than along the tangents of the boundary lines<br>(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :<br>: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and<br>generates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node<br>Ni, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the<br>horizontal direction27:</p>", "markdown": "Here a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the\nprevious section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We\nneed also specify that we want a different size along the normals than along the tangents of the boundary lines\n(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :\n: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and\ngenerates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node\nNi, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the\nhorizontal direction27:", "text": "Here a square is meshed non-uniformly with the variant of mesh_strai ght we have already seen in the\nprevious section26. This is not sufficient to get a 2-D anisotropic mesh. We need an anisotropic mesher. We\nneed also specify that we want a different size along the normals than along the tangents of the boundary lines\n(along the tangents the default sizes, i.e. mean of the edges' lengths, suit us). This is the role of cm2 :\n: meshtools1d: :metrics_gen_aniso2d. This function takes a 1D mesh and a size along the normal and\ngenerates a set of 2-D anisotropic metrics stored in an array metrics as depicted in Figure 23. At each node\nNi, a metric M(Ni, hn) is computed. For instance, along the right vertical line we specify a constant size hn in the\nhorizontal direction27:"}, "coordinates": [{"x": 0.0772, "y": 0.458}, {"x": 0.9189, "y": 0.458}, {"x": 0.9189, "y": 0.5742}, {"x": 0.0772, "y": 0.5742}], "id": 484, "page": 40}, {"category": "paragraph", "content": {"html": "<p id='485' data-category='paragraph' style='font-size:16px'>meshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;</p>", "markdown": "meshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;", "text": "meshtools1d : : metrics_gen_aniso2d (pos, connect2, hn, metrics) ;"}, "coordinates": [{"x": 0.106, "y": 0.6113}, {"x": 0.6032, "y": 0.6113}, {"x": 0.6032, "y": 0.6254}, {"x": 0.106, "y": 0.6254}], "id": 485, "page": 40}, {"category": "paragraph", "content": {"html": "<p id='486' data-category='paragraph' style='font-size:14px'>26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4.</p>", "markdown": "26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4.", "text": "26 We could obviously get about the same structured Q4 mesh with cm2 : : meshtools2d : : mesh_struct_Q4."}, "coordinates": [{"x": 0.0651, "y": 0.824}, {"x": 0.7367, "y": 0.824}, {"x": 0.7367, "y": 0.8369}, {"x": 0.0651, "y": 0.8369}], "id": 486, "page": 40}, {"category": "footnote", "content": {"html": "<br><p id='487' data-category='footnote' style='font-size:16px'>27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in<br>metrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi<br>is replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.<br>Note also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.<br>This property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four<br>summits of the square.</p>", "markdown": "27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in\nmetrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi\nis replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.\nNote also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.\nThis property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four\nsummits of the square.", "text": "27 Note that the metrics parameter is not a pure output parameter. Indeed this function does not simply overwrite the existing columns in\nmetrics but replace them with their intersection with the newly computed metric M(Ni, hn). If Mi in column #i already exists in metrics, Mi\nis replaced by intersection (Mi, M(Ni, hn)). Intersection (Mi, Mj) is the ellipse inscribed inside the two associated ellipses.\nNote also that a null metric is equivalent to an infinite circle, and that intersection (Mi, 0) = Mi.\nThis property of the metrics_gen_aniso2d function is essential to make coherent the intersections of the generated metrics at the four\nsummits of the square."}, "coordinates": [{"x": 0.0616, "y": 0.8409}, {"x": 0.9183, "y": 0.8409}, {"x": 0.9183, "y": 0.912}, {"x": 0.0616, "y": 0.912}], "id": 487, "page": 40}, {"category": "table", "content": {"html": "<table id='488' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40 |\n| --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 CM2 TriaMeshⓇ & CM2 QuadMeshⓇ - Tutorials 40 |\n| --- |\n"}, "coordinates": [{"x": 0.0115, "y": 0.9485}, {"x": 0.9997, "y": 0.9485}, {"x": 0.9997, "y": 1}, {"x": 0.0115, "y": 1}], "id": 488, "page": 40}, {"category": "heading1", "content": {"html": "<h1 id='489' style='font-size:16px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1055, "y": 0.0855}, {"x": 0.2642, "y": 0.0855}, {"x": 0.2642, "y": 0.0974}, {"x": 0.1055, "y": 0.0974}], "id": 489, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='490' data-category='paragraph' style='font-size:18px'>int main()</p>", "markdown": "int main()", "text": "int main()"}, "coordinates": [{"x": 0.1087, "y": 0.1047}, {"x": 0.19, "y": 0.1047}, {"x": 0.19, "y": 0.1162}, {"x": 0.1087, "y": 0.1162}], "id": 490, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='491' data-category='paragraph' style='font-size:14px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1158}, {"x": 0.1187, "y": 0.1158}, {"x": 0.1187, "y": 0.1251}, {"x": 0.1094, "y": 0.1251}], "id": 491, "page": 41}, {"category": "table", "content": {"html": "<br><table id='492' style='font-size:16px'><thead></thead><tbody><tr><td>const double</td><td>L(10.) ;</td></tr><tr><td>const double</td><td>hx(1.) ;</td></tr><tr><td>const double</td><td>Y size at bottom line. h0y(hx) ; </td></tr><tr><td>const double</td><td>Y size at top line. h1y(hx / 20.) ;</td></tr><tr><td>const DoubleVec2</td><td>P0(0 . 0.) ; ,</td></tr><tr><td>const DoubleVec2</td><td>P1(L, 0.) ;</td></tr><tr><td>const DoubleVec2</td><td>P2(L, L);</td></tr><tr><td>const DoubleVec2</td><td>P3(0 · , L) ;</td></tr><tr><td>DoubleMat</td><td>pos;</td></tr><tr><td>UIntVec</td><td>indices;</td></tr><tr><td>UIntMat</td><td>connect1, connect2, connect3, connect4, connectE;</td></tr><tr><td>UIntMat</td><td>connectM;</td></tr><tr><td>DoubleMat</td><td>metrics;</td></tr></tbody></table>", "markdown": "| const double | L(10.) ; |\n| --- | --- |\n| const double | hx(1.) ; |\n| const double | Y size at bottom line. h0y(hx) ;  |\n| const double | Y size at top line. h1y(hx / 20.) ; |\n| const DoubleVec2 | P0(0 . 0.) ; , |\n| const DoubleVec2 | P1(L, 0.) ; |\n| const DoubleVec2 | P2(L, L); |\n| const DoubleVec2 | P3(0 · , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connect1, connect2, connect3, connect4, connectE; |\n| UIntMat | connectM; |\n| DoubleMat | metrics; |\n", "text": "| const double | L(10.) ; |\n| --- | --- |\n| const double | hx(1.) ; |\n| const double | Y size at bottom line. h0y(hx) ;  |\n| const double | Y size at top line. h1y(hx / 20.) ; |\n| const DoubleVec2 | P0(0 . 0.) ; , |\n| const DoubleVec2 | P1(L, 0.) ; |\n| const DoubleVec2 | P2(L, L); |\n| const DoubleVec2 | P3(0 · , L) ; |\n| DoubleMat | pos; |\n| UIntVec | indices; |\n| UIntMat | connect1, connect2, connect3, connect4, connectE; |\n| UIntMat | connectM; |\n| DoubleMat | metrics; |\n"}, "coordinates": [{"x": 0.1164, "y": 0.123}, {"x": 0.7171, "y": 0.123}, {"x": 0.7171, "y": 0.2522}, {"x": 0.1164, "y": 0.2522}], "id": 492, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='493' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLL.<br>triamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLL.\ntriamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLL.\ntriamesh_aniso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1305, "y": 0.2566}, {"x": 0.7074, "y": 0.2566}, {"x": 0.7074, "y": 0.279}, {"x": 0.1305, "y": 0.279}], "id": 493, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='494' data-category='paragraph' style='font-size:14px'>11 VERTICES<br>pos . push_back (PO) ;<br>pos · push_back(P1) ;<br>pos · push_back(P2) ;<br>pos . push_back(P3) ;</p>", "markdown": "11 VERTICES\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back(P2) ;\npos . push_back(P3) ;", "text": "11 VERTICES\npos . push_back (PO) ;\npos · push_back(P1) ;\npos · push_back(P2) ;\npos . push_back(P3) ;"}, "coordinates": [{"x": 0.1326, "y": 0.2867}, {"x": 0.2753, "y": 0.2867}, {"x": 0.2753, "y": 0.3353}, {"x": 0.1326, "y": 0.3353}], "id": 494, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='495' data-category='paragraph' style='font-size:16px'>11 BOTTOM LINE<br>indices. clear () ;<br>meshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect1) ;<br>connectE.push_back (connect1) ;</p>", "markdown": "11 BOTTOM LINE\nindices. clear () ;\nmeshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect1) ;\nconnectE.push_back (connect1) ;", "text": "11 BOTTOM LINE\nindices. clear () ;\nmeshtools1d : : mesh_straight (pos, 日, 1, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect1) ;\nconnectE.push_back (connect1) ;"}, "coordinates": [{"x": 0.1316, "y": 0.3428}, {"x": 0.6257, "y": 0.3428}, {"x": 0.6257, "y": 0.3918}, {"x": 0.1316, "y": 0.3918}], "id": 495, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='496' data-category='paragraph' style='font-size:18px'>11 RIGHT-SIDE LINE</p>", "markdown": "11 RIGHT-SIDE LINE", "text": "11 RIGHT-SIDE LINE"}, "coordinates": [{"x": 0.1328, "y": 0.3995}, {"x": 0.282, "y": 0.3995}, {"x": 0.282, "y": 0.4106}, {"x": 0.1328, "y": 0.4106}], "id": 496, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='497' data-category='paragraph' style='font-size:16px'>indices.clear() ;<br>meshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect2) ;<br>connectE.push_back (connect2) ;</p>", "markdown": "indices.clear() ;\nmeshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect2) ;\nconnectE.push_back (connect2) ;", "text": "indices.clear() ;\nmeshtools1d: : mesh_straight (pos, 1, 2, h0y, h1y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect2) ;\nconnectE.push_back (connect2) ;"}, "coordinates": [{"x": 0.133, "y": 0.4048}, {"x": 0.6416, "y": 0.4048}, {"x": 0.6416, "y": 0.4482}, {"x": 0.133, "y": 0.4482}], "id": 497, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='498' data-category='paragraph' style='font-size:16px'>11 LEFT-SIDE LINE</p>", "markdown": "11 LEFT-SIDE LINE", "text": "11 LEFT-SIDE LINE"}, "coordinates": [{"x": 0.133, "y": 0.4569}, {"x": 0.2728, "y": 0.4569}, {"x": 0.2728, "y": 0.4682}, {"x": 0.133, "y": 0.4682}], "id": 498, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='499' data-category='paragraph' style='font-size:16px'>indices.clear() ;<br>meshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect3) ;<br>connectE.push_back (connect3) ;</p>", "markdown": "indices.clear() ;\nmeshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect3) ;\nconnectE.push_back (connect3) ;", "text": "indices.clear() ;\nmeshtools1d: : mesh_straight (pos, 2, 3, hx, hx, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect3) ;\nconnectE.push_back (connect3) ;"}, "coordinates": [{"x": 0.1331, "y": 0.4696}, {"x": 0.6258, "y": 0.4696}, {"x": 0.6258, "y": 0.5058}, {"x": 0.1331, "y": 0.5058}], "id": 499, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='500' data-category='paragraph' style='font-size:16px'>11 TOP LINE<br>indices.clear() ··<br>meshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;<br>meshtools1d: : indices_ to_connectE2 (indices, connect4) ;<br>connectE.push_back(connect4) ;</p>", "markdown": "11 TOP LINE\nindices.clear() ··\nmeshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect4) ;\nconnectE.push_back(connect4) ;", "text": "11 TOP LINE\nindices.clear() ··\nmeshtools1d: :mesh_straight (pos, 3, 日, h1y, h0y, true, indices) ;\nmeshtools1d: : indices_ to_connectE2 (indices, connect4) ;\nconnectE.push_back(connect4) ;"}, "coordinates": [{"x": 0.1324, "y": 0.5164}, {"x": 0.6419, "y": 0.5164}, {"x": 0.6419, "y": 0.5628}, {"x": 0.1324, "y": 0.5628}], "id": 500, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='501' data-category='paragraph' style='font-size:16px'>11 METRICS</p>", "markdown": "11 METRICS", "text": "11 METRICS"}, "coordinates": [{"x": 0.1332, "y": 0.5709}, {"x": 0.2164, "y": 0.5709}, {"x": 0.2164, "y": 0.5814}, {"x": 0.1332, "y": 0.5814}], "id": 501, "page": 41}, {"category": "table", "content": {"html": "<br><table id='502' style='font-size:18px'><thead></thead><tbody><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ;</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ;</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics);</td></tr><tr><td>meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ;</td></tr></tbody></table>", "markdown": "| meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ; |\n| --- |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ; |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics); |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ; |\n", "text": "| meshtools1d: :metrics_gen_aniso2d(pos, connect1, /*hn=>*/ h0y, metrics) ; |\n| --- |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect2, /*hn=>*/ hx , metrics) ; |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect3, /*hn=>*/ h1y, metrics); |\n| meshtools1d: :metrics_gen_aniso2d(pos, connect4, /*hn=>*/ hx , metrics) ; |\n"}, "coordinates": [{"x": 0.1294, "y": 0.58}, {"x": 0.7078, "y": 0.58}, {"x": 0.7078, "y": 0.6208}, {"x": 0.1294, "y": 0.6208}], "id": 502, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='503' data-category='paragraph' style='font-size:16px'>11 2D MESH</p>", "markdown": "11 2D MESH", "text": "11 2D MESH"}, "coordinates": [{"x": 0.1342, "y": 0.6281}, {"x": 0.2172, "y": 0.6281}, {"x": 0.2172, "y": 0.6381}, {"x": 0.1342, "y": 0.6381}], "id": 503, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='504' data-category='paragraph' style='font-size:14px'>triamesh_aniso : : mesher the_mesher;<br>triamesh_aniso: : mesher: :data_type data (pos, connectE2) ;<br>data. metrics = metrics;<br>the_mesher · run(data) ;</p>", "markdown": "triamesh_aniso : : mesher the_mesher;\ntriamesh_aniso: : mesher: :data_type data (pos, connectE2) ;\ndata. metrics = metrics;\nthe_mesher · run(data) ;", "text": "triamesh_aniso : : mesher the_mesher;\ntriamesh_aniso: : mesher: :data_type data (pos, connectE2) ;\ndata. metrics = metrics;\nthe_mesher · run(data) ;"}, "coordinates": [{"x": 0.1315, "y": 0.6327}, {"x": 0.6026, "y": 0.6327}, {"x": 0.6026, "y": 0.6766}, {"x": 0.1315, "y": 0.6766}], "id": 504, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='505' data-category='paragraph' style='font-size:16px'>11 VISUALIZATION.<br>meshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;</p>", "markdown": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;", "text": "11 VISUALIZATION.\nmeshtools : : medit_output(\"out.mesh\", data.pos, data. connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1293, "y": 0.6836}, {"x": 0.7241, "y": 0.6836}, {"x": 0.7241, "y": 0.7069}, {"x": 0.1293, "y": 0.7069}], "id": 505, "page": 41}, {"category": "paragraph", "content": {"html": "<br><p id='506' data-category='paragraph' style='font-size:16px'>return 0;<br>} 11 main</p>", "markdown": "return 0;\n} 11 main", "text": "return 0;\n} 11 main"}, "coordinates": [{"x": 0.1054, "y": 0.7143}, {"x": 0.2076, "y": 0.7143}, {"x": 0.2076, "y": 0.7347}, {"x": 0.1054, "y": 0.7347}], "id": 506, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='507' data-category='paragraph' style='font-size:22px'>As already stated, except for the metrics array, the anisotropic meshers have the very same options and<br>parameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,<br>shared boundaries, background meshes...</p>", "markdown": "As already stated, except for the metrics array, the anisotropic meshers have the very same options and\nparameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,\nshared boundaries, background meshes...", "text": "As already stated, except for the metrics array, the anisotropic meshers have the very same options and\nparameters as their isotropic counterparts. They accept internal hard lines, isolated nodes, multiple domains,\nshared boundaries, background meshes..."}, "coordinates": [{"x": 0.0766, "y": 0.7896}, {"x": 0.9023, "y": 0.7896}, {"x": 0.9023, "y": 0.8342}, {"x": 0.0766, "y": 0.8342}], "id": 507, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='508' data-category='paragraph' style='font-size:20px'>The following example illustrates the internal hard line feature.<br>We have specified a normal size along the inner circle much smaller than the default tangent size (using again<br>meshtools1d : : metrics_gen_aniso2d).</p>", "markdown": "The following example illustrates the internal hard line feature.\nWe have specified a normal size along the inner circle much smaller than the default tangent size (using again\nmeshtools1d : : metrics_gen_aniso2d).", "text": "The following example illustrates the internal hard line feature.\nWe have specified a normal size along the inner circle much smaller than the default tangent size (using again\nmeshtools1d : : metrics_gen_aniso2d)."}, "coordinates": [{"x": 0.0757, "y": 0.8441}, {"x": 0.9069, "y": 0.8441}, {"x": 0.9069, "y": 0.8896}, {"x": 0.0757, "y": 0.8896}], "id": 508, "page": 41}, {"category": "table", "content": {"html": "<table id='509' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials |\n| --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 41 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0091, "y": 0.9477}, {"x": 1, "y": 0.9477}, {"x": 1, "y": 1}, {"x": 0.0091, "y": 1}], "id": 509, "page": 41}, {"category": "paragraph", "content": {"html": "<p id='510' data-category='paragraph' style='font-size:20px'>For the external square, nothing was specified in the metrics array and the mesher used its default isotropic<br>metrics based on the length of the adjacent edges.</p>", "markdown": "For the external square, nothing was specified in the metrics array and the mesher used its default isotropic\nmetrics based on the length of the adjacent edges.", "text": "For the external square, nothing was specified in the metrics array and the mesher used its default isotropic\nmetrics based on the length of the adjacent edges."}, "coordinates": [{"x": 0.0757, "y": 0.0638}, {"x": 0.8981, "y": 0.0638}, {"x": 0.8981, "y": 0.096}, {"x": 0.0757, "y": 0.096}], "id": 510, "page": 42}, {"category": "figure", "content": {"html": "<figure id='511'><img alt=\"\" data-coord=\"top-left:(115,199); bottom-right:(594,673)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0932, "y": 0.1137}, {"x": 0.479, "y": 0.1137}, {"x": 0.479, "y": 0.384}, {"x": 0.0932, "y": 0.384}], "id": 511, "page": 42}, {"category": "figure", "content": {"html": "<br><figure id='512'><img alt=\"\" data-coord=\"top-left:(648,198); bottom-right:(1122,673)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5226, "y": 0.1134}, {"x": 0.9043, "y": 0.1134}, {"x": 0.9043, "y": 0.3842}, {"x": 0.5226, "y": 0.3842}], "id": 512, "page": 42}, {"category": "caption", "content": {"html": "<caption id='513' style='font-size:14px'>Figure 25 - 2-D anisotropic meshes (T3 and all-Q4).</caption>", "markdown": "Figure 25 - 2-D anisotropic meshes (T3 and all-Q4).", "text": "Figure 25 - 2-D anisotropic meshes (T3 and all-Q4)."}, "coordinates": [{"x": 0.342, "y": 0.3945}, {"x": 0.6563, "y": 0.3945}, {"x": 0.6563, "y": 0.4083}, {"x": 0.342, "y": 0.4083}], "id": 513, "page": 42}, {"category": "paragraph", "content": {"html": "<p id='514' data-category='paragraph' style='font-size:16px'>The example below is mesh of Figure 21 revisited the anisotropic way.<br>Here we specify a small size in the directions normal to the three lines but a uniform size along the tangents.<br>The normal sizes follow the same kind of Gaussian variation.<br>All these metrics are specified at the nodes of the same uniform background mesh.</p>", "markdown": "The example below is mesh of Figure 21 revisited the anisotropic way.\nHere we specify a small size in the directions normal to the three lines but a uniform size along the tangents.\nThe normal sizes follow the same kind of Gaussian variation.\nAll these metrics are specified at the nodes of the same uniform background mesh.", "text": "The example below is mesh of Figure 21 revisited the anisotropic way.\nHere we specify a small size in the directions normal to the three lines but a uniform size along the tangents.\nThe normal sizes follow the same kind of Gaussian variation.\nAll these metrics are specified at the nodes of the same uniform background mesh."}, "coordinates": [{"x": 0.0766, "y": 0.4437}, {"x": 0.8965, "y": 0.4437}, {"x": 0.8965, "y": 0.5037}, {"x": 0.0766, "y": 0.5037}], "id": 514, "page": 42}, {"category": "figure", "content": {"html": "<figure id='515'><img alt=\"\" data-coord=\"top-left:(115,914); bottom-right:(596,1390)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0927, "y": 0.5213}, {"x": 0.4803, "y": 0.5213}, {"x": 0.4803, "y": 0.7925}, {"x": 0.0927, "y": 0.7925}], "id": 515, "page": 42}, {"category": "figure", "content": {"html": "<br><figure id='516'><img alt=\"\" data-coord=\"top-left:(643,907); bottom-right:(1130,1390)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5188, "y": 0.5172}, {"x": 0.9112, "y": 0.5172}, {"x": 0.9112, "y": 0.7928}, {"x": 0.5188, "y": 0.7928}], "id": 516, "page": 42}, {"category": "caption", "content": {"html": "<caption id='517' style='font-size:14px'>Figure 26 - 2-D anisotropic meshes (T3 and all-Q4).</caption>", "markdown": "Figure 26 - 2-D anisotropic meshes (T3 and all-Q4).", "text": "Figure 26 - 2-D anisotropic meshes (T3 and all-Q4)."}, "coordinates": [{"x": 0.3419, "y": 0.8024}, {"x": 0.6556, "y": 0.8024}, {"x": 0.6556, "y": 0.8164}, {"x": 0.3419, "y": 0.8164}], "id": 517, "page": 42}, {"category": "table", "content": {"html": "<table id='518' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 42 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0049, "y": 0.9478}, {"x": 1, "y": 0.9478}, {"x": 1, "y": 1}, {"x": 0.0049, "y": 1}], "id": 518, "page": 42}, {"category": "heading1", "content": {"html": "<h1 id='519' style='font-size:22px'>11. 3-D surface meshes (aniso meshers only)</h1>", "markdown": "# 11. 3-D surface meshes (aniso meshers only)", "text": "11. 3-D surface meshes (aniso meshers only)"}, "coordinates": [{"x": 0.0768, "y": 0.0632}, {"x": 0.6872, "y": 0.0632}, {"x": 0.6872, "y": 0.0889}, {"x": 0.0768, "y": 0.0889}], "id": 519, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='520' data-category='paragraph' style='font-size:20px'>The four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso<br>and CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.<br>To generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a<br>template function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or<br>CM2 QuadMesh Aniso):</p>", "markdown": "The four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso\nand CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.\nTo generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a\ntemplate function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or\nCM2 QuadMesh Aniso):", "text": "The four meshers CM2 TriaMesh Iso, CM2 QuadMesh Iso and their anisotropic versions CM2 TriaMesh Aniso\nand CM2 QuadMesh Aniso are plane 2-D meshers. They generate or optimize meshes in the Z = 0 plane only.\nTo generate meshes on 3-D parametric surfaces, CM2 MeshTools offers a convenient solution by the way of a\ntemplate function that pre- and post-process the data for a 2-D anisotropic mesher (CM2 TriaMesh Aniso or\nCM2 QuadMesh Aniso):"}, "coordinates": [{"x": 0.076, "y": 0.099}, {"x": 0.9038, "y": 0.099}, {"x": 0.9038, "y": 0.1719}, {"x": 0.076, "y": 0.1719}], "id": 520, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='521' data-category='paragraph' style='font-size:14px'>template <class Surface, class AnisoMesher, class AuxMesher><br>int<br>meshtools2d : : mesh_surface_param</p>", "markdown": "template <class Surface, class AnisoMesher, class AuxMesher>\nint\nmeshtools2d : : mesh_surface_param", "text": "template <class Surface, class AnisoMesher, class AuxMesher>\nint\nmeshtools2d : : mesh_surface_param"}, "coordinates": [{"x": 0.1048, "y": 0.2094}, {"x": 0.5952, "y": 0.2094}, {"x": 0.5952, "y": 0.2416}, {"x": 0.1048, "y": 0.2416}], "id": 521, "page": 43}, {"category": "paragraph", "content": {"html": "<br><p id='522' data-category='paragraph' style='font-size:16px'>(const Surface& S, AnisoMesher& mesher2D,</p>", "markdown": "(const Surface& S, AnisoMesher& mesher2D,", "text": "(const Surface& S, AnisoMesher& mesher2D,"}, "coordinates": [{"x": 0.133, "y": 0.238}, {"x": 0.4639, "y": 0.238}, {"x": 0.4639, "y": 0.2502}, {"x": 0.133, "y": 0.2502}], "id": 522, "page": 43}, {"category": "paragraph", "content": {"html": "<br><p id='523' data-category='paragraph' style='font-size:14px'>typename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,<br>double max_ chordal_error, double min_h, unsi gned chordal_control_type,<br>unsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,<br>doub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,<br>unsi gned max_ bgm_remeshings = 4<br>bool recompute_Qs_flag = true, bool compute_area_flag = true) ;</p>", "markdown": "typename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,\ndouble max_ chordal_error, double min_h, unsi gned chordal_control_type,\nunsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,\ndoub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,\nunsi gned max_ bgm_remeshings = 4\nbool recompute_Qs_flag = true, bool compute_area_flag = true) ;", "text": "typename AnisoMesher : : data_ type& data3D, AuxMesher& aux_mesher,\ndouble max_ chordal_error, double min_h, unsi gned chordal_control_type,\nunsi gned high_order_ type = ⊙ , unsigned hi gh_order_mode = 2,\ndoub le max_chordal_error ratio = 0. 10, bool dry_run_flag = false,\nunsi gned max_ bgm_remeshings = 4\nbool recompute_Qs_flag = true, bool compute_area_flag = true) ;"}, "coordinates": [{"x": 0.1239, "y": 0.2458}, {"x": 0.7082, "y": 0.2458}, {"x": 0.7082, "y": 0.3075}, {"x": 0.1239, "y": 0.3075}], "id": 523, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='524' data-category='paragraph' style='font-size:20px'>This function can be used as in the following code sample:</p>", "markdown": "This function can be used as in the following code sample:", "text": "This function can be used as in the following code sample:"}, "coordinates": [{"x": 0.0774, "y": 0.3505}, {"x": 0.5205, "y": 0.3505}, {"x": 0.5205, "y": 0.3677}, {"x": 0.0774, "y": 0.3677}], "id": 524, "page": 43}, {"category": "table", "content": {"html": "<table id='525' style='font-size:14px'><thead></thead><tbody><tr><td><table><thead></thead><tbody><tr><td>tri amesh_aniso: :mesher amesh_iso : :mesher</td><td>the_mesher; aux_mesher;</td></tr><tr><td>tri tri amesh_ani so: :mesher: :data_type surface_type</td><td>data (pos, connectE2) ; S(some parameters) ; 11 A parametric surface.</td></tr></tbody></table></td></tr><tr><td>meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ;</td></tr></tbody></table>", "markdown": "| <table><thead></thead><tbody><tr><td>tri amesh_aniso: :mesher amesh_iso : :mesher</td><td>the_mesher; aux_mesher;</td></tr><tr><td>tri tri amesh_ani so: :mesher: :data_type surface_type</td><td>data (pos, connectE2) ; S(some parameters) ; 11 A parametric surface.</td></tr></tbody></table> |\n| --- |\n| meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ; |\n", "text": "| {LinL_0007} |\n| --- |\n| meshtools2d : : mesh_surface_param (S, the_mesher, data, aux_mesher , -0.05, 0. , 4) ; data.extract (pos, connectM) ; |\n"}, "coordinates": [{"x": 0.0963, "y": 0.3922}, {"x": 0.7822, "y": 0.3922}, {"x": 0.7822, "y": 0.4802}, {"x": 0.0963, "y": 0.4802}], "id": 525, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='526' data-category='paragraph' style='font-size:18px'>The class Surface for parameter S is a concept of parametric surface with members:</p>", "markdown": "The class Surface for parameter S is a concept of parametric surface with members:", "text": "The class Surface for parameter S is a concept of parametric surface with members:"}, "coordinates": [{"x": 0.0767, "y": 0.5164}, {"x": 0.7279, "y": 0.5164}, {"x": 0.7279, "y": 0.5333}, {"x": 0.0767, "y": 0.5333}], "id": 526, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='527' data-category='paragraph' style='font-size:14px'>int get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;<br>int get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const;<br>int get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;<br>int get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;</p>", "markdown": "int get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;\nint get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const;\nint get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;\nint get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;", "text": "int get_3D_coordinates (const Doub leMat& pos2D, DoubleMat& pos3D) const;\nint get_2D_coordinates (const Doub leMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const;\nint get_ tangents (const DoubleMat& pos2D, DoubleMat& T) const;\nint get_curvatures (const Doub leMat& pos2D, DoubleMat& C) const;"}, "coordinates": [{"x": 0.1048, "y": 0.5684}, {"x": 0.693, "y": 0.5684}, {"x": 0.693, "y": 0.6221}, {"x": 0.1048, "y": 0.6221}], "id": 527, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='528' data-category='paragraph' style='font-size:18px'>The Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points<br>located on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in<br>column #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)<br>when failed.</p>", "markdown": "The Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points\nlocated on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in\ncolumn #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)\nwhen failed.", "text": "The Surface: : get_3D_coordinates member should compute the 3-D coordinates of a set of 2-D points\nlocated on the reference plane. The 3-D coordinates of the point in column #j of pos2D must be returned in\ncolumn #j of pos3D. This function should return zero when successful and a negative value (-1 for instance)\nwhen failed."}, "coordinates": [{"x": 0.0766, "y": 0.6636}, {"x": 0.8991, "y": 0.6636}, {"x": 0.8991, "y": 0.7211}, {"x": 0.0766, "y": 0.7211}], "id": 528, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='529' data-category='paragraph' style='font-size:20px'>The Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give<br>the coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in<br>column #j of pos3D must be returned in column #j of pos2D. This function should return zero when<br>successful and a negative value (-1 for instance) when failed.</p>", "markdown": "The Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give\nthe coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in\ncolumn #j of pos3D must be returned in column #j of pos2D. This function should return zero when\nsuccessful and a negative value (-1 for instance) when failed.", "text": "The Surface : : get_2D_coordinates member is the reciprocal function of the previous one28. It should give\nthe coordinates in the 2-D reference plane of a set of 3-D points. The reference coordinates of the point in\ncolumn #j of pos3D must be returned in column #j of pos2D. This function should return zero when\nsuccessful and a negative value (-1 for instance) when failed."}, "coordinates": [{"x": 0.0762, "y": 0.7327}, {"x": 0.9194, "y": 0.7327}, {"x": 0.9194, "y": 0.7906}, {"x": 0.0762, "y": 0.7906}], "id": 529, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='530' data-category='paragraph' style='font-size:14px'>28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear<br>search. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is<br>not called for the new nodes generated inside the surface by the mesher.</p>", "markdown": "28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear\nsearch. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is\nnot called for the new nodes generated inside the surface by the mesher.", "text": "28 For parametric surfaces such as Bezier surfaces or NURB surfaces, the computation of reference coordinates often involves a non-linear\nsearch. However, this function is called only for the nodes on the boundary mesh and for the isolated nodes (i.e. the hard nodes only). It is\nnot called for the new nodes generated inside the surface by the mesher."}, "coordinates": [{"x": 0.0621, "y": 0.8757}, {"x": 0.9178, "y": 0.8757}, {"x": 0.9178, "y": 0.9131}, {"x": 0.0621, "y": 0.9131}], "id": 530, "page": 43}, {"category": "table", "content": {"html": "<table id='531' style='font-size:18px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>43</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5. .6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 43 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0102, "y": 0.948}, {"x": 1, "y": 0.948}, {"x": 1, "y": 1}, {"x": 0.0102, "y": 1}], "id": 531, "page": 43}, {"category": "paragraph", "content": {"html": "<p id='532' data-category='paragraph' style='font-size:16px'>nodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices<br>of the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix<br>data3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.<br>This array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before.</p>", "markdown": "nodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices\nof the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix\ndata3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.\nThis array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before.", "text": "nodeIDs is an auxiliary vector that can be helpful for an effective implementation. It contains the global indices\nof the nodes for which the 2-D coordinates are required. These are the indices in the the global matrix\ndata3D . pos. nodeIDs [j] is the node ID (i.e. column in data . pos) for the coordinates in column j of pos3D.\nThis array can be used for fast 2-D coordinates retrieval if these coordinates have been computed before."}, "coordinates": [{"x": 0.0767, "y": 0.0649}, {"x": 0.9209, "y": 0.0649}, {"x": 0.9209, "y": 0.1225}, {"x": 0.0767, "y": 0.1225}], "id": 532, "page": 44}, {"category": "paragraph", "content": {"html": "<br><p id='533' data-category='paragraph' style='font-size:16px'>aP aP<br>The Surface : : get_ tangents member should compute the two tangents Bu = and Bv =<br>au av<br>on the surface at a set of points given by their reference coordinates.</p>", "markdown": "aP aP\nThe Surface : : get_ tangents member should compute the two tangents Bu = and Bv =\nau av\non the surface at a set of points given by their reference coordinates.", "text": "aP aP\nThe Surface : : get_ tangents member should compute the two tangents Bu = and Bv =\nau av\non the surface at a set of points given by their reference coordinates."}, "coordinates": [{"x": 0.0731, "y": 0.1261}, {"x": 0.8483, "y": 0.1261}, {"x": 0.8483, "y": 0.1633}, {"x": 0.0731, "y": 0.1633}], "id": 533, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='534' data-category='paragraph' style='font-size:18px'>These tangents must not be normalized. They are the mere derivatives of the surface with respect to two<br>reference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T<br>(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),<br>then the next three are for the second tangent29.</p>", "markdown": "These tangents must not be normalized. They are the mere derivatives of the surface with respect to two\nreference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T\n(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),\nthen the next three are for the second tangent29.", "text": "These tangents must not be normalized. They are the mere derivatives of the surface with respect to two\nreference parameters. The two tangents at the point in column #j of pos2D must be returned in column #j of T\n(dimension 6 X N). The first three values are for the first tangent (with respect to the first reference coordinate),\nthen the next three are for the second tangent29."}, "coordinates": [{"x": 0.0766, "y": 0.1741}, {"x": 0.9199, "y": 0.1741}, {"x": 0.9199, "y": 0.2327}, {"x": 0.0766, "y": 0.2327}], "id": 534, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='535' data-category='paragraph' style='font-size:18px'>The Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given<br>by their reference coordinates (optional).</p>", "markdown": "The Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given\nby their reference coordinates (optional).", "text": "The Surface : : get_curvatures function may compute the curvatures of the surface at a set of points given\nby their reference coordinates (optional)."}, "coordinates": [{"x": 0.076, "y": 0.2426}, {"x": 0.9173, "y": 0.2426}, {"x": 0.9173, "y": 0.2738}, {"x": 0.076, "y": 0.2738}], "id": 535, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='536' data-category='paragraph' style='font-size:16px'>The curvatures H are 2 X 2 symmetric matrices defined as:</p>", "markdown": "The curvatures H are 2 X 2 symmetric matrices defined as:", "text": "The curvatures H are 2 X 2 symmetric matrices defined as:"}, "coordinates": [{"x": 0.0758, "y": 0.283}, {"x": 0.521, "y": 0.283}, {"x": 0.521, "y": 0.2991}, {"x": 0.0758, "y": 0.2991}], "id": 536, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='537' data-category='paragraph' style='font-size:20px'>a2P<br>· Huu du2 N)<br>Dot product between the derivative of Bu (first local tangent) with respect to u,<br>and the normal N to the surface.</p>", "markdown": "a2P\n· Huu du2 N)\nDot product between the derivative of Bu (first local tangent) with respect to u,\nand the normal N to the surface.", "text": "a2P\n· Huu du2 N)\nDot product between the derivative of Bu (first local tangent) with respect to u,\nand the normal N to the surface."}, "coordinates": [{"x": 0.0877, "y": 0.3057}, {"x": 0.7028, "y": 0.3057}, {"x": 0.7028, "y": 0.3792}, {"x": 0.0877, "y": 0.3792}], "id": 537, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='538' data-category='paragraph' style='font-size:18px'>O2P<br>· Huv = N<br>du av<br>Dot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv<br>(second local tangent) with respect to u, and the normal N to the surface.</p>", "markdown": "O2P\n· Huv = N\ndu av\nDot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv\n(second local tangent) with respect to u, and the normal N to the surface.", "text": "O2P\n· Huv = N\ndu av\nDot product between the derivative of Bu (first local tangent) with respect to V, or derivative of Bv\n(second local tangent) with respect to u, and the normal N to the surface."}, "coordinates": [{"x": 0.0903, "y": 0.3856}, {"x": 0.8451, "y": 0.3856}, {"x": 0.8451, "y": 0.4585}, {"x": 0.0903, "y": 0.4585}], "id": 538, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='539' data-category='paragraph' style='font-size:18px'>�2P<br>· Hw = N<br>av2<br>Dot product between the derivative of Bv (second local tangent) with respect to V,<br>and the normal N to the surface.</p>", "markdown": "�2P\n· Hw = N\nav2\nDot product between the derivative of Bv (second local tangent) with respect to V,\nand the normal N to the surface.", "text": "�2P\n· Hw = N\nav2\nDot product between the derivative of Bv (second local tangent) with respect to V,\nand the normal N to the surface."}, "coordinates": [{"x": 0.0882, "y": 0.4647}, {"x": 0.7272, "y": 0.4647}, {"x": 0.7272, "y": 0.5361}, {"x": 0.0882, "y": 0.5361}], "id": 539, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='540' data-category='paragraph' style='font-size:16px'>These three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.<br>uu</p>", "markdown": "These three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.\nuu", "text": "These three values must be stored column-wise in matrix H: H. on row 0, Hw on row 1 and Hw on row 2.\nuu"}, "coordinates": [{"x": 0.0737, "y": 0.5466}, {"x": 0.9012, "y": 0.5466}, {"x": 0.9012, "y": 0.5665}, {"x": 0.0737, "y": 0.5665}], "id": 540, "page": 44}, {"category": "paragraph", "content": {"html": "<br><p id='541' data-category='paragraph' style='font-size:18px'>You can leave the implementation of this member empty (returning -1 for instance). In this case approximate<br>curvatures computed from variations of the tangents will be used instead.</p>", "markdown": "You can leave the implementation of this member empty (returning -1 for instance). In this case approximate\ncurvatures computed from variations of the tangents will be used instead.", "text": "You can leave the implementation of this member empty (returning -1 for instance). In this case approximate\ncurvatures computed from variations of the tangents will be used instead."}, "coordinates": [{"x": 0.0753, "y": 0.5742}, {"x": 0.9015, "y": 0.5742}, {"x": 0.9015, "y": 0.6055}, {"x": 0.0753, "y": 0.6055}], "id": 541, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='542' data-category='paragraph' style='font-size:14px'>29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some<br>singularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to<br>the true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute<br>the target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and<br>replace them with a default one.</p>", "markdown": "29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some\nsingularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to\nthe true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute\nthe target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and\nreplace them with a default one.", "text": "29 This function should normally return in T only valid bases made of two non-null and non-colinear vectors. When the surface exhibits some\nsingularities, the user can \"correct\" the deficient bases. As far as the mesher is concerned, the exactness of these tangents with respect to\nthe true surface is not critical. More precisely, the tangent bases are used by the template function as transformation matrices to compute\nthe target anisotropic 2-D metrics array. The template function checks for deficient aniso metrics (derived from deficient local bases) and\nreplace them with a default one."}, "coordinates": [{"x": 0.0616, "y": 0.8526}, {"x": 0.9172, "y": 0.8526}, {"x": 0.9172, "y": 0.9131}, {"x": 0.0616, "y": 0.9131}], "id": 542, "page": 44}, {"category": "table", "content": {"html": "<table id='543' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials |\n| --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 44 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0089, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0089, "y": 1}], "id": 543, "page": 44}, {"category": "paragraph", "content": {"html": "<p id='544' data-category='paragraph' style='font-size:18px'>The template class AnisoMesher is a concept of triangle anisometric mesher with function:</p>", "markdown": "The template class AnisoMesher is a concept of triangle anisometric mesher with function:", "text": "The template class AnisoMesher is a concept of triangle anisometric mesher with function:"}, "coordinates": [{"x": 0.0757, "y": 0.0646}, {"x": 0.777, "y": 0.0646}, {"x": 0.777, "y": 0.0808}, {"x": 0.0757, "y": 0.0808}], "id": 544, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='545' data-category='paragraph' style='font-size:14px'>void run (typename AnisoMesher: :data_type& data) const;</p>", "markdown": "void run (typename AnisoMesher: :data_type& data) const;", "text": "void run (typename AnisoMesher: :data_type& data) const;"}, "coordinates": [{"x": 0.106, "y": 0.1052}, {"x": 0.5543, "y": 0.1052}, {"x": 0.5543, "y": 0.1204}, {"x": 0.106, "y": 0.1204}], "id": 545, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='546' data-category='paragraph' style='font-size:16px'>The mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers<br>CM2 TriaMesh Aniso or CM2 QuadMesh Aniso.</p>", "markdown": "The mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers\nCM2 TriaMesh Aniso or CM2 QuadMesh Aniso.", "text": "The mesh_surface_param function is designed to work with one of the 2-D anisotropic meshers\nCM2 TriaMesh Aniso or CM2 QuadMesh Aniso."}, "coordinates": [{"x": 0.0747, "y": 0.1535}, {"x": 0.8225, "y": 0.1535}, {"x": 0.8225, "y": 0.1834}, {"x": 0.0747, "y": 0.1834}], "id": 546, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='547' data-category='paragraph' style='font-size:16px'>The data3D parameter is the structure gathering all the input and output data, just like for any other<br>unstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:<br>: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher<br>used. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D<br>anisotropic metrics (dimensions 6 X NODS).</p>", "markdown": "The data3D parameter is the structure gathering all the input and output data, just like for any other\nunstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:\n: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher\nused. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D\nanisotropic metrics (dimensions 6 X NODS).", "text": "The data3D parameter is the structure gathering all the input and output data, just like for any other\nunstructured mesher of the CM2 MeshTools SDK. The type of data3D is either triamesh_aniso: : mesher:\n: data_type or quadmesh_aniso : : mesher : :data_type depending on the type of anisotropic mesher\nused. The point is that the pos matrix is now a 3-D coordinates matrix and the metrics array contains 3-D\nanisotropic metrics (dimensions 6 X NODS)."}, "coordinates": [{"x": 0.077, "y": 0.1949}, {"x": 0.9051, "y": 0.1949}, {"x": 0.9051, "y": 0.2665}, {"x": 0.077, "y": 0.2665}], "id": 547, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='548' data-category='paragraph' style='font-size:16px'>3D-anisotropic metrics are defined as below:</p>", "markdown": "3D-anisotropic metrics are defined as below:", "text": "3D-anisotropic metrics are defined as below:"}, "coordinates": [{"x": 0.077, "y": 0.2778}, {"x": 0.4196, "y": 0.2778}, {"x": 0.4196, "y": 0.2933}, {"x": 0.077, "y": 0.2933}], "id": 548, "page": 45}, {"category": "equation", "content": {"html": "<p id='549' data-category='equation'>$${\\cal M}_{j}=\\left[\\frac{a}{b}\\begin{array}{c c c}{{b}}&{{d}}\\\\ {{c}}&{{c}}&{{e}}\\\\ {{d}}&{{e}}&{{f}}\\end{array}\\right]$$</p>", "markdown": "$${\\cal M}_{j}=\\left[\\frac{a}{b}\\begin{array}{c c c}{{b}}&{{d}}\\\\ {{c}}&{{c}}&{{e}}\\\\ {{d}}&{{e}}&{{f}}\\end{array}\\right]$$", "text": "a b d\n M / = b c e\n d e f"}, "coordinates": [{"x": 0.1525, "y": 0.3051}, {"x": 0.3046, "y": 0.3051}, {"x": 0.3046, "y": 0.3589}, {"x": 0.1525, "y": 0.3589}], "id": 549, "page": 45}, {"category": "paragraph", "content": {"html": "<br><p id='550' data-category='paragraph' style='font-size:16px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.1546, "y": 0.3627}, {"x": 0.1954, "y": 0.3627}, {"x": 0.1954, "y": 0.3761}, {"x": 0.1546, "y": 0.3761}], "id": 550, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='551' data-category='paragraph' style='font-size:18px'>a > 0<br>ac - b2 > 0<br>Det (M ) >0<br>i.e. the three eigen values are > 0</p>", "markdown": "a > 0\nac - b2 > 0\nDet (M ) >0\ni.e. the three eigen values are > 0", "text": "a > 0\nac - b2 > 0\nDet (M ) >0\ni.e. the three eigen values are > 0"}, "coordinates": [{"x": 0.1716, "y": 0.384}, {"x": 0.4473, "y": 0.384}, {"x": 0.4473, "y": 0.4664}, {"x": 0.1716, "y": 0.4664}], "id": 551, "page": 45}, {"category": "figure", "content": {"html": "<br><figure id='552'><img style='font-size:14px' alt=\"a\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j\" data-coord=\"top-left:(630,534); bottom-right:(1032,784)\" /></figure>", "markdown": "![image](/image/placeholder)\na\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j", "text": "![image](/image/placeholder)\na\n* b\nc\ndata3D .metrics\nd\ne\ncolumn #j"}, "coordinates": [{"x": 0.5079, "y": 0.3049}, {"x": 0.8323, "y": 0.3049}, {"x": 0.8323, "y": 0.447}, {"x": 0.5079, "y": 0.447}], "id": 552, "page": 45}, {"category": "caption", "content": {"html": "<caption id='553' style='font-size:14px'>Figure 27 - Definition and storage of the 3-D anisotropic metrics.</caption>", "markdown": "Figure 27 - Definition and storage of the 3-D anisotropic metrics.", "text": "Figure 27 - Definition and storage of the 3-D anisotropic metrics."}, "coordinates": [{"x": 0.3, "y": 0.4816}, {"x": 0.6959, "y": 0.4816}, {"x": 0.6959, "y": 0.4961}, {"x": 0.3, "y": 0.4961}], "id": 553, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='554' data-category='paragraph' style='font-size:16px'>Let (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:</p>", "markdown": "Let (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:", "text": "Let (✓ 0, v ☑ V2) be the three ortho-normal vectors along the axes of the ellipsoid:"}, "coordinates": [{"x": 0.076, "y": 0.5377}, {"x": 0.6844, "y": 0.5377}, {"x": 0.6844, "y": 0.5554}, {"x": 0.076, "y": 0.5554}], "id": 554, "page": 45}, {"category": "equation", "content": {"html": "<p id='555' data-category='equation'>$$\\begin{array}{l}{\\left\\|\\mathbf{v}_{0}\\right\\|=\\left\\|\\mathbf{v}_{1}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=1}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{2}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1},\\mathbf{v}_{2}\\right)=1}\\end{array}$$</p>", "markdown": "$$\\begin{array}{l}{\\left\\|\\mathbf{v}_{0}\\right\\|=\\left\\|\\mathbf{v}_{1}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=\\left\\|\\mathbf{v}_{2}\\right\\|=1}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{2}\\right)=0}\\\\ {\\left(\\mathbf{v}_{0},\\mathbf{v}_{1},\\mathbf{v}_{2}\\right)=1}\\end{array}$$", "text": "|vo|=|va||v2|=1\n <V0,V1> =0\n <V0,V2> =0\n <V1,V2>=0\n <V0xV1,V2>=1"}, "coordinates": [{"x": 0.1179, "y": 0.5681}, {"x": 0.2948, "y": 0.5681}, {"x": 0.2948, "y": 0.6867}, {"x": 0.1179, "y": 0.6867}], "id": 555, "page": 45}, {"category": "heading1", "content": {"html": "<h1 id='556' style='font-size:20px'>Then, the metrics Mi writes:</h1>", "markdown": "# Then, the metrics Mi writes:", "text": "Then, the metrics Mi writes:"}, "coordinates": [{"x": 0.0765, "y": 0.7079}, {"x": 0.2878, "y": 0.7079}, {"x": 0.2878, "y": 0.7248}, {"x": 0.0765, "y": 0.7248}], "id": 556, "page": 45}, {"category": "equation", "content": {"html": "<p id='557' data-category='equation'>$$M_{j}=\\mathbf{B}\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h_{0}^{~2}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\frac{1}{h_{1}^{~2}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h_{2}^{~2}}}}\\end{array}\\right]$$</p>", "markdown": "$$M_{j}=\\mathbf{B}\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h_{0}^{~2}}}&{{0}}&{{0}}\\\\ {{0}}&{{\\frac{1}{h_{1}^{~2}}}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h_{2}^{~2}}}}\\end{array}\\right]$$", "text": "1\n 0 0\n 2\n ho\n 1\n M = B 0 0\n j 2\n h1\n 1\n 0 0\n 2\n h2"}, "coordinates": [{"x": 0.1137, "y": 0.7322}, {"x": 0.3479, "y": 0.7322}, {"x": 0.3479, "y": 0.8596}, {"x": 0.1137, "y": 0.8596}], "id": 557, "page": 45}, {"category": "paragraph", "content": {"html": "<br><p id='558' data-category='paragraph' style='font-size:14px'>T B</p>", "markdown": "T B", "text": "T B"}, "coordinates": [{"x": 0.3519, "y": 0.7858}, {"x": 0.3782, "y": 0.7858}, {"x": 0.3782, "y": 0.8013}, {"x": 0.3519, "y": 0.8013}], "id": 558, "page": 45}, {"category": "paragraph", "content": {"html": "<br><p id='559' data-category='paragraph' style='font-size:16px'>with:</p>", "markdown": "with:", "text": "with:"}, "coordinates": [{"x": 0.4015, "y": 0.7922}, {"x": 0.4393, "y": 0.7922}, {"x": 0.4393, "y": 0.8067}, {"x": 0.4015, "y": 0.8067}], "id": 559, "page": 45}, {"category": "paragraph", "content": {"html": "<br><p id='560' data-category='paragraph' style='font-size:20px'>B = [vo V1 v2]<br>stored column - wise</p>", "markdown": "B = [vo V1 v2]\nstored column - wise", "text": "B = [vo V1 v2]\nstored column - wise"}, "coordinates": [{"x": 0.4487, "y": 0.7764}, {"x": 0.6512, "y": 0.7764}, {"x": 0.6512, "y": 0.82}, {"x": 0.4487, "y": 0.82}], "id": 560, "page": 45}, {"category": "table", "content": {"html": "<table id='561' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMeshⓇ Iso/Aniso - 45 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0056, "y": 0.948}, {"x": 1, "y": 0.948}, {"x": 1, "y": 1}, {"x": 0.0056, "y": 1}], "id": 561, "page": 45}, {"category": "paragraph", "content": {"html": "<p id='562' data-category='paragraph' style='font-size:18px'>The 3-D metric equivalent to an isotropic size of h writes:</p>", "markdown": "The 3-D metric equivalent to an isotropic size of h writes:", "text": "The 3-D metric equivalent to an isotropic size of h writes:"}, "coordinates": [{"x": 0.0757, "y": 0.0641}, {"x": 0.5087, "y": 0.0641}, {"x": 0.5087, "y": 0.0807}, {"x": 0.0757, "y": 0.0807}], "id": 562, "page": 46}, {"category": "equation", "content": {"html": "<p id='563' data-category='equation'>$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$</p>", "markdown": "$$M_{j}=\\left[\\begin{array}{c c c}{{1}}&{{0}}&{{0}}\\\\ {{h^{2}}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{0}}\\\\ {{0}}&{{0}}&{{\\frac{1}{h^{2}}}}\\end{array}\\right]$$", "text": "1\n 0 0\n h2\n 1\n M = 0 0\n i h2\n 1\n 0 0\n h2"}, "coordinates": [{"x": 0.1193, "y": 0.09}, {"x": 0.3163, "y": 0.09}, {"x": 0.3163, "y": 0.2027}, {"x": 0.1193, "y": 0.2027}], "id": 563, "page": 46}, {"category": "paragraph", "content": {"html": "<p id='564' data-category='paragraph' style='font-size:18px'>A null matrix would lead to infinite sizes in the three directions (infinite sphere).</p>", "markdown": "A null matrix would lead to infinite sizes in the three directions (infinite sphere).", "text": "A null matrix would lead to infinite sizes in the three directions (infinite sphere)."}, "coordinates": [{"x": 0.0753, "y": 0.2226}, {"x": 0.6763, "y": 0.2226}, {"x": 0.6763, "y": 0.2395}, {"x": 0.0753, "y": 0.2395}], "id": 564, "page": 46}, {"category": "paragraph", "content": {"html": "<p id='565' data-category='paragraph' style='font-size:16px'>The two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error<br>between the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the<br>HTML reference manual for more information on them.</p>", "markdown": "The two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error\nbetween the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the\nHTML reference manual for more information on them.", "text": "The two parameters max_ chordal_error and chordal_control_ type are used to limit the chordal error\nbetween the mesh and the parametric surface. We don't use them in this tutorial (set to 0). Please refer to the\nHTML reference manual for more information on them."}, "coordinates": [{"x": 0.0763, "y": 0.2495}, {"x": 0.911, "y": 0.2495}, {"x": 0.911, "y": 0.2936}, {"x": 0.0763, "y": 0.2936}], "id": 565, "page": 46}, {"category": "paragraph", "content": {"html": "<p id='566' data-category='paragraph' style='font-size:18px'>This first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric<br>surface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit<br>square [0 1] X [0 1].</p>", "markdown": "This first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric\nsurface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit\nsquare [0 1] X [0 1].", "text": "This first example illustrates the use of the anisotropic mesh as the intermediate mesh. Here, the parametric\nsurface to be meshed is plane but its boundaries are curved (sinusoidal). The parameters' range is the unit\nsquare [0 1] X [0 1]."}, "coordinates": [{"x": 0.0762, "y": 0.3038}, {"x": 0.9011, "y": 0.3038}, {"x": 0.9011, "y": 0.3495}, {"x": 0.0762, "y": 0.3495}], "id": 566, "page": 46}, {"category": "figure", "content": {"html": "<figure id='567'><img style='font-size:20px' alt=\"✓\n+ P(x,y,z)\nQ(u,v)\nu\" data-coord=\"top-left:(206,653); bottom-right:(1021,1013)\" /></figure>", "markdown": "![image](/image/placeholder)\n✓\n+ P(x,y,z)\nQ(u,v)\nu", "text": "![image](/image/placeholder)\n✓\n+ P(x,y,z)\nQ(u,v)\nu"}, "coordinates": [{"x": 0.1663, "y": 0.3724}, {"x": 0.8229, "y": 0.3724}, {"x": 0.8229, "y": 0.578}, {"x": 0.1663, "y": 0.578}], "id": 567, "page": 46}, {"category": "caption", "content": {"html": "<caption id='568' style='font-size:14px'>Figure 28 - Mapping between the reference space and the surface.</caption>", "markdown": "Figure 28 - Mapping between the reference space and the surface.", "text": "Figure 28 - Mapping between the reference space and the surface."}, "coordinates": [{"x": 0.293, "y": 0.5933}, {"x": 0.7049, "y": 0.5933}, {"x": 0.7049, "y": 0.6076}, {"x": 0.293, "y": 0.6076}], "id": 568, "page": 46}, {"category": "paragraph", "content": {"html": "<p id='569' data-category='paragraph' style='font-size:18px'>The source of this example is as follow:</p>", "markdown": "The source of this example is as follow:", "text": "The source of this example is as follow:"}, "coordinates": [{"x": 0.0763, "y": 0.6721}, {"x": 0.3774, "y": 0.6721}, {"x": 0.3774, "y": 0.6885}, {"x": 0.0763, "y": 0.6885}], "id": 569, "page": 46}, {"category": "table", "content": {"html": "<table id='570' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 46 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0047, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0047, "y": 1}], "id": 570, "page": 46}, {"category": "paragraph", "content": {"html": "<p id='571' data-category='paragraph' style='font-size:18px'>#include \"stdafx.h\"</p>", "markdown": "#include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1052, "y": 0.0851}, {"x": 0.2644, "y": 0.0851}, {"x": 0.2644, "y": 0.0979}, {"x": 0.1052, "y": 0.0979}], "id": 571, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='572' data-category='paragraph' style='font-size:18px'>/*The Surface class implements the functions needed by mesh_surface_param* /<br>struct surface</p>", "markdown": "/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface", "text": "/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface"}, "coordinates": [{"x": 0.1067, "y": 0.1056}, {"x": 0.7158, "y": 0.1056}, {"x": 0.7158, "y": 0.128}, {"x": 0.1067, "y": 0.128}], "id": 572, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='573' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1283}, {"x": 0.1187, "y": 0.1283}, {"x": 0.1187, "y": 0.1376}, {"x": 0.1094, "y": 0.1376}], "id": 573, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='574' data-category='paragraph' style='font-size:18px'>11 Constructor (parameters to define the surface should be passed here) ·<br>surface (double Lx, double Ly, double a = 0.5)</p>", "markdown": "11 Constructor (parameters to define the surface should be passed here) ·\nsurface (double Lx, double Ly, double a = 0.5)", "text": "11 Constructor (parameters to define the surface should be passed here) ·\nsurface (double Lx, double Ly, double a = 0.5)"}, "coordinates": [{"x": 0.1069, "y": 0.1367}, {"x": 0.691, "y": 0.1367}, {"x": 0.691, "y": 0.1636}, {"x": 0.1069, "y": 0.1636}], "id": 574, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='575' data-category='paragraph' style='font-size:18px'>_Lx(Lx) , _Ly(Ly) , _a(a) {</p>", "markdown": "_Lx(Lx) , _Ly(Ly) , _a(a) {", "text": "_Lx(Lx) , _Ly(Ly) , _a(a) {"}, "coordinates": [{"x": 0.1395, "y": 0.1588}, {"x": 0.3518, "y": 0.1588}, {"x": 0.3518, "y": 0.1707}, {"x": 0.1395, "y": 0.1707}], "id": 575, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='576' data-category='paragraph' style='font-size:14px'>:</p>", "markdown": ":", "text": ":"}, "coordinates": [{"x": 0.1345, "y": 0.1609}, {"x": 0.1411, "y": 0.1609}, {"x": 0.1411, "y": 0.1676}, {"x": 0.1345, "y": 0.1676}], "id": 576, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='577' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.3579, "y": 0.1592}, {"x": 0.3672, "y": 0.1592}, {"x": 0.3672, "y": 0.1689}, {"x": 0.3579, "y": 0.1689}], "id": 577, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='578' data-category='paragraph' style='font-size:18px'>11 Computes the 3D coordinates.<br>int get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const</p>", "markdown": "11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const", "text": "11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const"}, "coordinates": [{"x": 0.109, "y": 0.1786}, {"x": 0.6841, "y": 0.1786}, {"x": 0.6841, "y": 0.2023}, {"x": 0.109, "y": 0.2023}], "id": 578, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='579' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.2006}, {"x": 0.1187, "y": 0.2006}, {"x": 0.1187, "y": 0.2103}, {"x": 0.1094, "y": 0.2103}], "id": 579, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='580' data-category='paragraph' style='font-size:16px'>const size_t NODS(pos2D.cols()) ;<br>double u, ✓ , X , y , z;</p>", "markdown": "const size_t NODS(pos2D.cols()) ;\ndouble u, ✓ , X , y , z;", "text": "const size_t NODS(pos2D.cols()) ;\ndouble u, ✓ , X , y , z;"}, "coordinates": [{"x": 0.1277, "y": 0.2091}, {"x": 0.4316, "y": 0.2091}, {"x": 0.4316, "y": 0.2319}, {"x": 0.1277, "y": 0.2319}], "id": 580, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='581' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() != 2) return -1; 11 Error.</p>", "markdown": "if (pos2D.rows() != 2) return -1; 11 Error.", "text": "if (pos2D.rows() != 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1337, "y": 0.2393}, {"x": 0.4979, "y": 0.2393}, {"x": 0.4979, "y": 0.2535}, {"x": 0.1337, "y": 0.2535}], "id": 581, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='582' data-category='paragraph' style='font-size:18px'>if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))<br>pos3D.resize(3, NODS) ;</p>", "markdown": "if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;", "text": "if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;"}, "coordinates": [{"x": 0.1353, "y": 0.261}, {"x": 0.5288, "y": 0.261}, {"x": 0.5288, "y": 0.284}, {"x": 0.1353, "y": 0.284}], "id": 582, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='583' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1325, "y": 0.2918}, {"x": 0.4013, "y": 0.2918}, {"x": 0.4013, "y": 0.3066}, {"x": 0.1325, "y": 0.3066}], "id": 583, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='584' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.3038}, {"x": 0.143, "y": 0.3038}, {"x": 0.143, "y": 0.3135}, {"x": 0.1338, "y": 0.3135}], "id": 584, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='585' data-category='paragraph' style='font-size:14px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j) ;<br>X = u * _Lx;<br>y = ✓ * _Ly * (1. + _a * : :sin(x)) ;<br>Z = 0. ;<br>pos3D(0, j) = x;<br>pos3D(1, j) = y;<br>pos3D(2, j) = z;</p>", "markdown": "u = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = u * _Lx;\ny = ✓ * _Ly * (1. + _a * : :sin(x)) ;\nZ = 0. ;\npos3D(0, j) = x;\npos3D(1, j) = y;\npos3D(2, j) = z;", "text": "u = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = u * _Lx;\ny = ✓ * _Ly * (1. + _a * : :sin(x)) ;\nZ = 0. ;\npos3D(0, j) = x;\npos3D(1, j) = y;\npos3D(2, j) = z;"}, "coordinates": [{"x": 0.1538, "y": 0.3135}, {"x": 0.4415, "y": 0.3135}, {"x": 0.4415, "y": 0.4007}, {"x": 0.1538, "y": 0.4007}], "id": 585, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='586' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1326, "y": 0.3967}, {"x": 0.1419, "y": 0.3967}, {"x": 0.1419, "y": 0.4064}, {"x": 0.1326, "y": 0.4064}], "id": 586, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='587' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>", "markdown": "return 0; 11 OK.", "text": "return 0; 11 OK."}, "coordinates": [{"x": 0.1326, "y": 0.4054}, {"x": 0.3023, "y": 0.4054}, {"x": 0.3023, "y": 0.4182}, {"x": 0.1326, "y": 0.4182}], "id": 587, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='588' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1073, "y": 0.4167}, {"x": 0.1175, "y": 0.4167}, {"x": 0.1175, "y": 0.4286}, {"x": 0.1073, "y": 0.4286}], "id": 588, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='589' data-category='paragraph' style='font-size:18px'>11 Computes the reference coordinates (UV) · nodeIDs not used.<br>int get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const</p>", "markdown": "11 Computes the reference coordinates (UV) · nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const", "text": "11 Computes the reference coordinates (UV) · nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const"}, "coordinates": [{"x": 0.1069, "y": 0.4365}, {"x": 0.6828, "y": 0.4365}, {"x": 0.6828, "y": 0.4694}, {"x": 0.1069, "y": 0.4694}], "id": 589, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='590' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.4694}, {"x": 0.1187, "y": 0.4694}, {"x": 0.1187, "y": 0.4791}, {"x": 0.1094, "y": 0.4791}], "id": 590, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='591' data-category='paragraph' style='font-size:16px'>const size_t NODS(pos3D.cols()) ;<br>double u, ✓ , X , y;</p>", "markdown": "const size_t NODS(pos3D.cols()) ;\ndouble u, ✓ , X , y;", "text": "const size_t NODS(pos3D.cols()) ;\ndouble u, ✓ , X , y;"}, "coordinates": [{"x": 0.1294, "y": 0.4775}, {"x": 0.4342, "y": 0.4775}, {"x": 0.4342, "y": 0.5002}, {"x": 0.1294, "y": 0.5002}], "id": 591, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='592' data-category='paragraph' style='font-size:18px'>if (pos3D.rows() != 3) return -1; 11 Error.</p>", "markdown": "if (pos3D.rows() != 3) return -1; 11 Error.", "text": "if (pos3D.rows() != 3) return -1; 11 Error."}, "coordinates": [{"x": 0.1336, "y": 0.5086}, {"x": 0.4994, "y": 0.5086}, {"x": 0.4994, "y": 0.5219}, {"x": 0.1336, "y": 0.5219}], "id": 592, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='593' data-category='paragraph' style='font-size:18px'>if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))<br>pos2D.resize(2, NODS) ;</p>", "markdown": "if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;", "text": "if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;"}, "coordinates": [{"x": 0.133, "y": 0.5289}, {"x": 0.5294, "y": 0.5289}, {"x": 0.5294, "y": 0.5526}, {"x": 0.133, "y": 0.5526}], "id": 593, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='594' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1321, "y": 0.5601}, {"x": 0.4019, "y": 0.5601}, {"x": 0.4019, "y": 0.5754}, {"x": 0.1321, "y": 0.5754}], "id": 594, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='595' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.5725}, {"x": 0.143, "y": 0.5725}, {"x": 0.143, "y": 0.5822}, {"x": 0.1338, "y": 0.5822}], "id": 595, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='596' data-category='paragraph' style='font-size:16px'>X = pos3D(0, j) ;<br>y = pos3D(1, j);<br>u = X / Lx;<br>✓ = y / (_Ly * (1. + _a * : :sin(x))) ;<br>pos2D(0, j) = u;<br>pos2D(1, j) = V;</p>", "markdown": "X = pos3D(0, j) ;\ny = pos3D(1, j);\nu = X / Lx;\n✓ = y / (_Ly * (1. + _a * : :sin(x))) ;\npos2D(0, j) = u;\npos2D(1, j) = V;", "text": "X = pos3D(0, j) ;\ny = pos3D(1, j);\nu = X / Lx;\n✓ = y / (_Ly * (1. + _a * : :sin(x))) ;\npos2D(0, j) = u;\npos2D(1, j) = V;"}, "coordinates": [{"x": 0.1539, "y": 0.5827}, {"x": 0.4559, "y": 0.5827}, {"x": 0.4559, "y": 0.6471}, {"x": 0.1539, "y": 0.6471}], "id": 596, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='597' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1326, "y": 0.6448}, {"x": 0.1419, "y": 0.6448}, {"x": 0.1419, "y": 0.6544}, {"x": 0.1326, "y": 0.6544}], "id": 597, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='598' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>", "markdown": "return 0; 11 OK.", "text": "return 0; 11 OK."}, "coordinates": [{"x": 0.1342, "y": 0.6521}, {"x": 0.3032, "y": 0.6521}, {"x": 0.3032, "y": 0.6667}, {"x": 0.1342, "y": 0.6667}], "id": 598, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='599' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1077, "y": 0.6644}, {"x": 0.1173, "y": 0.6644}, {"x": 0.1173, "y": 0.6765}, {"x": 0.1077, "y": 0.6765}], "id": 599, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='600' data-category='paragraph' style='font-size:20px'>111 Computes the local tangents.<br>int get_tangents (const DoubleMat& pos2D, Doub leMat& T) const</p>", "markdown": "111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const", "text": "111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const"}, "coordinates": [{"x": 0.1085, "y": 0.6843}, {"x": 0.6038, "y": 0.6843}, {"x": 0.6038, "y": 0.7086}, {"x": 0.1085, "y": 0.7086}], "id": 600, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='601' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.7069}, {"x": 0.1187, "y": 0.7069}, {"x": 0.1187, "y": 0.7166}, {"x": 0.1094, "y": 0.7166}], "id": 601, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='602' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols());<br>double u, ✓ , x;</p>", "markdown": "const size_t NODS(pos2D.cols());\ndouble u, ✓ , x;", "text": "const size_t NODS(pos2D.cols());\ndouble u, ✓ , x;"}, "coordinates": [{"x": 0.1289, "y": 0.7151}, {"x": 0.432, "y": 0.7151}, {"x": 0.432, "y": 0.738}, {"x": 0.1289, "y": 0.738}], "id": 602, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='603' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>", "markdown": "if (pos2D.rows() く 2) return -1; 11 Error.", "text": "if (pos2D.rows() く 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1317, "y": 0.7463}, {"x": 0.4894, "y": 0.7463}, {"x": 0.4894, "y": 0.7603}, {"x": 0.1317, "y": 0.7603}], "id": 603, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='604' data-category='paragraph' style='font-size:18px'>if ((T.rows() != 6) 11 (T.cols() く NODS))<br>T.resize(6, NODS) ;</p>", "markdown": "if ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;", "text": "if ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;"}, "coordinates": [{"x": 0.1351, "y": 0.7666}, {"x": 0.4666, "y": 0.7666}, {"x": 0.4666, "y": 0.7906}, {"x": 0.1351, "y": 0.7906}], "id": 604, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='605' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1314, "y": 0.7979}, {"x": 0.4019, "y": 0.7979}, {"x": 0.4019, "y": 0.8123}, {"x": 0.1314, "y": 0.8123}], "id": 605, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='606' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.81}, {"x": 0.143, "y": 0.81}, {"x": 0.143, "y": 0.8197}, {"x": 0.1338, "y": 0.8197}], "id": 606, "page": 47}, {"category": "paragraph", "content": {"html": "<br><p id='607' data-category='paragraph' style='font-size:14px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j);<br>X = u * _Lx;<br>T(0, j) = _Lx;<br>T(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;</p>", "markdown": "u = pos2D(0, j) ;\n✓ = pos2D(1, j);\nX = u * _Lx;\nT(0, j) = _Lx;\nT(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;", "text": "u = pos2D(0, j) ;\n✓ = pos2D(1, j);\nX = u * _Lx;\nT(0, j) = _Lx;\nT(1, j) = ✓ * _Ly * _a * _Lx * : :cos (x) ;"}, "coordinates": [{"x": 0.1508, "y": 0.8185}, {"x": 0.4824, "y": 0.8185}, {"x": 0.4824, "y": 0.8749}, {"x": 0.1508, "y": 0.8749}], "id": 607, "page": 47}, {"category": "table", "content": {"html": "<table id='608' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 47 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0074, "y": 0.9486}, {"x": 0.9995, "y": 0.9486}, {"x": 0.9995, "y": 1}, {"x": 0.0074, "y": 1}], "id": 608, "page": 47}, {"category": "paragraph", "content": {"html": "<p id='609' data-category='paragraph' style='font-size:14px'>T(2, j) = ⊙ , ;<br>T(3, j) = 0. ;<br>T(4, j) = _Ly * (1. + _a * : :sin(x)) ;<br>T(5, j) = 0. ;</p>", "markdown": "T(2, j) = ⊙ , ;\nT(3, j) = 0. ;\nT(4, j) = _Ly * (1. + _a * : :sin(x)) ;\nT(5, j) = 0. ;", "text": "T(2, j) = ⊙ , ;\nT(3, j) = 0. ;\nT(4, j) = _Ly * (1. + _a * : :sin(x)) ;\nT(5, j) = 0. ;"}, "coordinates": [{"x": 0.1513, "y": 0.0848}, {"x": 0.4573, "y": 0.0848}, {"x": 0.4573, "y": 0.1299}, {"x": 0.1513, "y": 0.1299}], "id": 609, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='610' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1326, "y": 0.1283}, {"x": 0.1419, "y": 0.1283}, {"x": 0.1419, "y": 0.138}, {"x": 0.1326, "y": 0.138}], "id": 610, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='611' data-category='paragraph' style='font-size:18px'>return 0; 11 OK.</p>", "markdown": "return 0; 11 OK.", "text": "return 0; 11 OK."}, "coordinates": [{"x": 0.1331, "y": 0.1357}, {"x": 0.3034, "y": 0.1357}, {"x": 0.3034, "y": 0.1506}, {"x": 0.1331, "y": 0.1506}], "id": 611, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='612' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1068, "y": 0.147}, {"x": 0.1181, "y": 0.147}, {"x": 0.1181, "y": 0.1595}, {"x": 0.1068, "y": 0.1595}], "id": 612, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='613' data-category='paragraph' style='font-size:18px'>111 Computes the local curvatures.<br>int get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const</p>", "markdown": "111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const", "text": "111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const"}, "coordinates": [{"x": 0.1068, "y": 0.1682}, {"x": 0.6191, "y": 0.1682}, {"x": 0.6191, "y": 0.1914}, {"x": 0.1068, "y": 0.1914}], "id": 613, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='614' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1905}, {"x": 0.1187, "y": 0.1905}, {"x": 0.1187, "y": 0.2002}, {"x": 0.1094, "y": 0.2002}], "id": 614, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='615' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols()) in</p>", "markdown": "const size_t NODS(pos2D.cols()) in", "text": "const size_t NODS(pos2D.cols()) in"}, "coordinates": [{"x": 0.1319, "y": 0.1989}, {"x": 0.4309, "y": 0.1989}, {"x": 0.4309, "y": 0.2128}, {"x": 0.1319, "y": 0.2128}], "id": 615, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='616' data-category='paragraph' style='font-size:18px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>", "markdown": "if (pos2D.rows() く 2) return -1; 11 Error.", "text": "if (pos2D.rows() く 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1333, "y": 0.2187}, {"x": 0.4869, "y": 0.2187}, {"x": 0.4869, "y": 0.2329}, {"x": 0.1333, "y": 0.2329}], "id": 616, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='617' data-category='paragraph' style='font-size:18px'>if ((H. rows() != 3) 11 (H.cols() く NODS))<br>H. resize(3, NODS) ;</p>", "markdown": "if ((H. rows() != 3) 11 (H.cols() く NODS))\nH. resize(3, NODS) ;", "text": "if ((H. rows() != 3) 11 (H.cols() く NODS))\nH. resize(3, NODS) ;"}, "coordinates": [{"x": 0.1372, "y": 0.2393}, {"x": 0.4658, "y": 0.2393}, {"x": 0.4658, "y": 0.2633}, {"x": 0.1372, "y": 0.2633}], "id": 617, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='618' data-category='paragraph' style='font-size:14px'>H = ⊙ · ; 11 Null curvatures here (the surface is plane) ·<br>return 0;</p>", "markdown": "H = ⊙ · ; 11 Null curvatures here (the surface is plane) ·\nreturn 0;", "text": "H = ⊙ · ; 11 Null curvatures here (the surface is plane) ·\nreturn 0;"}, "coordinates": [{"x": 0.1221, "y": 0.271}, {"x": 0.6176, "y": 0.271}, {"x": 0.6176, "y": 0.294}, {"x": 0.1221, "y": 0.294}], "id": 618, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='619' data-category='paragraph' style='font-size:18px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1079, "y": 0.292}, {"x": 0.1167, "y": 0.292}, {"x": 0.1167, "y": 0.3043}, {"x": 0.1079, "y": 0.3043}], "id": 619, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='620' data-category='paragraph' style='font-size:18px'>111 Data members.<br>double _Lx, _Ly, _a;</p>", "markdown": "111 Data members.\ndouble _Lx, _Ly, _a;", "text": "111 Data members.\ndouble _Lx, _Ly, _a;"}, "coordinates": [{"x": 0.106, "y": 0.3119}, {"x": 0.3118, "y": 0.3119}, {"x": 0.3118, "y": 0.3357}, {"x": 0.106, "y": 0.3357}], "id": 620, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='621' data-category='paragraph' style='font-size:20px'>}; 11 surface</p>", "markdown": "}; 11 surface", "text": "}; 11 surface"}, "coordinates": [{"x": 0.1057, "y": 0.3434}, {"x": 0.2336, "y": 0.3434}, {"x": 0.2336, "y": 0.3575}, {"x": 0.1057, "y": 0.3575}], "id": 621, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='622' data-category='paragraph' style='font-size:20px'>111<br>int main()</p>", "markdown": "111\nint main()", "text": "111\nint main()"}, "coordinates": [{"x": 0.1068, "y": 0.375}, {"x": 0.1923, "y": 0.375}, {"x": 0.1923, "y": 0.3977}, {"x": 0.1068, "y": 0.3977}], "id": 622, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='623' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.3967}, {"x": 0.1187, "y": 0.3967}, {"x": 0.1187, "y": 0.4064}, {"x": 0.1094, "y": 0.4064}], "id": 623, "page": 48}, {"category": "table", "content": {"html": "<br><table id='624' style='font-size:16px'><thead></thead><tbody><tr><td>const</td><td>DoubleVec2</td><td>PO(0. , -0.5)</td><td>;</td></tr><tr><td>const</td><td>DoubleVec2</td><td>P1(1 · , -0.5)</td><td>;</td></tr><tr><td>const</td><td>DoubleVec2</td><td>P2(1 . , +0.5) ;</td><td></td></tr><tr><td>const</td><td>DoubleVec2</td><td>P3(0 · , +0.5) ;</td><td></td></tr><tr><td>DoubleMat</td><td></td><td>pos;</td><td></td></tr><tr><td>UIntVec</td><td></td><td>indicesG, indices;</td><td></td></tr><tr><td>DoubleVec</td><td></td><td>Us;</td><td></td></tr><tr><td>UIntMat</td><td></td><td>connectE2, connectM;</td><td></td></tr><tr><td>DoubleVec</td><td></td><td>sizesG, sizes;</td><td></td></tr><tr><td>const</td><td>double</td><td>Lx (10.) ;</td><td></td></tr><tr><td>const</td><td>double</td><td>Ly(6.0) ;</td><td></td></tr><tr><td>const</td><td>double</td><td>h0 (0.25) ;</td><td></td></tr><tr><td>surface</td><td></td><td>S(Lx, Ly, 0.5) ; 11 The parametric surface to be</td><td></td></tr></tbody></table>", "markdown": "| const | DoubleVec2 | PO(0. , -0.5) | ; |\n| --- | --- | --- | --- |\n| const | DoubleVec2 | P1(1 · , -0.5) | ; |\n| const | DoubleVec2 | P2(1 . , +0.5) ; |  |\n| const | DoubleVec2 | P3(0 · , +0.5) ; |  |\n| DoubleMat |  | pos; |  |\n| UIntVec |  | indicesG, indices; |  |\n| DoubleVec |  | Us; |  |\n| UIntMat |  | connectE2, connectM; |  |\n| DoubleVec |  | sizesG, sizes; |  |\n| const | double | Lx (10.) ; |  |\n| const | double | Ly(6.0) ; |  |\n| const | double | h0 (0.25) ; |  |\n| surface |  | S(Lx, Ly, 0.5) ; 11 The parametric surface to be |  |\n", "text": "| const | DoubleVec2 | PO(0. , -0.5) | ; |\n| --- | --- | --- | --- |\n| const | DoubleVec2 | P1(1 · , -0.5) | ; |\n| const | DoubleVec2 | P2(1 . , +0.5) ; |  |\n| const | DoubleVec2 | P3(0 · , +0.5) ; |  |\n| DoubleMat |  | pos; |  |\n| UIntVec |  | indicesG, indices; |  |\n| DoubleVec |  | Us; |  |\n| UIntMat |  | connectE2, connectM; |  |\n| DoubleVec |  | sizesG, sizes; |  |\n| const | double | Lx (10.) ; |  |\n| const | double | Ly(6.0) ; |  |\n| const | double | h0 (0.25) ; |  |\n| surface |  | S(Lx, Ly, 0.5) ; 11 The parametric surface to be |  |\n"}, "coordinates": [{"x": 0.132, "y": 0.4045}, {"x": 0.7128, "y": 0.4045}, {"x": 0.7128, "y": 0.5439}, {"x": 0.132, "y": 0.5439}], "id": 624, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='625' data-category='paragraph' style='font-size:18px'>meshed.</p>", "markdown": "meshed.", "text": "meshed."}, "coordinates": [{"x": 0.7201, "y": 0.5304}, {"x": 0.7778, "y": 0.5304}, {"x": 0.7778, "y": 0.5407}, {"x": 0.7201, "y": 0.5407}], "id": 625, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='626' data-category='paragraph' style='font-size:14px'>11 UNLOCK THE DLLs.<br>triamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;<br>,<br>triamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;<br>,</p>", "markdown": "11 UNLOCK THE DLLs.\ntriamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;\n,\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,", "text": "11 UNLOCK THE DLLs.\ntriamesh_aniso: :registration(\"Licensed to SMART Inc. \" \"B657DA67QZ01\") ;\n,\ntriamesh_iso: : registration(\"Licensed to SMART Inc. \" \"F53EA108BCWX\") ;\n,"}, "coordinates": [{"x": 0.1318, "y": 0.5494}, {"x": 0.7074, "y": 0.5494}, {"x": 0.7074, "y": 0.5844}, {"x": 0.1318, "y": 0.5844}], "id": 626, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='627' data-category='paragraph' style='font-size:14px'>pos . push_back(P0) ;<br>pos · push_back (P1) ;<br>pos · push_back (P2) ;<br>pos . push_back (P3) ;</p>", "markdown": "pos . push_back(P0) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;", "text": "pos . push_back(P0) ;\npos · push_back (P1) ;\npos · push_back (P2) ;\npos . push_back (P3) ;"}, "coordinates": [{"x": 0.132, "y": 0.5932}, {"x": 0.2761, "y": 0.5932}, {"x": 0.2761, "y": 0.6347}, {"x": 0.132, "y": 0.6347}], "id": 627, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='628' data-category='paragraph' style='font-size:14px'>11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.<br>meshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;<br>indicesG.pop_back() ;<br>meshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;<br>S. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·</p>", "markdown": "11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.\nmeshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;\nS. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·", "text": "11 GEOMETRIC SUPPORT FOR THE EXTERNAL CONTOUR.\nmeshtools1d : : mesh_straight(pos, ⊙ , 1, 1 . /100 · , 1. /100 . , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 1, 2, 1 · /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 2, 3, 1 . /100 · , 1 . /100 · , false, indicesG) ;\nindicesG.pop_back() ;\nmeshtools1d: : mesh_straight(pos, 3, 日, 1./100 · , 1. /100. , false, indicesG) ;\nS. get_3D_coordinates(pos, pos) ; 11 Map UV -> XYZ (same node IDs) ·"}, "coordinates": [{"x": 0.1311, "y": 0.6432}, {"x": 0.7253, "y": 0.6432}, {"x": 0.7253, "y": 0.7392}, {"x": 0.1311, "y": 0.7392}], "id": 628, "page": 48}, {"category": "paragraph", "content": {"html": "<p id='629' data-category='paragraph' style='font-size:18px'>11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.<br>sizesG. clear() ;<br>sizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.<br>meshtools1d: :mesh_line(pos, indicesG, sizesG, true,<br>1, UINT_MAX, O. , , indices, Us, sizes) ;<br>⊙ .<br>meshtools1d: : indices_to_connectE2(indices, connectE2) ;</p>", "markdown": "11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.\nsizesG. clear() ;\nsizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.\nmeshtools1d: :mesh_line(pos, indicesG, sizesG, true,\n1, UINT_MAX, O. , , indices, Us, sizes) ;\n⊙ .\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;", "text": "11 MESH THE EXTERNAL CONTOUR WITH UNIFORM SIZE HO.\nsizesG. clear() ;\nsizesG. resize(indicesG.size() , h0) ; 11 Uniform mesh size.\nmeshtools1d: :mesh_line(pos, indicesG, sizesG, true,\n1, UINT_MAX, O. , , indices, Us, sizes) ;\n⊙ .\nmeshtools1d: : indices_to_connectE2(indices, connectE2) ;"}, "coordinates": [{"x": 0.131, "y": 0.7466}, {"x": 0.6506, "y": 0.7466}, {"x": 0.6506, "y": 0.8114}, {"x": 0.131, "y": 0.8114}], "id": 629, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='630' data-category='paragraph' style='font-size:18px'>11 MESH THE SURFACE.</p>", "markdown": "11 MESH THE SURFACE.", "text": "11 MESH THE SURFACE."}, "coordinates": [{"x": 0.1321, "y": 0.8194}, {"x": 0.294, "y": 0.8194}, {"x": 0.294, "y": 0.8307}, {"x": 0.1321, "y": 0.8307}], "id": 630, "page": 48}, {"category": "paragraph", "content": {"html": "<br><p id='631' data-category='paragraph' style='font-size:18px'>triamesh_aniso: : mesher the_mesher, aux_mesher;<br>triamesh_aniso: : mesher: :data_type data(pos, connectE2) ;<br>meshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;<br>data.extract(pos, connectM) ;</p>", "markdown": "triamesh_aniso: : mesher the_mesher, aux_mesher;\ntriamesh_aniso: : mesher: :data_type data(pos, connectE2) ;\nmeshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;\ndata.extract(pos, connectM) ;", "text": "triamesh_aniso: : mesher the_mesher, aux_mesher;\ntriamesh_aniso: : mesher: :data_type data(pos, connectE2) ;\nmeshtools2d : : mesh_surface_param(S, the_mesher, data, aux_mesher, 0. , 0. , 0) ;\ndata.extract(pos, connectM) ;"}, "coordinates": [{"x": 0.1324, "y": 0.8245}, {"x": 0.7464, "y": 0.8245}, {"x": 0.7464, "y": 0.872}, {"x": 0.1324, "y": 0.872}], "id": 631, "page": 48}, {"category": "table", "content": {"html": "<table id='632' style='font-size:22px'><thead></thead><tbody><tr><td>TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 Ⓡ & Iso/Aniso - 48 tutorials</td></tr></tbody></table>", "markdown": "| TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 Ⓡ & Iso/Aniso - 48 tutorials |\n| --- | --- |\n", "text": "| TriaMesh CM2 QuadMeshⓇ Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 Ⓡ & Iso/Aniso - 48 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0081, "y": 0.9483}, {"x": 1, "y": 0.9483}, {"x": 1, "y": 1}, {"x": 0.0081, "y": 1}], "id": 632, "page": 48}, {"category": "heading1", "content": {"html": "<h1 id='633' style='font-size:18px'>data.print_info (&display_hdl) ;</h1>", "markdown": "# data.print_info (&display_hdl) ;", "text": "data.print_info (&display_hdl) ;"}, "coordinates": [{"x": 0.1315, "y": 0.0857}, {"x": 0.3756, "y": 0.0857}, {"x": 0.3756, "y": 0.0987}, {"x": 0.1315, "y": 0.0987}], "id": 633, "page": 49}, {"category": "paragraph", "content": {"html": "<p id='634' data-category='paragraph' style='font-size:14px'>/ / VISUALISATION.<br>meshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;</p>", "markdown": "/ / VISUALISATION.\nmeshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;", "text": "/ / VISUALISATION.\nmeshtools : : medit_output ( \" out. mesh\" , data · pos , data · connectM, CM2_FACET3) ;"}, "coordinates": [{"x": 0.1297, "y": 0.1048}, {"x": 0.724, "y": 0.1048}, {"x": 0.724, "y": 0.13}, {"x": 0.1297, "y": 0.13}], "id": 634, "page": 49}, {"category": "paragraph", "content": {"html": "<p id='635' data-category='paragraph' style='font-size:16px'>return 0;<br>} / / main</p>", "markdown": "return 0;\n} / / main", "text": "return 0;\n} / / main"}, "coordinates": [{"x": 0.1053, "y": 0.1377}, {"x": 0.2077, "y": 0.1377}, {"x": 0.2077, "y": 0.1598}, {"x": 0.1053, "y": 0.1598}], "id": 635, "page": 49}, {"category": "paragraph", "content": {"html": "<p id='636' data-category='paragraph' style='font-size:20px'>We present below the intermediate anisotropic meshes on the reference space (normally not shown) and the<br>final meshes on the parametric surface.</p>", "markdown": "We present below the intermediate anisotropic meshes on the reference space (normally not shown) and the\nfinal meshes on the parametric surface.", "text": "We present below the intermediate anisotropic meshes on the reference space (normally not shown) and the\nfinal meshes on the parametric surface."}, "coordinates": [{"x": 0.0762, "y": 0.2051}, {"x": 0.9078, "y": 0.2051}, {"x": 0.9078, "y": 0.236}, {"x": 0.0762, "y": 0.236}], "id": 636, "page": 49}, {"category": "table", "content": {"html": "<table id='637' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. 6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. 6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 49 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0048, "y": 0.9479}, {"x": 1, "y": 0.9479}, {"x": 1, "y": 1}, {"x": 0.0048, "y": 1}], "id": 637, "page": 49}, {"category": "figure", "content": {"html": "<figure id='638'><img alt=\"\" data-coord=\"top-left:(116,117); bottom-right:(594,591)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0938, "y": 0.0672}, {"x": 0.4787, "y": 0.0672}, {"x": 0.4787, "y": 0.3375}, {"x": 0.0938, "y": 0.3375}], "id": 638, "page": 50}, {"category": "figure", "content": {"html": "<br><figure id='639'><img alt=\"\" data-coord=\"top-left:(649,118); bottom-right:(1124,591)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5234, "y": 0.0676}, {"x": 0.9061, "y": 0.0676}, {"x": 0.9061, "y": 0.3373}, {"x": 0.5234, "y": 0.3373}], "id": 639, "page": 50}, {"category": "caption", "content": {"html": "<caption id='640' style='font-size:14px'>Figure 29 - 2-D anisotropic meshes in the reference space (UV).</caption>", "markdown": "Figure 29 - 2-D anisotropic meshes in the reference space (UV).", "text": "Figure 29 - 2-D anisotropic meshes in the reference space (UV)."}, "coordinates": [{"x": 0.3029, "y": 0.3477}, {"x": 0.6923, "y": 0.3477}, {"x": 0.6923, "y": 0.3615}, {"x": 0.3029, "y": 0.3615}], "id": 640, "page": 50}, {"category": "figure", "content": {"html": "<br><figure id='641'><img style='font-size:20px' alt=\"↓ ↓\" data-coord=\"top-left:(112,635); bottom-right:(1134,1238)\" /></figure>", "markdown": "![image](/image/placeholder)\n↓ ↓", "text": "![image](/image/placeholder)\n↓ ↓"}, "coordinates": [{"x": 0.091, "y": 0.3625}, {"x": 0.9143, "y": 0.3625}, {"x": 0.9143, "y": 0.7059}, {"x": 0.091, "y": 0.7059}], "id": 641, "page": 50}, {"category": "caption", "content": {"html": "<br><caption id='642' style='font-size:14px'>Figure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space.</caption>", "markdown": "Figure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space.", "text": "Figure 30 - Surface meshes (T3 and all-Q4) obtained via an anisotropic mesh in the reference space."}, "coordinates": [{"x": 0.1948, "y": 0.7005}, {"x": 0.8031, "y": 0.7005}, {"x": 0.8031, "y": 0.7152}, {"x": 0.1948, "y": 0.7152}], "id": 642, "page": 50}, {"category": "paragraph", "content": {"html": "<p id='643' data-category='paragraph' style='font-size:18px'>The next example is a true 3-D parametric surface (only the source code for the surface class is shown).</p>", "markdown": "The next example is a true 3-D parametric surface (only the source code for the surface class is shown).", "text": "The next example is a true 3-D parametric surface (only the source code for the surface class is shown)."}, "coordinates": [{"x": 0.0748, "y": 0.7641}, {"x": 0.8619, "y": 0.7641}, {"x": 0.8619, "y": 0.782}, {"x": 0.0748, "y": 0.782}], "id": 643, "page": 50}, {"category": "table", "content": {"html": "<table id='644' style='font-size:16px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5. .6 rev. February 2025</td><td>CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5. .6 rev. February 2025 | CM2 TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - 50 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0051, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0051, "y": 1}], "id": 644, "page": 50}, {"category": "heading1", "content": {"html": "<h1 id='645' style='font-size:20px'>#include \"stdafx.h\"</h1>", "markdown": "# #include \"stdafx.h\"", "text": "#include \"stdafx.h\""}, "coordinates": [{"x": 0.1053, "y": 0.085}, {"x": 0.2644, "y": 0.085}, {"x": 0.2644, "y": 0.0981}, {"x": 0.1053, "y": 0.0981}], "id": 645, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='646' data-category='paragraph' style='font-size:20px'>/*The Surface class implements the functions needed by mesh_surface_param* /<br>struct surface</p>", "markdown": "/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface", "text": "/*The Surface class implements the functions needed by mesh_surface_param* /\nstruct surface"}, "coordinates": [{"x": 0.1071, "y": 0.1056}, {"x": 0.7155, "y": 0.1056}, {"x": 0.7155, "y": 0.1281}, {"x": 0.1071, "y": 0.1281}], "id": 646, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='647' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1283}, {"x": 0.1187, "y": 0.1283}, {"x": 0.1187, "y": 0.1376}, {"x": 0.1094, "y": 0.1376}], "id": 647, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='648' data-category='paragraph' style='font-size:20px'>11 Constructor.<br>surface (double L, double H) : _L(L) , _H(H) { }</p>", "markdown": "11 Constructor.\nsurface (double L, double H) : _L(L) , _H(H) { }", "text": "11 Constructor.\nsurface (double L, double H) : _L(L) , _H(H) { }"}, "coordinates": [{"x": 0.1081, "y": 0.1355}, {"x": 0.4911, "y": 0.1355}, {"x": 0.4911, "y": 0.1595}, {"x": 0.1081, "y": 0.1595}], "id": 648, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='649' data-category='paragraph' style='font-size:20px'>11 Computes the 3D coordinates.<br>int get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const</p>", "markdown": "11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const", "text": "11 Computes the 3D coordinates.\nint get_3D_coordinates (const DoubleMat& pos2D, Doub leMat& pos3D) const"}, "coordinates": [{"x": 0.1075, "y": 0.1641}, {"x": 0.6855, "y": 0.1641}, {"x": 0.6855, "y": 0.1881}, {"x": 0.1075, "y": 0.1881}], "id": 649, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='650' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.1854}, {"x": 0.1187, "y": 0.1854}, {"x": 0.1187, "y": 0.1947}, {"x": 0.1094, "y": 0.1947}], "id": 650, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='651' data-category='paragraph' style='font-size:18px'>const size_t NODS(pos2D.cols());<br>double u, V, x, y , z;</p>", "markdown": "const size_t NODS(pos2D.cols());\ndouble u, V, x, y , z;", "text": "const size_t NODS(pos2D.cols());\ndouble u, V, x, y , z;"}, "coordinates": [{"x": 0.1299, "y": 0.1928}, {"x": 0.4313, "y": 0.1928}, {"x": 0.4313, "y": 0.2149}, {"x": 0.1299, "y": 0.2149}], "id": 651, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='652' data-category='paragraph' style='font-size:20px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>", "markdown": "if (pos2D.rows() く 2) return -1; 11 Error.", "text": "if (pos2D.rows() く 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1338, "y": 0.2211}, {"x": 0.4901, "y": 0.2211}, {"x": 0.4901, "y": 0.2353}, {"x": 0.1338, "y": 0.2353}], "id": 652, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='653' data-category='paragraph' style='font-size:20px'>if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))<br>pos3D.resize(3, NODS) ;</p>", "markdown": "if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;", "text": "if ((pos3D.rows() != 3) 11 (pos3D.cols() く NODS))\npos3D.resize(3, NODS) ;"}, "coordinates": [{"x": 0.1373, "y": 0.2403}, {"x": 0.5293, "y": 0.2403}, {"x": 0.5293, "y": 0.2623}, {"x": 0.1373, "y": 0.2623}], "id": 653, "page": 51}, {"category": "paragraph", "content": {"html": "<p id='654' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1323, "y": 0.2688}, {"x": 0.401, "y": 0.2688}, {"x": 0.401, "y": 0.2841}, {"x": 0.1323, "y": 0.2841}], "id": 654, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='655' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.2807}, {"x": 0.143, "y": 0.2807}, {"x": 0.143, "y": 0.29}, {"x": 0.1338, "y": 0.29}], "id": 655, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='656' data-category='paragraph' style='font-size:16px'>u = pos2D(0, j) ;<br>✓ = pos2D(1, j) ;<br>X = L * u;<br>y = 人 L * ✓;<br>Z = _H * : : cos (x) * : :cos (y) ;<br>pos3D(0, 1) = x;<br>pos3D(1, j) = y ;<br>pos3D(2, j) = z;</p>", "markdown": "u = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = L * u;\ny = 人 L * ✓;\nZ = _H * : : cos (x) * : :cos (y) ;\npos3D(0, 1) = x;\npos3D(1, j) = y ;\npos3D(2, j) = z;", "text": "u = pos2D(0, j) ;\n✓ = pos2D(1, j) ;\nX = L * u;\ny = 人 L * ✓;\nZ = _H * : : cos (x) * : :cos (y) ;\npos3D(0, 1) = x;\npos3D(1, j) = y ;\npos3D(2, j) = z;"}, "coordinates": [{"x": 0.1527, "y": 0.2934}, {"x": 0.3932, "y": 0.2934}, {"x": 0.3932, "y": 0.3687}, {"x": 0.1527, "y": 0.3687}], "id": 656, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='657' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1326, "y": 0.3658}, {"x": 0.1419, "y": 0.3658}, {"x": 0.1419, "y": 0.3755}, {"x": 0.1326, "y": 0.3755}], "id": 657, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='658' data-category='paragraph' style='font-size:20px'>return 0; 11 OK.</p>", "markdown": "return 0; 11 OK.", "text": "return 0; 11 OK."}, "coordinates": [{"x": 0.1317, "y": 0.3733}, {"x": 0.3029, "y": 0.3733}, {"x": 0.3029, "y": 0.3868}, {"x": 0.1317, "y": 0.3868}], "id": 658, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='659' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1083, "y": 0.3838}, {"x": 0.117, "y": 0.3838}, {"x": 0.117, "y": 0.3958}, {"x": 0.1083, "y": 0.3958}], "id": 659, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='660' data-category='paragraph' style='font-size:20px'>11 Computes the reference coordinates (UV) . nodeIDs not used.<br>int get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,<br>DoubleMat& pos2D) const</p>", "markdown": "11 Computes the reference coordinates (UV) . nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const", "text": "11 Computes the reference coordinates (UV) . nodeIDs not used.\nint get_2D_coordinates (const DoubleMat& pos3D, const UIntVec& nodeIDs,\nDoubleMat& pos2D) const"}, "coordinates": [{"x": 0.1066, "y": 0.4007}, {"x": 0.6828, "y": 0.4007}, {"x": 0.6828, "y": 0.4336}, {"x": 0.1066, "y": 0.4336}], "id": 660, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='661' data-category='paragraph' style='font-size:20px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.4323}, {"x": 0.1187, "y": 0.4323}, {"x": 0.1187, "y": 0.442}, {"x": 0.1094, "y": 0.442}], "id": 661, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='662' data-category='paragraph' style='font-size:20px'>const size_t NODS(pos3D.cols());<br>double u, V, x, y;</p>", "markdown": "const size_t NODS(pos3D.cols());\ndouble u, V, x, y;", "text": "const size_t NODS(pos3D.cols());\ndouble u, V, x, y;"}, "coordinates": [{"x": 0.1276, "y": 0.4395}, {"x": 0.434, "y": 0.4395}, {"x": 0.434, "y": 0.462}, {"x": 0.1276, "y": 0.462}], "id": 662, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='663' data-category='paragraph' style='font-size:18px'>if (pos3D.rows() く 2) return -1; 11 Error.</p>", "markdown": "if (pos3D.rows() く 2) return -1; 11 Error.", "text": "if (pos3D.rows() く 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1334, "y": 0.4677}, {"x": 0.4905, "y": 0.4677}, {"x": 0.4905, "y": 0.4816}, {"x": 0.1334, "y": 0.4816}], "id": 663, "page": 51}, {"category": "paragraph", "content": {"html": "<p id='664' data-category='paragraph' style='font-size:20px'>if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))<br>pos2D.resize(2, NODS) ;</p>", "markdown": "if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;", "text": "if ((pos2D.rows() != 2) 11 (pos2D.cols() く NODS))\npos2D.resize(2, NODS) ;"}, "coordinates": [{"x": 0.137, "y": 0.4871}, {"x": 0.5288, "y": 0.4871}, {"x": 0.5288, "y": 0.5104}, {"x": 0.137, "y": 0.5104}], "id": 664, "page": 51}, {"category": "paragraph", "content": {"html": "<p id='665' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1322, "y": 0.5153}, {"x": 0.4019, "y": 0.5153}, {"x": 0.4019, "y": 0.5306}, {"x": 0.1322, "y": 0.5306}], "id": 665, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='666' data-category='paragraph' style='font-size:20px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.5272}, {"x": 0.143, "y": 0.5272}, {"x": 0.143, "y": 0.5369}, {"x": 0.1338, "y": 0.5369}], "id": 666, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='667' data-category='paragraph' style='font-size:18px'>X = pos3D(0, j) ;<br>y = pos3D(1, j) ;<br>u = X / _L;<br>✓ = y / _L :<br>pos2D(0, j) = u;<br>pos2D(1, j) = V;</p>", "markdown": "X = pos3D(0, j) ;\ny = pos3D(1, j) ;\nu = X / _L;\n✓ = y / _L :\npos2D(0, j) = u;\npos2D(1, j) = V;", "text": "X = pos3D(0, j) ;\ny = pos3D(1, j) ;\nu = X / _L;\n✓ = y / _L :\npos2D(0, j) = u;\npos2D(1, j) = V;"}, "coordinates": [{"x": 0.1506, "y": 0.5361}, {"x": 0.2925, "y": 0.5361}, {"x": 0.2925, "y": 0.5969}, {"x": 0.1506, "y": 0.5969}], "id": 667, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='668' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1326, "y": 0.594}, {"x": 0.1419, "y": 0.594}, {"x": 0.1419, "y": 0.6036}, {"x": 0.1326, "y": 0.6036}], "id": 668, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='669' data-category='paragraph' style='font-size:20px'>return 0; 11 OK.</p>", "markdown": "return 0; 11 OK.", "text": "return 0; 11 OK."}, "coordinates": [{"x": 0.132, "y": 0.6005}, {"x": 0.3039, "y": 0.6005}, {"x": 0.3039, "y": 0.6155}, {"x": 0.132, "y": 0.6155}], "id": 669, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='670' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1085, "y": 0.6117}, {"x": 0.1174, "y": 0.6117}, {"x": 0.1174, "y": 0.6233}, {"x": 0.1085, "y": 0.6233}], "id": 670, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='671' data-category='paragraph' style='font-size:20px'>111 Computes the local tangents.<br>int get_tangents (const DoubleMat& pos2D, Doub leMat& T) const</p>", "markdown": "111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const", "text": "111 Computes the local tangents.\nint get_tangents (const DoubleMat& pos2D, Doub leMat& T) const"}, "coordinates": [{"x": 0.1088, "y": 0.6297}, {"x": 0.6018, "y": 0.6297}, {"x": 0.6018, "y": 0.6528}, {"x": 0.1088, "y": 0.6528}], "id": 671, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='672' data-category='paragraph' style='font-size:20px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1094, "y": 0.651}, {"x": 0.1187, "y": 0.651}, {"x": 0.1187, "y": 0.6607}, {"x": 0.1094, "y": 0.6607}], "id": 672, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='673' data-category='paragraph' style='font-size:18px'>const size_t</p>", "markdown": "const size_t", "text": "const size_t"}, "coordinates": [{"x": 0.132, "y": 0.6588}, {"x": 0.2333, "y": 0.6588}, {"x": 0.2333, "y": 0.6711}, {"x": 0.132, "y": 0.6711}], "id": 673, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='674' data-category='paragraph' style='font-size:22px'>NODS(pos2D.cols());</p>", "markdown": "NODS(pos2D.cols());", "text": "NODS(pos2D.cols());"}, "coordinates": [{"x": 0.2766, "y": 0.6587}, {"x": 0.4319, "y": 0.6587}, {"x": 0.4319, "y": 0.6714}, {"x": 0.2766, "y": 0.6714}], "id": 674, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='675' data-category='paragraph' style='font-size:20px'>double</p>", "markdown": "double", "text": "double"}, "coordinates": [{"x": 0.1317, "y": 0.669}, {"x": 0.1837, "y": 0.669}, {"x": 0.1837, "y": 0.6794}, {"x": 0.1317, "y": 0.6794}], "id": 675, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='676' data-category='paragraph' style='font-size:16px'>u, ✓ , X , y;</p>", "markdown": "u, ✓ , X , y;", "text": "u, ✓ , X , y;"}, "coordinates": [{"x": 0.2769, "y": 0.671}, {"x": 0.3675, "y": 0.671}, {"x": 0.3675, "y": 0.6809}, {"x": 0.2769, "y": 0.6809}], "id": 676, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='677' data-category='paragraph' style='font-size:20px'>if (pos2D.rows() く 2) return -1; 11 Error.</p>", "markdown": "if (pos2D.rows() く 2) return -1; 11 Error.", "text": "if (pos2D.rows() く 2) return -1; 11 Error."}, "coordinates": [{"x": 0.1337, "y": 0.6861}, {"x": 0.4885, "y": 0.6861}, {"x": 0.4885, "y": 0.7005}, {"x": 0.1337, "y": 0.7005}], "id": 677, "page": 51}, {"category": "paragraph", "content": {"html": "<p id='678' data-category='paragraph' style='font-size:20px'>if ((T.rows() != 6) 11 (T.cols() く NODS))<br>T.resize(6, NODS) ;</p>", "markdown": "if ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;", "text": "if ((T.rows() != 6) 11 (T.cols() く NODS))\nT.resize(6, NODS) ;"}, "coordinates": [{"x": 0.1357, "y": 0.7058}, {"x": 0.4641, "y": 0.7058}, {"x": 0.4641, "y": 0.7286}, {"x": 0.1357, "y": 0.7286}], "id": 678, "page": 51}, {"category": "paragraph", "content": {"html": "<p id='679' data-category='paragraph' style='font-size:18px'>for (size_t j = 0; j く NODS; ++j)</p>", "markdown": "for (size_t j = 0; j く NODS; ++j)", "text": "for (size_t j = 0; j く NODS; ++j)"}, "coordinates": [{"x": 0.1317, "y": 0.7341}, {"x": 0.4023, "y": 0.7341}, {"x": 0.4023, "y": 0.7487}, {"x": 0.1317, "y": 0.7487}], "id": 679, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='680' data-category='paragraph' style='font-size:18px'>{</p>", "markdown": "{", "text": "{"}, "coordinates": [{"x": 0.1338, "y": 0.746}, {"x": 0.143, "y": 0.746}, {"x": 0.143, "y": 0.7552}, {"x": 0.1338, "y": 0.7552}], "id": 680, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='681' data-category='paragraph' style='font-size:18px'>u = pos2D(0, j) ;</p>", "markdown": "u = pos2D(0, j) ;", "text": "u = pos2D(0, j) ;"}, "coordinates": [{"x": 0.1557, "y": 0.7544}, {"x": 0.2861, "y": 0.7544}, {"x": 0.2861, "y": 0.7662}, {"x": 0.1557, "y": 0.7662}], "id": 681, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='682' data-category='paragraph' style='font-size:18px'>✓ = pos2D(1, j) ;</p>", "markdown": "✓ = pos2D(1, j) ;", "text": "✓ = pos2D(1, j) ;"}, "coordinates": [{"x": 0.1556, "y": 0.7642}, {"x": 0.2867, "y": 0.7642}, {"x": 0.2867, "y": 0.7765}, {"x": 0.1556, "y": 0.7765}], "id": 682, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='683' data-category='paragraph' style='font-size:14px'>X = L * u;</p>", "markdown": "X = L * u;", "text": "X = L * u;"}, "coordinates": [{"x": 0.1564, "y": 0.7741}, {"x": 0.2468, "y": 0.7741}, {"x": 0.2468, "y": 0.7849}, {"x": 0.1564, "y": 0.7849}], "id": 683, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='684' data-category='paragraph' style='font-size:16px'>L * V;</p>", "markdown": "L * V;", "text": "L * V;"}, "coordinates": [{"x": 0.1973, "y": 0.7839}, {"x": 0.2467, "y": 0.7839}, {"x": 0.2467, "y": 0.7946}, {"x": 0.1973, "y": 0.7946}], "id": 684, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='685' data-category='paragraph' style='font-size:14px'>y =</p>", "markdown": "y =", "text": "y ="}, "coordinates": [{"x": 0.1554, "y": 0.7851}, {"x": 0.1827, "y": 0.7851}, {"x": 0.1827, "y": 0.7946}, {"x": 0.1554, "y": 0.7946}], "id": 685, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='686' data-category='paragraph' style='font-size:18px'>T(O, j) =</p>", "markdown": "T(O, j) =", "text": "T(O, j) ="}, "coordinates": [{"x": 0.1559, "y": 0.7921}, {"x": 0.2315, "y": 0.7921}, {"x": 0.2315, "y": 0.8046}, {"x": 0.1559, "y": 0.8046}], "id": 686, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='687' data-category='paragraph' style='font-size:18px'>� ;</p>", "markdown": "� ;", "text": "� ;"}, "coordinates": [{"x": 0.2454, "y": 0.7937}, {"x": 0.2621, "y": 0.7937}, {"x": 0.2621, "y": 0.804}, {"x": 0.2454, "y": 0.804}], "id": 687, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='688' data-category='paragraph' style='font-size:18px'>T(1, ]</p>", "markdown": "T(1, ]", "text": "T(1, ]"}, "coordinates": [{"x": 0.1564, "y": 0.8022}, {"x": 0.206, "y": 0.8022}, {"x": 0.206, "y": 0.813}, {"x": 0.1564, "y": 0.813}], "id": 688, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='689' data-category='paragraph' style='font-size:16px'>= 0.</p>", "markdown": "= 0.", "text": "= 0."}, "coordinates": [{"x": 0.221, "y": 0.8019}, {"x": 0.2538, "y": 0.8019}, {"x": 0.2538, "y": 0.8118}, {"x": 0.221, "y": 0.8118}], "id": 689, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='690' data-category='paragraph' style='font-size:20px'>T(2, ]</p>", "markdown": "T(2, ]", "text": "T(2, ]"}, "coordinates": [{"x": 0.1556, "y": 0.8107}, {"x": 0.2068, "y": 0.8107}, {"x": 0.2068, "y": 0.8238}, {"x": 0.1556, "y": 0.8238}], "id": 690, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='691' data-category='paragraph' style='font-size:16px'>= - H * _L * : :sin(x) * : :cos (y) ;</p>", "markdown": "= - H * _L * : :sin(x) * : :cos (y) ;", "text": "= - H * _L * : :sin(x) * : :cos (y) ;"}, "coordinates": [{"x": 0.2208, "y": 0.8115}, {"x": 0.4877, "y": 0.8115}, {"x": 0.4877, "y": 0.8237}, {"x": 0.2208, "y": 0.8237}], "id": 691, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='692' data-category='paragraph' style='font-size:14px'>,</p>", "markdown": ",", "text": ","}, "coordinates": [{"x": 0.2554, "y": 0.8266}, {"x": 0.2615, "y": 0.8266}, {"x": 0.2615, "y": 0.832}, {"x": 0.2554, "y": 0.832}], "id": 692, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='693' data-category='paragraph' style='font-size:16px'>T(3, ] ) = 0. F</p>", "markdown": "T(3, ] ) = 0. F", "text": "T(3, ] ) = 0. F"}, "coordinates": [{"x": 0.1558, "y": 0.8208}, {"x": 0.2615, "y": 0.8208}, {"x": 0.2615, "y": 0.8339}, {"x": 0.1558, "y": 0.8339}], "id": 693, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='694' data-category='paragraph' style='font-size:14px'>= L ;</p>", "markdown": "= L ;", "text": "= L ;"}, "coordinates": [{"x": 0.2211, "y": 0.8312}, {"x": 0.262, "y": 0.8312}, {"x": 0.262, "y": 0.8406}, {"x": 0.2211, "y": 0.8406}], "id": 694, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='695' data-category='paragraph' style='font-size:20px'>T(4, J</p>", "markdown": "T(4, J", "text": "T(4, J"}, "coordinates": [{"x": 0.1557, "y": 0.8295}, {"x": 0.2073, "y": 0.8295}, {"x": 0.2073, "y": 0.8425}, {"x": 0.1557, "y": 0.8425}], "id": 695, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='696' data-category='paragraph' style='font-size:16px'>T(5, j) = - H * _L * : :cos (x) * : :sin(y) ;</p>", "markdown": "T(5, j) = - H * _L * : :cos (x) * : :sin(y) ;", "text": "T(5, j) = - H * _L * : :cos (x) * : :sin(y) ;"}, "coordinates": [{"x": 0.1557, "y": 0.84}, {"x": 0.4882, "y": 0.84}, {"x": 0.4882, "y": 0.8524}, {"x": 0.1557, "y": 0.8524}], "id": 696, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='697' data-category='paragraph' style='font-size:20px'>return 0;</p>", "markdown": "return 0;", "text": "return 0;"}, "coordinates": [{"x": 0.1331, "y": 0.859}, {"x": 0.2061, "y": 0.859}, {"x": 0.2061, "y": 0.87}, {"x": 0.1331, "y": 0.87}], "id": 697, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='698' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.132, "y": 0.8502}, {"x": 0.1425, "y": 0.8502}, {"x": 0.1425, "y": 0.8604}, {"x": 0.132, "y": 0.8604}], "id": 698, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='699' data-category='paragraph' style='font-size:20px'>11 OK.</p>", "markdown": "11 OK.", "text": "11 OK."}, "coordinates": [{"x": 0.2529, "y": 0.8587}, {"x": 0.3027, "y": 0.8587}, {"x": 0.3027, "y": 0.8706}, {"x": 0.2529, "y": 0.8706}], "id": 699, "page": 51}, {"category": "paragraph", "content": {"html": "<br><p id='700' data-category='paragraph' style='font-size:20px'>}</p>", "markdown": "}", "text": "}"}, "coordinates": [{"x": 0.1066, "y": 0.8678}, {"x": 0.1176, "y": 0.8678}, {"x": 0.1176, "y": 0.8806}, {"x": 0.1066, "y": 0.8806}], "id": 700, "page": 51}, {"category": "table", "content": {"html": "<table id='701' style='font-size:22px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMeshⓇ Iso/Aniso - 51 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0076, "y": 0.9483}, {"x": 0.9994, "y": 0.9483}, {"x": 0.9994, "y": 1}, {"x": 0.0076, "y": 1}], "id": 701, "page": 51}, {"category": "figure", "content": {"html": "<figure id='702'><img style='font-size:14px' alt=\"111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface.\" data-coord=\"top-left:(94,109); bottom-right:(1108,738)\" /></figure>", "markdown": "![image](/image/placeholder)\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface.", "text": "![image](/image/placeholder)\n111 Computes the local curvatures.\nint get_curvatures (const DoubleMat& pos2D, Doub leMat& H) const\n{\nconst size_t NODS(pos2D.cols ()) ;\ndouble u, V, x, y;\nif (pos2D.rows () く 2) return -1; 11 Error.\nif ((H.rows() != 3) 11 (H.cols() く NODS))\nH.resize(3, NODS) ;\nfor (size_t j = ⌀; j く NODS; ++j)\n{\nu = pos2D (日, j) ;\n✓ = pos2D(1, j) ;\nX = _L * u;\ny = _L * ✓\nSX = : : sin(x) ; CX = ::cos(x) ;\nsy = : : sin(y) ; cy = : :cos (y) ;\nS = H * L*_L / : : sqrt(1. + _H*_H * (sx*sx*cy*cy + cx*cx*sy*sy)) ;\nH(0, j) cx*cy * s;\nH(1, j) = + sx*sy * s;\nH(2, j) = - cx*cy * s;\n}\nreturn 0;\n}\n11 Data members.\ndouble _L, _H;\n}; 11 surface."}, "coordinates": [{"x": 0.0761, "y": 0.0622}, {"x": 0.8932, "y": 0.0622}, {"x": 0.8932, "y": 0.4213}, {"x": 0.0761, "y": 0.4213}], "id": 702, "page": 52}, {"category": "table", "content": {"html": "<table id='703' style='font-size:18px'><thead></thead><tbody><tr><td>Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials</td></tr></tbody></table>", "markdown": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials |\n| --- | --- |\n", "text": "| Ⓒ Computing Objects /version 5.6 rev. February 2025 | CM2 TriaMesh Ⓡ & CM2 QuadMesh� Iso/Aniso - 52 tutorials |\n| --- | --- |\n"}, "coordinates": [{"x": 0.0048, "y": 0.9482}, {"x": 1, "y": 0.9482}, {"x": 1, "y": 1}, {"x": 0.0048, "y": 1}], "id": 703, "page": 52}, {"category": "figure", "content": {"html": "<figure id='704'><img alt=\"\" data-coord=\"top-left:(116,116); bottom-right:(593,593)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.0939, "y": 0.0666}, {"x": 0.4782, "y": 0.0666}, {"x": 0.4782, "y": 0.3385}, {"x": 0.0939, "y": 0.3385}], "id": 704, "page": 53}, {"category": "figure", "content": {"html": "<br><figure id='705'><img alt=\"\" data-coord=\"top-left:(648,117); bottom-right:(1123,592)\" /></figure>", "markdown": "![image](/image/placeholder)\n", "text": "![image](/image/placeholder)\n"}, "coordinates": [{"x": 0.5226, "y": 0.0672}, {"x": 0.9052, "y": 0.0672}, {"x": 0.9052, "y": 0.3376}, {"x": 0.5226, "y": 0.3376}], "id": 705, "page": 53}, {"category": "caption", "content": {"html": "<caption id='706' style='font-size:14px'>Figure 31 - 2-D anisotropic meshes in the reference space (UV).</caption>", "markdown": "Figure 31 - 2-D anisotropic meshes in the reference space (UV).", "text": "Figure 31 - 2-D anisotropic meshes in the reference space (UV)."}, "coordinates": [{"x": 0.3025, "y": 0.3475}, {"x": 0.6926, "y": 0.3475}, {"x": 0.6926, "y": 0.3617}, {"x": 0.3025, "y": 0.3617}], "id": 706, "page": 53}, {"category": "figure", "content": {"html": "<br><figure id='707'><img style='font-size:20px' alt=\"↓ ↓\" data-coord=\"top-left:(114,635); bottom-right:(1134,1242)\" /></figure>", "markdown": "![image](/image/placeholder)\n↓ ↓", "text": "![image](/image/placeholder)\n↓ ↓"}, "coordinates": [{"x": 0.092, "y": 0.3623}, {"x": 0.9143, "y": 0.3623}, {"x": 0.9143, "y": 0.7082}, {"x": 0.092, "y": 0.7082}], "id": 707, "page": 53}, {"category": "caption", "content": {"html": "<br><caption id='708' style='font-size:14px'>Figure 32 - 3-D surface meshes (T3 and all Q4).</caption>", "markdown": "Figure 32 - 3-D surface meshes (T3 and all Q4).", "text": "Figure 32 - 3-D surface meshes (T3 and all Q4)."}, "coordinates": [{"x": 0.3523, "y": 0.7022}, {"x": 0.6443, "y": 0.7022}, {"x": 0.6443, "y": 0.7175}, {"x": 0.3523, "y": 0.7175}], "id": 708, "page": 53}, {"category": "paragraph", "content": {"html": "<p id='709' data-category='paragraph' style='font-size:16px'>Notes:</p>", "markdown": "Notes:", "text": "Notes:"}, "coordinates": [{"x": 0.0774, "y": 0.7412}, {"x": 0.1315, "y": 0.7412}, {"x": 0.1315, "y": 0.7558}, {"x": 0.0774, "y": 0.7558}], "id": 709, "page": 53}, {"category": "list", "content": {"html": "<p id='710' data-category='list' style='font-size:16px'>· This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface<br>is available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2<br>SurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).<br>For more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.<br>· When there is only a discrete representation of the surface available (such as a tessellated surface), a<br>different method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and<br>CM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.<br>For more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.<br>· A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing.</p>", "markdown": "- · This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface\n- is available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2\n- SurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).\n- For more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.\n- · When there is only a discrete representation of the surface available (such as a tessellated surface), a\n- different method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and\n- CM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.\n- For more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.\n- · A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing.\n", "text": "· This solution for 3-D surface meshing can be used only when a \"mathematical\" representation of the surface\nis available (through a CAD kernel for instance). This method is implemented in CM2 SurfMeshⓇ T3 and CM2\nSurfMeshⓇ Q4 (based also on the OpenCascadeⓇ OCCT kernel).\nFor more information, refer to CM2 SurfMesh T3/Q4 - tutorials and reference manual.\n· When there is only a discrete representation of the surface available (such as a tessellated surface), a\ndifferent method can be used: 3-D patch remeshing implemented in CM2 SurfRemeshⓇ T3 and\nCM2 SurfRemeshⓇ Q4, two other components of the CM2 MeshToolsⓇ library.\nFor more information, refer to CM2 SurfRemesh T3/Q4 - tutorials and reference manual.\n· A similar template function (meshtools1d : : mesh_curve_param) is available for parametric curve meshing."}, "coordinates": [{"x": 0.0873, "y": 0.7659}, {"x": 0.9228, "y": 0.7659}, {"x": 0.9228, "y": 0.9021}, {"x": 0.0873, "y": 0.9021}], "id": 710, "page": 53}, {"category": "table", "content": {"html": "<table id='711' style='font-size:16px'><thead></thead><tbody><tr><td>CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025</td><td>TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials</td><td>53</td></tr></tbody></table>", "markdown": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 53 |\n| --- | --- | --- |\n", "text": "| CM2 Ⓒ Computing Objects /version 5.6 rev. February 2025 | TriaMeshⓇ & CM2 QuadMesh� Iso/Aniso - tutorials | 53 |\n| --- | --- | --- |\n"}, "coordinates": [{"x": 0.0114, "y": 0.9484}, {"x": 1, "y": 0.9484}, {"x": 1, "y": 1}, {"x": 0.0114, "y": 1}], "id": 711, "page": 53}, {"category": "heading1", "content": {"html": "<h1 id='712' style='font-size:14px'>COMPUTING<br>OBJECTS</h1>", "markdown": "# COMPUTING\nOBJECTS", "text": "COMPUTING\nOBJECTS"}, "coordinates": [{"x": 0.1554, "y": 0.0523}, {"x": 0.4199, "y": 0.0523}, {"x": 0.4199, "y": 0.1145}, {"x": 0.1554, "y": 0.1145}], "id": 712, "page": 54}], "model": "document-parse-250618", "ocr": true, "usage": {"pages": 54}}